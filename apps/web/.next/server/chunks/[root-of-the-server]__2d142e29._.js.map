{"version":3,"sources":["../../../../../node_modules/convex/dist/esm/server/api.js","../../../../../node_modules/convex/dist/esm/values/validator.js","../../../../../node_modules/convex/dist/esm/values/errors.js","../../../../../node_modules/convex/dist/esm/values/compare.js","../../../../../node_modules/convex/dist/esm/values/index.js","../../../../../node_modules/convex/dist/esm/server/impl/syscall.js","../../../../../node_modules/convex/dist/esm/server/components/paths.js","../../../../../node_modules/convex/dist/esm/server/impl/actions_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/vector_search_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/authentication_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/filter_builder_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/index_range_builder_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/search_filter_builder_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/query_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/database_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/scheduler_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/storage_impl.js","../../../../../node_modules/convex/dist/esm/server/impl/registration_impl.js","../../../../../node_modules/convex/dist/esm/server/pagination.js","../../../../../node_modules/convex/dist/esm/values/value.js","../../../../../node_modules/convex/dist/esm/server/cron.js","../../../../../node_modules/convex/dist/esm/server/router.js","../../../../../node_modules/convex/dist/esm/server/components/index.js","../../../../../node_modules/convex/dist/esm/server/schema.js","../../../../../node_modules/convex/dist/esm/server/index.js","../../../../../node_modules/convex/dist/esm/browser/sync/udf_path_utils.js","../../../../../node_modules/convex/dist/esm/browser/sync/local_state.js","../../../../../node_modules/convex/dist/esm/browser/sync/request_manager.js","../../../../../node_modules/convex/dist/esm/browser/sync/optimistic_updates_impl.js","../../../../../node_modules/convex/dist/esm/browser/sync/remote_query_set.js","../../../../../node_modules/convex/dist/esm/browser/sync/protocol.js","../../../../../node_modules/convex/dist/esm/browser/sync/web_socket_manager.js","../../../../../node_modules/convex/dist/esm/browser/sync/authentication_manager.js","../../../../../node_modules/convex/dist/esm/browser/sync/client.js","../../../../../node_modules/convex/dist/esm/browser/simple_client-node.js","../../../../../node_modules/convex/dist/esm/browser/http_client.js","../../../../../node_modules/convex/dist/esm/browser/index.js","../../../../../node_modules/convex/dist/esm/browser/sync/paginated_query_client.js","../../../../../node_modules/convex/dist/esm/browser/simple_client.js","../../../../../node_modules/convex/dist/esm/browser/index-node.js","../../../../../node_modules/convex/dist/esm/values/validators.js","../../../../../node_modules/convex/dist/esm/server/search_filter_builder.js","../../../../../node_modules/convex/dist/esm/browser/sync/metrics.js","../../../../../node_modules/convex/dist/esm/server/index_range_builder.js","../../../../../node_modules/convex/dist/esm/values/base64.js","../../../../../node_modules/convex/dist/esm/browser/logging.js","../../../../../node_modules/convex/dist/esm/server/filter_builder.js","../../../../../node_modules/convex/dist/esm/server/vector_search.js","../../../../../node_modules/convex/dist/esm/vendor/long.js","../../../../../node_modules/convex/dist/esm/browser/sync/pagination.js","../../../../../node_modules/convex/dist/esm/values/compare_utf8.js","../../../../../node_modules/convex/dist/esm/index.js","../../../../../node_modules/convex/dist/esm/server/functionName.js","../../../../../node_modules/convex/dist/esm/browser/sync/session.js","../../../../../node_modules/convex/dist/esm/vendor/jwt-decode/index.js","../../../../../node_modules/convex/dist/esm/common/index.js","../../../../../node_modules/convex/dist/esm/server/impl/validate.js","../../../../../apps/web/src/lib/convexClient.ts","../../../../../packages/backend/convex/_generated/api.js"],"sourcesContent":["\"use strict\";\nimport { functionName } from \"./functionName.js\";\nimport { getFunctionAddress } from \"./components/paths.js\";\nexport function getFunctionName(functionReference) {\n  const address = getFunctionAddress(functionReference);\n  if (address.name === void 0) {\n    if (address.functionHandle !== void 0) {\n      throw new Error(\n        `Expected function reference like \"api.file.func\" or \"internal.file.func\", but received function handle ${address.functionHandle}`\n      );\n    } else if (address.reference !== void 0) {\n      throw new Error(\n        `Expected function reference in the current component like \"api.file.func\" or \"internal.file.func\", but received reference ${address.reference}`\n      );\n    }\n    throw new Error(\n      `Expected function reference like \"api.file.func\" or \"internal.file.func\", but received ${JSON.stringify(address)}`\n    );\n  }\n  if (typeof functionReference === \"string\") return functionReference;\n  const name = functionReference[functionName];\n  if (!name) {\n    throw new Error(`${functionReference} is not a functionReference`);\n  }\n  return name;\n}\nexport function makeFunctionReference(name) {\n  return { [functionName]: name };\n}\nfunction createApi(pathParts = []) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createApi(newParts);\n      } else if (prop === functionName) {\n        if (pathParts.length < 2) {\n          const found = [\"api\", ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`api.moduleName.functionName\\`. Found: \\`${found}\\``\n          );\n        }\n        const path = pathParts.slice(0, -1).join(\"/\");\n        const exportName = pathParts[pathParts.length - 1];\n        if (exportName === \"default\") {\n          return path;\n        } else {\n          return path + \":\" + exportName;\n        }\n      } else if (prop === Symbol.toStringTag) {\n        return \"FunctionReference\";\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nexport function filterApi(api) {\n  return api;\n}\nexport function justInternal(api) {\n  return api;\n}\nexport function justPublic(api) {\n  return api;\n}\nexport function justQueries(api) {\n  return api;\n}\nexport function justMutations(api) {\n  return api;\n}\nexport function justActions(api) {\n  return api;\n}\nexport function justPaginatedQueries(api) {\n  return api;\n}\nexport function justSchedulable(api) {\n  return api;\n}\nexport const anyApi = createApi();\n//# sourceMappingURL=api.js.map\n","\"use strict\";\nimport {\n  VAny,\n  VArray,\n  VBoolean,\n  VBytes,\n  VFloat64,\n  VId,\n  VInt64,\n  VLiteral,\n  VNull,\n  VObject,\n  VRecord,\n  VString,\n  VUnion\n} from \"./validators.js\";\nexport function isValidator(v2) {\n  return !!v2.isConvexValidator;\n}\nexport function asObjectValidator(obj) {\n  if (isValidator(obj)) {\n    return obj;\n  } else {\n    return v.object(obj);\n  }\n}\nexport const v = {\n  /**\n   * Validates that the value corresponds to an ID of a document in given table.\n   * @param tableName The name of the table.\n   */\n  id: (tableName) => {\n    return new VId({\n      isOptional: \"required\",\n      tableName\n    });\n  },\n  /**\n   * Validates that the value is of type Null.\n   */\n  null: () => {\n    return new VNull({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   *\n   * Alias for `v.float64()`\n   */\n  number: () => {\n    return new VFloat64({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   */\n  float64: () => {\n    return new VFloat64({ isOptional: \"required\" });\n  },\n  /**\n   * @deprecated Use `v.int64()` instead\n   */\n  bigint: () => {\n    return new VInt64({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is of Convex type Int64 (BigInt in JS).\n   */\n  int64: () => {\n    return new VInt64({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is of type Boolean.\n   */\n  boolean: () => {\n    return new VBoolean({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is of type String.\n   */\n  string: () => {\n    return new VString({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is of Convex type Bytes (constructed in JS via `ArrayBuffer`).\n   */\n  bytes: () => {\n    return new VBytes({ isOptional: \"required\" });\n  },\n  /**\n   * Validates that the value is equal to the given literal value.\n   * @param literal The literal value to compare against.\n   */\n  literal: (literal) => {\n    return new VLiteral({ isOptional: \"required\", value: literal });\n  },\n  /**\n   * Validates that the value is an Array of the given element type.\n   * @param element The validator for the elements of the array.\n   */\n  array: (element) => {\n    return new VArray({ isOptional: \"required\", element });\n  },\n  /**\n   * Validates that the value is an Object with the given properties.\n   * @param fields An object specifying the validator for each property.\n   */\n  object: (fields) => {\n    return new VObject({ isOptional: \"required\", fields });\n  },\n  /**\n   * Validates that the value is a Record with keys and values that match the given types.\n   * @param keys The validator for the keys of the record. This cannot contain string literals.\n   * @param values The validator for the values of the record.\n   */\n  record: (keys, values) => {\n    return new VRecord({\n      isOptional: \"required\",\n      key: keys,\n      value: values\n    });\n  },\n  /**\n   * Validates that the value matches one of the given validators.\n   * @param members The validators to match against.\n   */\n  union: (...members) => {\n    return new VUnion({\n      isOptional: \"required\",\n      members\n    });\n  },\n  /**\n   * Does not validate the value.\n   */\n  any: () => {\n    return new VAny({ isOptional: \"required\" });\n  },\n  /**\n   * Allows not specifying a value for a property in an Object.\n   * @param value The property value validator to make optional.\n   *\n   * ```typescript\n   * const objectWithOptionalFields = v.object({\n   *   requiredField: v.string(),\n   *   optionalField: v.optional(v.string()),\n   * });\n   * ```\n   */\n  optional: (value) => {\n    return value.asOptional();\n  },\n  /**\n   * Allows specifying a value or null.\n   */\n  nullable: (value) => {\n    return v.union(value, v.null());\n  }\n};\n//# sourceMappingURL=validator.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar _a, _b;\nimport { stringifyValueForError } from \"./value.js\";\nconst IDENTIFYING_FIELD = Symbol.for(\"ConvexError\");\nexport class ConvexError extends (_b = Error, _a = IDENTIFYING_FIELD, _b) {\n  constructor(data) {\n    super(typeof data === \"string\" ? data : stringifyValueForError(data));\n    __publicField(this, \"name\", \"ConvexError\");\n    __publicField(this, \"data\");\n    __publicField(this, _a, true);\n    this.data = data;\n  }\n}\n//# sourceMappingURL=errors.js.map\n","\"use strict\";\nimport { compareUTF8 } from \"./compare_utf8.js\";\nexport function compareValues(k1, k2) {\n  return compareAsTuples(makeComparable(k1), makeComparable(k2));\n}\nfunction compareAsTuples(a, b) {\n  if (a[0] === b[0]) {\n    return compareSameTypeValues(a[1], b[1]);\n  } else if (a[0] < b[0]) {\n    return -1;\n  }\n  return 1;\n}\nfunction compareSameTypeValues(v1, v2) {\n  if (v1 === void 0 || v1 === null) {\n    return 0;\n  }\n  if (typeof v1 === \"number\") {\n    if (typeof v2 !== \"number\") {\n      throw new Error(`Unexpected type ${v2}`);\n    }\n    return compareNumbers(v1, v2);\n  }\n  if (typeof v1 === \"string\") {\n    if (typeof v2 !== \"string\") {\n      throw new Error(`Unexpected type ${v2}`);\n    }\n    return compareUTF8(v1, v2);\n  }\n  if (typeof v1 === \"bigint\" || typeof v1 === \"boolean\" || typeof v1 === \"string\") {\n    return v1 < v2 ? -1 : v1 === v2 ? 0 : 1;\n  }\n  if (!Array.isArray(v1) || !Array.isArray(v2)) {\n    throw new Error(`Unexpected type ${v1}`);\n  }\n  for (let i = 0; i < v1.length && i < v2.length; i++) {\n    const cmp = compareAsTuples(v1[i], v2[i]);\n    if (cmp !== 0) {\n      return cmp;\n    }\n  }\n  if (v1.length < v2.length) {\n    return -1;\n  }\n  if (v1.length > v2.length) {\n    return 1;\n  }\n  return 0;\n}\nfunction compareNumbers(v1, v2) {\n  if (isNaN(v1) || isNaN(v2)) {\n    const buffer1 = new ArrayBuffer(8);\n    const buffer2 = new ArrayBuffer(8);\n    new DataView(buffer1).setFloat64(\n      0,\n      v1,\n      /* little-endian */\n      true\n    );\n    new DataView(buffer2).setFloat64(\n      0,\n      v2,\n      /* little-endian */\n      true\n    );\n    const v1Bits = BigInt(\n      new DataView(buffer1).getBigInt64(\n        0,\n        /* little-endian */\n        true\n      )\n    );\n    const v2Bits = BigInt(\n      new DataView(buffer2).getBigInt64(\n        0,\n        /* little-endian */\n        true\n      )\n    );\n    const v1Sign = (v1Bits & 0x8000000000000000n) !== 0n;\n    const v2Sign = (v2Bits & 0x8000000000000000n) !== 0n;\n    if (isNaN(v1) !== isNaN(v2)) {\n      if (isNaN(v1)) {\n        return v1Sign ? -1 : 1;\n      }\n      return v2Sign ? 1 : -1;\n    }\n    if (v1Sign !== v2Sign) {\n      return v1Sign ? -1 : 1;\n    }\n    return v1Bits < v2Bits ? -1 : v1Bits === v2Bits ? 0 : 1;\n  }\n  if (Object.is(v1, v2)) {\n    return 0;\n  }\n  if (Object.is(v1, -0)) {\n    return Object.is(v2, 0) ? -1 : -Math.sign(v2);\n  }\n  if (Object.is(v2, -0)) {\n    return Object.is(v1, 0) ? 1 : Math.sign(v1);\n  }\n  return v1 < v2 ? -1 : 1;\n}\nfunction makeComparable(v) {\n  if (v === void 0) {\n    return [0, void 0];\n  }\n  if (v === null) {\n    return [1, null];\n  }\n  if (typeof v === \"bigint\") {\n    return [2, v];\n  }\n  if (typeof v === \"number\") {\n    return [3, v];\n  }\n  if (typeof v === \"boolean\") {\n    return [4, v];\n  }\n  if (typeof v === \"string\") {\n    return [5, v];\n  }\n  if (v instanceof ArrayBuffer) {\n    return [6, Array.from(new Uint8Array(v)).map(makeComparable)];\n  }\n  if (Array.isArray(v)) {\n    return [7, v.map(makeComparable)];\n  }\n  const keys = Object.keys(v).sort();\n  const pojo = keys.map((k) => [k, v[k]]);\n  return [8, pojo.map(makeComparable)];\n}\n//# sourceMappingURL=compare.js.map\n","\"use strict\";\nexport { convexToJson, jsonToConvex } from \"./value.js\";\nexport { v, asObjectValidator } from \"./validator.js\";\nimport * as Base64 from \"./base64.js\";\nexport { Base64 };\nexport * from \"./errors.js\";\nexport { compareValues } from \"./compare.js\";\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nimport { ConvexError } from \"../../values/errors.js\";\nimport { jsonToConvex } from \"../../values/value.js\";\nexport function performSyscall(op, arg) {\n  if (typeof Convex === \"undefined\" || Convex.syscall === void 0) {\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  }\n  const resultStr = Convex.syscall(op, JSON.stringify(arg));\n  return JSON.parse(resultStr);\n}\nexport async function performAsyncSyscall(op, arg) {\n  if (typeof Convex === \"undefined\" || Convex.asyncSyscall === void 0) {\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  }\n  let resultStr;\n  try {\n    resultStr = await Convex.asyncSyscall(op, JSON.stringify(arg));\n  } catch (e) {\n    if (e.data !== void 0) {\n      const rethrown = new ConvexError(e.message);\n      rethrown.data = jsonToConvex(e.data);\n      throw rethrown;\n    }\n    throw new Error(e.message);\n  }\n  return JSON.parse(resultStr);\n}\nexport function performJsSyscall(op, arg) {\n  if (typeof Convex === \"undefined\" || Convex.jsSyscall === void 0) {\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  }\n  return Convex.jsSyscall(op, arg);\n}\n//# sourceMappingURL=syscall.js.map\n","\"use strict\";\nimport { functionName } from \"../functionName.js\";\nexport const toReferencePath = Symbol.for(\"toReferencePath\");\nexport function setReferencePath(obj, value) {\n  obj[toReferencePath] = value;\n}\nexport function extractReferencePath(reference) {\n  return reference[toReferencePath] ?? null;\n}\nexport function isFunctionHandle(s) {\n  return s.startsWith(\"function://\");\n}\nexport function getFunctionAddress(functionReference) {\n  let functionAddress;\n  if (typeof functionReference === \"string\") {\n    if (isFunctionHandle(functionReference)) {\n      functionAddress = { functionHandle: functionReference };\n    } else {\n      functionAddress = { name: functionReference };\n    }\n  } else if (functionReference[functionName]) {\n    functionAddress = { name: functionReference[functionName] };\n  } else {\n    const referencePath = extractReferencePath(functionReference);\n    if (!referencePath) {\n      throw new Error(`${functionReference} is not a functionReference`);\n    }\n    functionAddress = { reference: referencePath };\n  }\n  return functionAddress;\n}\n//# sourceMappingURL=paths.js.map\n","\"use strict\";\nimport { convexToJson, jsonToConvex } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\nfunction syscallArgs(requestId, functionReference, args) {\n  const address = getFunctionAddress(functionReference);\n  return {\n    ...address,\n    args: convexToJson(parseArgs(args)),\n    version,\n    requestId\n  };\n}\nexport function setupActionCalls(requestId) {\n  return {\n    runQuery: async (query, args) => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/query\",\n        syscallArgs(requestId, query, args)\n      );\n      return jsonToConvex(result);\n    },\n    runMutation: async (mutation, args) => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/mutation\",\n        syscallArgs(requestId, mutation, args)\n      );\n      return jsonToConvex(result);\n    },\n    runAction: async (action, args) => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/action\",\n        syscallArgs(requestId, action, args)\n      );\n      return jsonToConvex(result);\n    }\n  };\n}\n//# sourceMappingURL=actions_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { version } from \"../../index.js\";\nimport {\n  FilterExpression\n} from \"../vector_search.js\";\nimport { validateArg } from \"./validate.js\";\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nexport function setupActionVectorSearch(requestId) {\n  return async (tableName, indexName, query) => {\n    validateArg(tableName, 1, \"vectorSearch\", \"tableName\");\n    validateArg(indexName, 2, \"vectorSearch\", \"indexName\");\n    validateArg(query, 3, \"vectorSearch\", \"query\");\n    if (!query.vector || !Array.isArray(query.vector) || query.vector.length === 0) {\n      throw Error(\"`vector` must be a non-empty Array in vectorSearch\");\n    }\n    return await new VectorQueryImpl(\n      requestId,\n      tableName + \".\" + indexName,\n      query\n    ).collect();\n  };\n}\nexport class VectorQueryImpl {\n  constructor(requestId, indexName, query) {\n    __publicField(this, \"requestId\");\n    __publicField(this, \"state\");\n    this.requestId = requestId;\n    const filters = query.filter ? serializeExpression(query.filter(filterBuilderImpl)) : null;\n    this.state = {\n      type: \"preparing\",\n      query: {\n        indexName,\n        limit: query.limit,\n        vector: query.vector,\n        expressions: filters\n      }\n    };\n  }\n  async collect() {\n    if (this.state.type === \"consumed\") {\n      throw new Error(\"This query is closed and can't emit any more values.\");\n    }\n    const query = this.state.query;\n    this.state = { type: \"consumed\" };\n    const { results } = await performAsyncSyscall(\"1.0/actions/vectorSearch\", {\n      requestId: this.requestId,\n      version,\n      query\n    });\n    return results;\n  }\n}\nexport class ExpressionImpl extends FilterExpression {\n  constructor(inner) {\n    super();\n    __publicField(this, \"inner\");\n    this.inner = inner;\n  }\n  serialize() {\n    return this.inner;\n  }\n}\nexport function serializeExpression(expr) {\n  if (expr instanceof ExpressionImpl) {\n    return expr.serialize();\n  } else {\n    return { $literal: convexOrUndefinedToJson(expr) };\n  }\n}\nexport const filterBuilderImpl = {\n  //  Comparisons  /////////////////////////////////////////////////////////////\n  eq(fieldName, value) {\n    if (typeof fieldName !== \"string\") {\n      throw new Error(\"The first argument to `q.eq` must be a field name.\");\n    }\n    return new ExpressionImpl({\n      $eq: [\n        serializeExpression(new ExpressionImpl({ $field: fieldName })),\n        serializeExpression(value)\n      ]\n    });\n  },\n  //  Logic  ///////////////////////////////////////////////////////////////////\n  or(...exprs) {\n    return new ExpressionImpl({ $or: exprs.map(serializeExpression) });\n  }\n};\n//# sourceMappingURL=vector_search_impl.js.map\n","\"use strict\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nexport function setupAuth(requestId) {\n  return {\n    getUserIdentity: async () => {\n      return await performAsyncSyscall(\"1.0/getUserIdentity\", {\n        requestId\n      });\n    }\n  };\n}\n//# sourceMappingURL=authentication_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nimport {\n  Expression\n} from \"../filter_builder.js\";\nexport class ExpressionImpl extends Expression {\n  constructor(inner) {\n    super();\n    __publicField(this, \"inner\");\n    this.inner = inner;\n  }\n  serialize() {\n    return this.inner;\n  }\n}\nexport function serializeExpression(expr) {\n  if (expr instanceof ExpressionImpl) {\n    return expr.serialize();\n  } else {\n    return { $literal: convexOrUndefinedToJson(expr) };\n  }\n}\nexport const filterBuilderImpl = {\n  //  Comparisons  /////////////////////////////////////////////////////////////\n  eq(l, r) {\n    return new ExpressionImpl({\n      $eq: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  neq(l, r) {\n    return new ExpressionImpl({\n      $neq: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  lt(l, r) {\n    return new ExpressionImpl({\n      $lt: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  lte(l, r) {\n    return new ExpressionImpl({\n      $lte: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  gt(l, r) {\n    return new ExpressionImpl({\n      $gt: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  gte(l, r) {\n    return new ExpressionImpl({\n      $gte: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  //  Arithmetic  //////////////////////////////////////////////////////////////\n  add(l, r) {\n    return new ExpressionImpl({\n      $add: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  sub(l, r) {\n    return new ExpressionImpl({\n      $sub: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  mul(l, r) {\n    return new ExpressionImpl({\n      $mul: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  div(l, r) {\n    return new ExpressionImpl({\n      $div: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  mod(l, r) {\n    return new ExpressionImpl({\n      $mod: [serializeExpression(l), serializeExpression(r)]\n    });\n  },\n  neg(x) {\n    return new ExpressionImpl({ $neg: serializeExpression(x) });\n  },\n  //  Logic  ///////////////////////////////////////////////////////////////////\n  and(...exprs) {\n    return new ExpressionImpl({ $and: exprs.map(serializeExpression) });\n  },\n  or(...exprs) {\n    return new ExpressionImpl({ $or: exprs.map(serializeExpression) });\n  },\n  not(x) {\n    return new ExpressionImpl({ $not: serializeExpression(x) });\n  },\n  //  Other  ///////////////////////////////////////////////////////////////////\n  field(fieldPath) {\n    return new ExpressionImpl({ $field: fieldPath });\n  }\n};\n//# sourceMappingURL=filter_builder_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nimport {\n  IndexRange\n} from \"../index_range_builder.js\";\nexport class IndexRangeBuilderImpl extends IndexRange {\n  constructor(rangeExpressions) {\n    super();\n    __publicField(this, \"rangeExpressions\");\n    __publicField(this, \"isConsumed\");\n    this.rangeExpressions = rangeExpressions;\n    this.isConsumed = false;\n  }\n  static new() {\n    return new IndexRangeBuilderImpl([]);\n  }\n  consume() {\n    if (this.isConsumed) {\n      throw new Error(\n        \"IndexRangeBuilder has already been used! Chain your method calls like `q => q.eq(...).eq(...)`. See https://docs.convex.dev/using/indexes\"\n      );\n    }\n    this.isConsumed = true;\n  }\n  eq(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Eq\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  gt(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Gt\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  gte(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Gte\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  lt(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Lt\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  lte(fieldName, value) {\n    this.consume();\n    return new IndexRangeBuilderImpl(\n      this.rangeExpressions.concat({\n        type: \"Lte\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  export() {\n    this.consume();\n    return this.rangeExpressions;\n  }\n}\n//# sourceMappingURL=index_range_builder_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexOrUndefinedToJson } from \"../../values/value.js\";\nimport {\n  SearchFilter\n} from \"../search_filter_builder.js\";\nimport { validateArg } from \"./validate.js\";\nexport class SearchFilterBuilderImpl extends SearchFilter {\n  constructor(filters) {\n    super();\n    __publicField(this, \"filters\");\n    __publicField(this, \"isConsumed\");\n    this.filters = filters;\n    this.isConsumed = false;\n  }\n  static new() {\n    return new SearchFilterBuilderImpl([]);\n  }\n  consume() {\n    if (this.isConsumed) {\n      throw new Error(\n        \"SearchFilterBuilder has already been used! Chain your method calls like `q => q.search(...).eq(...)`.\"\n      );\n    }\n    this.isConsumed = true;\n  }\n  search(fieldName, query) {\n    validateArg(fieldName, 1, \"search\", \"fieldName\");\n    validateArg(query, 2, \"search\", \"query\");\n    this.consume();\n    return new SearchFilterBuilderImpl(\n      this.filters.concat({\n        type: \"Search\",\n        fieldPath: fieldName,\n        value: query\n      })\n    );\n  }\n  eq(fieldName, value) {\n    validateArg(fieldName, 1, \"eq\", \"fieldName\");\n    if (arguments.length !== 2) {\n      validateArg(value, 2, \"search\", \"value\");\n    }\n    this.consume();\n    return new SearchFilterBuilderImpl(\n      this.filters.concat({\n        type: \"Eq\",\n        fieldPath: fieldName,\n        value: convexOrUndefinedToJson(value)\n      })\n    );\n  }\n  export() {\n    this.consume();\n    return this.filters;\n  }\n}\n//# sourceMappingURL=search_filter_builder_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { performAsyncSyscall, performSyscall } from \"./syscall.js\";\nimport {\n  filterBuilderImpl,\n  serializeExpression\n} from \"./filter_builder_impl.js\";\nimport {\n  IndexRangeBuilderImpl\n} from \"./index_range_builder_impl.js\";\nimport {\n  SearchFilterBuilderImpl\n} from \"./search_filter_builder_impl.js\";\nimport { validateArg, validateArgIsNonNegativeInteger } from \"./validate.js\";\nimport { version } from \"../../index.js\";\nconst MAX_QUERY_OPERATORS = 256;\nexport class QueryInitializerImpl {\n  constructor(tableName) {\n    __publicField(this, \"tableName\");\n    this.tableName = tableName;\n  }\n  withIndex(indexName, indexRange) {\n    validateArg(indexName, 1, \"withIndex\", \"indexName\");\n    let rangeBuilder = IndexRangeBuilderImpl.new();\n    if (indexRange !== void 0) {\n      rangeBuilder = indexRange(rangeBuilder);\n    }\n    return new QueryImpl({\n      source: {\n        type: \"IndexRange\",\n        indexName: this.tableName + \".\" + indexName,\n        range: rangeBuilder.export(),\n        order: null\n      },\n      operators: []\n    });\n  }\n  withSearchIndex(indexName, searchFilter) {\n    validateArg(indexName, 1, \"withSearchIndex\", \"indexName\");\n    validateArg(searchFilter, 2, \"withSearchIndex\", \"searchFilter\");\n    const searchFilterBuilder = SearchFilterBuilderImpl.new();\n    return new QueryImpl({\n      source: {\n        type: \"Search\",\n        indexName: this.tableName + \".\" + indexName,\n        filters: searchFilter(searchFilterBuilder).export()\n      },\n      operators: []\n    });\n  }\n  fullTableScan() {\n    return new QueryImpl({\n      source: {\n        type: \"FullTableScan\",\n        tableName: this.tableName,\n        order: null\n      },\n      operators: []\n    });\n  }\n  order(order) {\n    return this.fullTableScan().order(order);\n  }\n  // This is internal API and should not be exposed to developers yet.\n  async count() {\n    const syscallJSON = await performAsyncSyscall(\"1.0/count\", {\n      table: this.tableName\n    });\n    const syscallResult = jsonToConvex(syscallJSON);\n    return syscallResult;\n  }\n  filter(predicate) {\n    return this.fullTableScan().filter(predicate);\n  }\n  limit(n) {\n    return this.fullTableScan().limit(n);\n  }\n  collect() {\n    return this.fullTableScan().collect();\n  }\n  take(n) {\n    return this.fullTableScan().take(n);\n  }\n  paginate(paginationOpts) {\n    return this.fullTableScan().paginate(paginationOpts);\n  }\n  first() {\n    return this.fullTableScan().first();\n  }\n  unique() {\n    return this.fullTableScan().unique();\n  }\n  [Symbol.asyncIterator]() {\n    return this.fullTableScan()[Symbol.asyncIterator]();\n  }\n}\nfunction throwClosedError(type) {\n  throw new Error(\n    type === \"consumed\" ? \"This query is closed and can't emit any more values.\" : \"This query has been chained with another operator and can't be reused.\"\n  );\n}\nexport class QueryImpl {\n  constructor(query) {\n    __publicField(this, \"state\");\n    __publicField(this, \"tableNameForErrorMessages\");\n    this.state = { type: \"preparing\", query };\n    if (query.source.type === \"FullTableScan\") {\n      this.tableNameForErrorMessages = query.source.tableName;\n    } else {\n      this.tableNameForErrorMessages = query.source.indexName.split(\".\")[0];\n    }\n  }\n  takeQuery() {\n    if (this.state.type !== \"preparing\") {\n      throw new Error(\n        \"A query can only be chained once and can't be chained after iteration begins.\"\n      );\n    }\n    const query = this.state.query;\n    this.state = { type: \"closed\" };\n    return query;\n  }\n  startQuery() {\n    if (this.state.type === \"executing\") {\n      throw new Error(\"Iteration can only begin on a query once.\");\n    }\n    if (this.state.type === \"closed\" || this.state.type === \"consumed\") {\n      throwClosedError(this.state.type);\n    }\n    const query = this.state.query;\n    const { queryId } = performSyscall(\"1.0/queryStream\", { query, version });\n    this.state = { type: \"executing\", queryId };\n    return queryId;\n  }\n  closeQuery() {\n    if (this.state.type === \"executing\") {\n      const queryId = this.state.queryId;\n      performSyscall(\"1.0/queryCleanup\", { queryId });\n    }\n    this.state = { type: \"consumed\" };\n  }\n  order(order) {\n    validateArg(order, 1, \"order\", \"order\");\n    const query = this.takeQuery();\n    if (query.source.type === \"Search\") {\n      throw new Error(\n        \"Search queries must always be in relevance order. Can not set order manually.\"\n      );\n    }\n    if (query.source.order !== null) {\n      throw new Error(\"Queries may only specify order at most once\");\n    }\n    query.source.order = order;\n    return new QueryImpl(query);\n  }\n  filter(predicate) {\n    validateArg(predicate, 1, \"filter\", \"predicate\");\n    const query = this.takeQuery();\n    if (query.operators.length >= MAX_QUERY_OPERATORS) {\n      throw new Error(\n        `Can't construct query with more than ${MAX_QUERY_OPERATORS} operators`\n      );\n    }\n    query.operators.push({\n      filter: serializeExpression(predicate(filterBuilderImpl))\n    });\n    return new QueryImpl(query);\n  }\n  limit(n) {\n    validateArg(n, 1, \"limit\", \"n\");\n    const query = this.takeQuery();\n    query.operators.push({ limit: n });\n    return new QueryImpl(query);\n  }\n  [Symbol.asyncIterator]() {\n    this.startQuery();\n    return this;\n  }\n  async next() {\n    if (this.state.type === \"closed\" || this.state.type === \"consumed\") {\n      throwClosedError(this.state.type);\n    }\n    const queryId = this.state.type === \"preparing\" ? this.startQuery() : this.state.queryId;\n    const { value, done } = await performAsyncSyscall(\"1.0/queryStreamNext\", {\n      queryId\n    });\n    if (done) {\n      this.closeQuery();\n    }\n    const convexValue = jsonToConvex(value);\n    return { value: convexValue, done };\n  }\n  return() {\n    this.closeQuery();\n    return Promise.resolve({ done: true, value: void 0 });\n  }\n  async paginate(paginationOpts) {\n    validateArg(paginationOpts, 1, \"paginate\", \"options\");\n    if (typeof paginationOpts?.numItems !== \"number\" || paginationOpts.numItems < 0) {\n      throw new Error(\n        `\\`options.numItems\\` must be a positive number. Received \\`${paginationOpts?.numItems}\\`.`\n      );\n    }\n    const query = this.takeQuery();\n    const pageSize = paginationOpts.numItems;\n    const cursor = paginationOpts.cursor;\n    const endCursor = paginationOpts?.endCursor ?? null;\n    const maximumRowsRead = paginationOpts.maximumRowsRead ?? null;\n    const { page, isDone, continueCursor, splitCursor, pageStatus } = await performAsyncSyscall(\"1.0/queryPage\", {\n      query,\n      cursor,\n      endCursor,\n      pageSize,\n      maximumRowsRead,\n      maximumBytesRead: paginationOpts.maximumBytesRead,\n      version\n    });\n    return {\n      page: page.map((json) => jsonToConvex(json)),\n      isDone,\n      continueCursor,\n      splitCursor,\n      pageStatus\n    };\n  }\n  async collect() {\n    const out = [];\n    for await (const item of this) {\n      out.push(item);\n    }\n    return out;\n  }\n  async take(n) {\n    validateArg(n, 1, \"take\", \"n\");\n    validateArgIsNonNegativeInteger(n, 1, \"take\", \"n\");\n    return this.limit(n).collect();\n  }\n  async first() {\n    const first_array = await this.take(1);\n    return first_array.length === 0 ? null : first_array[0];\n  }\n  async unique() {\n    const first_two_array = await this.take(2);\n    if (first_two_array.length === 0) {\n      return null;\n    }\n    if (first_two_array.length === 2) {\n      throw new Error(`unique() query returned more than one result from table ${this.tableNameForErrorMessages}:\n [${first_two_array[0]._id}, ${first_two_array[1]._id}, ...]`);\n    }\n    return first_two_array[0];\n  }\n}\n//# sourceMappingURL=query_impl.js.map\n","\"use strict\";\nimport {\n  convexToJson,\n  jsonToConvex\n} from \"../../values/index.js\";\nimport { performAsyncSyscall, performSyscall } from \"./syscall.js\";\nimport { QueryInitializerImpl } from \"./query_impl.js\";\nimport { validateArg } from \"./validate.js\";\nimport { version } from \"../../index.js\";\nimport { patchValueToJson } from \"../../values/value.js\";\nasync function get(table, id, isSystem) {\n  validateArg(id, 1, \"get\", \"id\");\n  if (typeof id !== \"string\") {\n    throw new Error(\n      `Invalid argument \\`id\\` for \\`db.get\\`, expected string but got '${typeof id}': ${id}`\n    );\n  }\n  const args = {\n    id: convexToJson(id),\n    isSystem,\n    version,\n    table\n  };\n  const syscallJSON = await performAsyncSyscall(\"1.0/get\", args);\n  return jsonToConvex(syscallJSON);\n}\nexport function setupReader() {\n  const reader = (isSystem = false) => {\n    return {\n      get: async (arg0, arg1) => {\n        return arg1 !== void 0 ? await get(arg0, arg1, isSystem) : await get(void 0, arg0, isSystem);\n      },\n      query: (tableName) => {\n        return new TableReader(tableName, isSystem).query();\n      },\n      normalizeId: (tableName, id) => {\n        validateArg(tableName, 1, \"normalizeId\", \"tableName\");\n        validateArg(id, 2, \"normalizeId\", \"id\");\n        const accessingSystemTable = tableName.startsWith(\"_\");\n        if (accessingSystemTable !== isSystem) {\n          throw new Error(\n            `${accessingSystemTable ? \"System\" : \"User\"} tables can only be accessed from db.${isSystem ? \"\" : \"system.\"}normalizeId().`\n          );\n        }\n        const syscallJSON = performSyscall(\"1.0/db/normalizeId\", {\n          table: tableName,\n          idString: id\n        });\n        const syscallResult = jsonToConvex(syscallJSON);\n        return syscallResult.id;\n      },\n      // We set the system reader on the next line\n      system: null,\n      table: (tableName) => {\n        return new TableReader(tableName, isSystem);\n      }\n    };\n  };\n  const { system: _, ...rest } = reader(true);\n  const r = reader();\n  r.system = rest;\n  return r;\n}\nasync function insert(tableName, value) {\n  if (tableName.startsWith(\"_\")) {\n    throw new Error(\"System tables (prefixed with `_`) are read-only.\");\n  }\n  validateArg(tableName, 1, \"insert\", \"table\");\n  validateArg(value, 2, \"insert\", \"value\");\n  const syscallJSON = await performAsyncSyscall(\"1.0/insert\", {\n    table: tableName,\n    value: convexToJson(value)\n  });\n  const syscallResult = jsonToConvex(syscallJSON);\n  return syscallResult._id;\n}\nasync function patch(table, id, value) {\n  validateArg(id, 1, \"patch\", \"id\");\n  validateArg(value, 2, \"patch\", \"value\");\n  await performAsyncSyscall(\"1.0/shallowMerge\", {\n    id: convexToJson(id),\n    value: patchValueToJson(value),\n    table\n  });\n}\nasync function replace(table, id, value) {\n  validateArg(id, 1, \"replace\", \"id\");\n  validateArg(value, 2, \"replace\", \"value\");\n  await performAsyncSyscall(\"1.0/replace\", {\n    id: convexToJson(id),\n    value: convexToJson(value),\n    table\n  });\n}\nasync function delete_(table, id) {\n  validateArg(id, 1, \"delete\", \"id\");\n  await performAsyncSyscall(\"1.0/remove\", {\n    id: convexToJson(id),\n    table\n  });\n}\nexport function setupWriter() {\n  const reader = setupReader();\n  return {\n    get: reader.get,\n    query: reader.query,\n    normalizeId: reader.normalizeId,\n    system: reader.system,\n    insert: async (table, value) => {\n      return await insert(table, value);\n    },\n    patch: async (arg0, arg1, arg2) => {\n      return arg2 !== void 0 ? await patch(arg0, arg1, arg2) : await patch(void 0, arg0, arg1);\n    },\n    replace: async (arg0, arg1, arg2) => {\n      return arg2 !== void 0 ? await replace(arg0, arg1, arg2) : await replace(void 0, arg0, arg1);\n    },\n    delete: async (arg0, arg1) => {\n      return arg1 !== void 0 ? await delete_(arg0, arg1) : await delete_(void 0, arg0);\n    },\n    table: (tableName) => {\n      return new TableWriter(tableName, false);\n    }\n  };\n}\nclass TableReader {\n  constructor(tableName, isSystem) {\n    this.tableName = tableName;\n    this.isSystem = isSystem;\n  }\n  async get(id) {\n    return get(this.tableName, id, this.isSystem);\n  }\n  query() {\n    const accessingSystemTable = this.tableName.startsWith(\"_\");\n    if (accessingSystemTable !== this.isSystem) {\n      throw new Error(\n        `${accessingSystemTable ? \"System\" : \"User\"} tables can only be accessed from db.${this.isSystem ? \"\" : \"system.\"}query().`\n      );\n    }\n    return new QueryInitializerImpl(this.tableName);\n  }\n}\nclass TableWriter extends TableReader {\n  async insert(value) {\n    return insert(this.tableName, value);\n  }\n  async patch(id, value) {\n    return patch(this.tableName, id, value);\n  }\n  async replace(id, value) {\n    return replace(this.tableName, id, value);\n  }\n  async delete(id) {\n    return delete_(this.tableName, id);\n  }\n}\n//# sourceMappingURL=database_impl.js.map\n","\"use strict\";\nimport { convexToJson } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { validateArg } from \"./validate.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\nexport function setupMutationScheduler() {\n  return {\n    runAfter: async (delayMs, functionReference, args) => {\n      const syscallArgs = runAfterSyscallArgs(delayMs, functionReference, args);\n      return await performAsyncSyscall(\"1.0/schedule\", syscallArgs);\n    },\n    runAt: async (ms_since_epoch_or_date, functionReference, args) => {\n      const syscallArgs = runAtSyscallArgs(\n        ms_since_epoch_or_date,\n        functionReference,\n        args\n      );\n      return await performAsyncSyscall(\"1.0/schedule\", syscallArgs);\n    },\n    cancel: async (id) => {\n      validateArg(id, 1, \"cancel\", \"id\");\n      const args = { id: convexToJson(id) };\n      await performAsyncSyscall(\"1.0/cancel_job\", args);\n    }\n  };\n}\nexport function setupActionScheduler(requestId) {\n  return {\n    runAfter: async (delayMs, functionReference, args) => {\n      const syscallArgs = {\n        requestId,\n        ...runAfterSyscallArgs(delayMs, functionReference, args)\n      };\n      return await performAsyncSyscall(\"1.0/actions/schedule\", syscallArgs);\n    },\n    runAt: async (ms_since_epoch_or_date, functionReference, args) => {\n      const syscallArgs = {\n        requestId,\n        ...runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args)\n      };\n      return await performAsyncSyscall(\"1.0/actions/schedule\", syscallArgs);\n    },\n    cancel: async (id) => {\n      validateArg(id, 1, \"cancel\", \"id\");\n      const syscallArgs = { id: convexToJson(id) };\n      return await performAsyncSyscall(\"1.0/actions/cancel_job\", syscallArgs);\n    }\n  };\n}\nfunction runAfterSyscallArgs(delayMs, functionReference, args) {\n  if (typeof delayMs !== \"number\") {\n    throw new Error(\"`delayMs` must be a number\");\n  }\n  if (!isFinite(delayMs)) {\n    throw new Error(\"`delayMs` must be a finite number\");\n  }\n  if (delayMs < 0) {\n    throw new Error(\"`delayMs` must be non-negative\");\n  }\n  const functionArgs = parseArgs(args);\n  const address = getFunctionAddress(functionReference);\n  const ts = (Date.now() + delayMs) / 1e3;\n  return {\n    ...address,\n    ts,\n    args: convexToJson(functionArgs),\n    version\n  };\n}\nfunction runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args) {\n  let ts;\n  if (ms_since_epoch_or_date instanceof Date) {\n    ts = ms_since_epoch_or_date.valueOf() / 1e3;\n  } else if (typeof ms_since_epoch_or_date === \"number\") {\n    ts = ms_since_epoch_or_date / 1e3;\n  } else {\n    throw new Error(\"The invoke time must a Date or a timestamp\");\n  }\n  const address = getFunctionAddress(functionReference);\n  const functionArgs = parseArgs(args);\n  return {\n    ...address,\n    ts,\n    args: convexToJson(functionArgs),\n    version\n  };\n}\n//# sourceMappingURL=scheduler_impl.js.map\n","\"use strict\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall, performJsSyscall } from \"./syscall.js\";\nimport { validateArg } from \"./validate.js\";\nexport function setupStorageReader(requestId) {\n  return {\n    getUrl: async (storageId) => {\n      validateArg(storageId, 1, \"getUrl\", \"storageId\");\n      return await performAsyncSyscall(\"1.0/storageGetUrl\", {\n        requestId,\n        version,\n        storageId\n      });\n    },\n    getMetadata: async (storageId) => {\n      return await performAsyncSyscall(\"1.0/storageGetMetadata\", {\n        requestId,\n        version,\n        storageId\n      });\n    }\n  };\n}\nexport function setupStorageWriter(requestId) {\n  const reader = setupStorageReader(requestId);\n  return {\n    generateUploadUrl: async () => {\n      return await performAsyncSyscall(\"1.0/storageGenerateUploadUrl\", {\n        requestId,\n        version\n      });\n    },\n    delete: async (storageId) => {\n      await performAsyncSyscall(\"1.0/storageDelete\", {\n        requestId,\n        version,\n        storageId\n      });\n    },\n    getUrl: reader.getUrl,\n    getMetadata: reader.getMetadata\n  };\n}\nexport function setupStorageActionWriter(requestId) {\n  const writer = setupStorageWriter(requestId);\n  return {\n    ...writer,\n    store: async (blob, options) => {\n      return await performJsSyscall(\"storage/storeBlob\", {\n        requestId,\n        version,\n        blob,\n        options\n      });\n    },\n    get: async (storageId) => {\n      return await performJsSyscall(\"storage/getBlob\", {\n        requestId,\n        version,\n        storageId\n      });\n    }\n  };\n}\n//# sourceMappingURL=storage_impl.js.map\n","\"use strict\";\nimport {\n  convexToJson,\n  jsonToConvex,\n  v\n} from \"../../values/index.js\";\nimport { setupActionCalls } from \"./actions_impl.js\";\nimport { setupActionVectorSearch } from \"./vector_search_impl.js\";\nimport { setupAuth } from \"./authentication_impl.js\";\nimport { setupReader, setupWriter } from \"./database_impl.js\";\nimport { QueryImpl, QueryInitializerImpl } from \"./query_impl.js\";\nimport {\n  setupActionScheduler,\n  setupMutationScheduler\n} from \"./scheduler_impl.js\";\nimport {\n  setupStorageActionWriter,\n  setupStorageReader,\n  setupStorageWriter\n} from \"./storage_impl.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { asObjectValidator } from \"../../values/validator.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\nasync function invokeMutation(func, argsStr) {\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const mutationCtx = {\n    db: setupWriter(),\n    auth: setupAuth(requestId),\n    storage: setupStorageWriter(requestId),\n    scheduler: setupMutationScheduler(),\n    runQuery: (reference, args2) => runUdf(\"query\", reference, args2),\n    runMutation: (reference, args2) => runUdf(\"mutation\", reference, args2)\n  };\n  const result = await invokeFunction(func, mutationCtx, args);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === void 0 ? null : result));\n}\nexport function validateReturnValue(v2) {\n  if (v2 instanceof QueryInitializerImpl || v2 instanceof QueryImpl) {\n    throw new Error(\n      \"Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.\"\n    );\n  }\n}\nexport async function invokeFunction(func, ctx, args) {\n  let result;\n  try {\n    result = await Promise.resolve(func(ctx, ...args));\n  } catch (thrown) {\n    throw serializeConvexErrorData(thrown);\n  }\n  return result;\n}\nfunction dontCallDirectly(funcType, handler) {\n  return (ctx, args) => {\n    globalThis.console.warn(\n      `Convex functions should not directly call other Convex functions. Consider calling a helper function instead. e.g. \\`export const foo = ${funcType}(...); await foo(ctx);\\` is not supported. See https://docs.convex.dev/production/best-practices/#use-helper-functions-to-write-shared-code`\n    );\n    return handler(ctx, args);\n  };\n}\nfunction serializeConvexErrorData(thrown) {\n  if (typeof thrown === \"object\" && thrown !== null && Symbol.for(\"ConvexError\") in thrown) {\n    const error = thrown;\n    error.data = JSON.stringify(\n      convexToJson(error.data === void 0 ? null : error.data)\n    );\n    error.ConvexErrorSymbol = Symbol.for(\"ConvexError\");\n    return error;\n  } else {\n    return thrown;\n  }\n}\nfunction assertNotBrowser() {\n  if (typeof window === \"undefined\" || window.__convexAllowFunctionsInBrowser) {\n    return;\n  }\n  const isRealBrowser = Object.getOwnPropertyDescriptor(globalThis, \"window\")?.get?.toString().includes(\"[native code]\") ?? false;\n  if (isRealBrowser) {\n    console.error(\n      \"Convex functions should not be imported in the browser. This will throw an error in future versions of `convex`. If this is a false negative, please report it to Convex support.\"\n    );\n  }\n}\nfunction strictReplacer(key, value) {\n  if (value === void 0) {\n    throw new Error(\n      `A validator is undefined for field \"${key}\". This is often caused by circular imports. See https://docs.convex.dev/error#undefined-validator for details.`\n    );\n  }\n  return value;\n}\nfunction exportArgs(functionDefinition) {\n  return () => {\n    let args = v.any();\n    if (typeof functionDefinition === \"object\" && functionDefinition.args !== void 0) {\n      args = asObjectValidator(functionDefinition.args);\n    }\n    return JSON.stringify(args.json, strictReplacer);\n  };\n}\nfunction exportReturns(functionDefinition) {\n  return () => {\n    let returns;\n    if (typeof functionDefinition === \"object\" && functionDefinition.returns !== void 0) {\n      returns = asObjectValidator(functionDefinition.returns);\n    }\n    return JSON.stringify(returns ? returns.json : null, strictReplacer);\n  };\n}\nexport const mutationGeneric = (functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"mutation\", handler);\n  assertNotBrowser();\n  func.isMutation = true;\n  func.isPublic = true;\n  func.invokeMutation = (argsStr) => invokeMutation(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n};\nexport const internalMutationGeneric = (functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\n    \"internalMutation\",\n    handler\n  );\n  assertNotBrowser();\n  func.isMutation = true;\n  func.isInternal = true;\n  func.invokeMutation = (argsStr) => invokeMutation(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n};\nasync function invokeQuery(func, argsStr) {\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const queryCtx = {\n    db: setupReader(),\n    auth: setupAuth(requestId),\n    storage: setupStorageReader(requestId),\n    runQuery: (reference, args2) => runUdf(\"query\", reference, args2)\n  };\n  const result = await invokeFunction(func, queryCtx, args);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === void 0 ? null : result));\n}\nexport const queryGeneric = (functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"query\", handler);\n  assertNotBrowser();\n  func.isQuery = true;\n  func.isPublic = true;\n  func.invokeQuery = (argsStr) => invokeQuery(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n};\nexport const internalQueryGeneric = (functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"internalQuery\", handler);\n  assertNotBrowser();\n  func.isQuery = true;\n  func.isInternal = true;\n  func.invokeQuery = (argsStr) => invokeQuery(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n};\nasync function invokeAction(func, requestId, argsStr) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    scheduler: setupActionScheduler(requestId),\n    storage: setupStorageActionWriter(requestId),\n    vectorSearch: setupActionVectorSearch(requestId)\n  };\n  const result = await invokeFunction(func, ctx, args);\n  return JSON.stringify(convexToJson(result === void 0 ? null : result));\n}\nexport const actionGeneric = (functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"action\", handler);\n  assertNotBrowser();\n  func.isAction = true;\n  func.isPublic = true;\n  func.invokeAction = (requestId, argsStr) => invokeAction(handler, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n};\nexport const internalActionGeneric = (functionDefinition) => {\n  const handler = typeof functionDefinition === \"function\" ? functionDefinition : functionDefinition.handler;\n  const func = dontCallDirectly(\"internalAction\", handler);\n  assertNotBrowser();\n  func.isAction = true;\n  func.isInternal = true;\n  func.invokeAction = (requestId, argsStr) => invokeAction(handler, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n};\nasync function invokeHttpAction(func, request) {\n  const requestId = \"\";\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    storage: setupStorageActionWriter(requestId),\n    scheduler: setupActionScheduler(requestId),\n    vectorSearch: setupActionVectorSearch(requestId)\n  };\n  return await invokeFunction(func, ctx, [request]);\n}\nexport const httpActionGeneric = (func) => {\n  const q = dontCallDirectly(\"httpAction\", func);\n  assertNotBrowser();\n  q.isHttp = true;\n  q.invokeHttpAction = (request) => invokeHttpAction(func, request);\n  q._handler = func;\n  return q;\n};\nasync function runUdf(udfType, f, args) {\n  const queryArgs = parseArgs(args);\n  const syscallArgs = {\n    udfType,\n    args: convexToJson(queryArgs),\n    ...getFunctionAddress(f)\n  };\n  const result = await performAsyncSyscall(\"1.0/runUdf\", syscallArgs);\n  return jsonToConvex(result);\n}\n//# sourceMappingURL=registration_impl.js.map\n","\"use strict\";\nimport { v } from \"../values/validator.js\";\nexport const paginationOptsValidator = v.object({\n  numItems: v.number(),\n  cursor: v.union(v.string(), v.null()),\n  endCursor: v.optional(v.union(v.string(), v.null())),\n  id: v.optional(v.number()),\n  maximumRowsRead: v.optional(v.number()),\n  maximumBytesRead: v.optional(v.number())\n});\nexport function paginationResultValidator(itemValidator) {\n  return v.object({\n    page: v.array(itemValidator),\n    continueCursor: v.string(),\n    isDone: v.boolean(),\n    splitCursor: v.optional(v.union(v.string(), v.null())),\n    pageStatus: v.optional(\n      v.union(\n        v.literal(\"SplitRecommended\"),\n        v.literal(\"SplitRequired\"),\n        v.null()\n      )\n    )\n  });\n}\n//# sourceMappingURL=pagination.js.map\n","\"use strict\";\nimport * as Base64 from \"./base64.js\";\nimport { isSimpleObject } from \"../common/index.js\";\nconst LITTLE_ENDIAN = true;\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\nfunction isSpecial(n) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\nexport function slowBigIntToBase64(value) {\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g).reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\nexport function slowBase64ToBigInt(encoded) {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\nexport function modernBigIntToBase64(value) {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\nexport function modernBase64ToBigInt(encoded) {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\nexport const bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;\nexport const base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;\nconst MAX_IDENTIFIER_LEN = 1024;\nfunction validateObjectField(k) {\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  for (let i = 0; i < k.length; i += 1) {\n    const charCode = k.charCodeAt(i);\n    if (charCode < 32 || charCode >= 127) {\n      throw new Error(\n        `Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`\n      );\n    }\n  }\n}\nexport function jsonToConvex(value) {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map((value2) => jsonToConvex(value2));\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      throw new Error(\n        `Received a Set which is no longer supported as a Convex type.`\n      );\n    }\n    if (key === \"$map\") {\n      throw new Error(\n        `Received a Map which is no longer supported as a Convex type.`\n      );\n    }\n  }\n  const out = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvex(v);\n  }\n  return out;\n}\nconst MAX_VALUE_FOR_ERROR_LEN = 16384;\nexport function stringifyValueForError(value) {\n  const str = JSON.stringify(value, (_key, value2) => {\n    if (value2 === void 0) {\n      return \"undefined\";\n    }\n    if (typeof value2 === \"bigint\") {\n      return `${value2.toString()}n`;\n    }\n    return value2;\n  });\n  if (str.length > MAX_VALUE_FOR_ERROR_LEN) {\n    const rest = \"[...truncated]\";\n    let truncateAt = MAX_VALUE_FOR_ERROR_LEN - rest.length;\n    const codePoint = str.codePointAt(truncateAt - 1);\n    if (codePoint !== void 0 && codePoint > 65535) {\n      truncateAt -= 1;\n    }\n    return str.substring(0, truncateAt) + rest;\n  }\n  return str;\n}\nfunction convexToJsonInternal(value, originalValue, context, includeTopLevelUndefined) {\n  if (value === void 0) {\n    const contextText = context && ` (present at path ${context} in original object ${stringifyValueForError(\n      originalValue\n    )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (Array.isArray(value)) {\n    return value.map(\n      (value2, i) => convexToJsonInternal(value2, originalValue, context + `[${i}]`, false)\n    );\n  }\n  if (value instanceof Set) {\n    throw new Error(\n      errorMessageForUnsupportedType(context, \"Set\", [...value], originalValue)\n    );\n  }\n  if (value instanceof Map) {\n    throw new Error(\n      errorMessageForUnsupportedType(context, \"Map\", [...value], originalValue)\n    );\n  }\n  if (!isSimpleObject(value)) {\n    const theType = value?.constructor?.name;\n    const typeName = theType ? `${theType} ` : \"\";\n    throw new Error(\n      errorMessageForUnsupportedType(context, typeName, value, originalValue)\n    );\n  }\n  const out = {};\n  const entries = Object.entries(value);\n  entries.sort(([k1, _v1], [k2, _v2]) => k1 === k2 ? 0 : k1 < k2 ? -1 : 1);\n  for (const [k, v] of entries) {\n    if (v !== void 0) {\n      validateObjectField(k);\n      out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`, false);\n    } else if (includeTopLevelUndefined) {\n      validateObjectField(k);\n      out[k] = convexOrUndefinedToJsonInternal(\n        v,\n        originalValue,\n        context + `.${k}`\n      );\n    }\n  }\n  return out;\n}\nfunction errorMessageForUnsupportedType(context, typeName, value, originalValue) {\n  if (context) {\n    return `${typeName}${stringifyValueForError(\n      value\n    )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n      originalValue\n    )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;\n  } else {\n    return `${typeName}${stringifyValueForError(\n      value\n    )} is not a supported Convex type.`;\n  }\n}\nfunction convexOrUndefinedToJsonInternal(value, originalValue, context) {\n  if (value === void 0) {\n    return { $undefined: null };\n  } else {\n    if (originalValue === void 0) {\n      throw new Error(\n        `Programming error. Current value is ${stringifyValueForError(\n          value\n        )} but original value is undefined`\n      );\n    }\n    return convexToJsonInternal(value, originalValue, context, false);\n  }\n}\nexport function convexToJson(value) {\n  return convexToJsonInternal(value, value, \"\", false);\n}\nexport function convexOrUndefinedToJson(value) {\n  return convexOrUndefinedToJsonInternal(value, value, \"\");\n}\nexport function patchValueToJson(value) {\n  return convexToJsonInternal(value, value, \"\", true);\n}\n//# sourceMappingURL=value.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { getFunctionName } from \"../server/api.js\";\nimport { parseArgs } from \"../common/index.js\";\nimport { convexToJson } from \"../values/index.js\";\nconst DAYS_OF_WEEK = [\n  \"sunday\",\n  \"monday\",\n  \"tuesday\",\n  \"wednesday\",\n  \"thursday\",\n  \"friday\",\n  \"saturday\"\n];\nexport const cronJobs = () => new Crons();\nfunction validateIntervalNumber(n) {\n  if (!Number.isInteger(n) || n <= 0) {\n    throw new Error(\"Interval must be an integer greater than 0\");\n  }\n}\nfunction validatedDayOfMonth(n) {\n  if (!Number.isInteger(n) || n < 1 || n > 31) {\n    throw new Error(\"Day of month must be an integer from 1 to 31\");\n  }\n  return n;\n}\nfunction validatedDayOfWeek(s) {\n  if (!DAYS_OF_WEEK.includes(s)) {\n    throw new Error('Day of week must be a string like \"monday\".');\n  }\n  return s;\n}\nfunction validatedHourOfDay(n) {\n  if (!Number.isInteger(n) || n < 0 || n > 23) {\n    throw new Error(\"Hour of day must be an integer from 0 to 23\");\n  }\n  return n;\n}\nfunction validatedMinuteOfHour(n) {\n  if (!Number.isInteger(n) || n < 0 || n > 59) {\n    throw new Error(\"Minute of hour must be an integer from 0 to 59\");\n  }\n  return n;\n}\nfunction validatedCronString(s) {\n  return s;\n}\nfunction validatedCronIdentifier(s) {\n  if (!s.match(/^[ -~]*$/)) {\n    throw new Error(\n      `Invalid cron identifier ${s}: use ASCII letters that are not control characters`\n    );\n  }\n  return s;\n}\nexport class Crons {\n  constructor() {\n    __publicField(this, \"crons\");\n    __publicField(this, \"isCrons\");\n    this.isCrons = true;\n    this.crons = {};\n  }\n  /** @internal */\n  schedule(cronIdentifier, schedule, functionReference, args) {\n    const cronArgs = parseArgs(args);\n    validatedCronIdentifier(cronIdentifier);\n    if (cronIdentifier in this.crons) {\n      throw new Error(`Cron identifier registered twice: ${cronIdentifier}`);\n    }\n    this.crons[cronIdentifier] = {\n      name: getFunctionName(functionReference),\n      args: [convexToJson(cronArgs)],\n      schedule\n    };\n  }\n  /**\n   * Schedule a mutation or action to run at some interval.\n   *\n   * ```js\n   * crons.interval(\"Clear presence data\", {seconds: 30}, api.presence.clear);\n   * ```\n   *\n   * @param identifier - A unique name for this scheduled job.\n   * @param schedule - The time between runs for this scheduled job.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  interval(cronIdentifier, schedule, functionReference, ...args) {\n    const s = schedule;\n    const hasSeconds = +(\"seconds\" in s && s.seconds !== void 0);\n    const hasMinutes = +(\"minutes\" in s && s.minutes !== void 0);\n    const hasHours = +(\"hours\" in s && s.hours !== void 0);\n    const total = hasSeconds + hasMinutes + hasHours;\n    if (total !== 1) {\n      throw new Error(\"Must specify one of seconds, minutes, or hours\");\n    }\n    if (hasSeconds) {\n      validateIntervalNumber(schedule.seconds);\n    } else if (hasMinutes) {\n      validateIntervalNumber(schedule.minutes);\n    } else if (hasHours) {\n      validateIntervalNumber(schedule.hours);\n    }\n    this.schedule(\n      cronIdentifier,\n      { ...schedule, type: \"interval\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on an hourly basis.\n   *\n   * ```js\n   * crons.hourly(\n   *   \"Reset high scores\",\n   *   {\n   *     minuteUTC: 30,\n   *   },\n   *   api.scores.reset\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What time (UTC) each day to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  hourly(cronIdentifier, schedule, functionReference, ...args) {\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { minuteUTC, type: \"hourly\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a daily basis.\n   *\n   * ```js\n   * crons.daily(\n   *   \"Reset high scores\",\n   *   {\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *   },\n   *   api.scores.reset\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What time (UTC) each day to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  daily(cronIdentifier, schedule, functionReference, ...args) {\n    const hourUTC = validatedHourOfDay(schedule.hourUTC);\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { hourUTC, minuteUTC, type: \"daily\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a weekly basis.\n   *\n   * ```js\n   * crons.weekly(\n   *   \"Weekly re-engagement email\",\n   *   {\n   *     dayOfWeek: \"Tuesday\",\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *   },\n   *   api.emails.send\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What day and time (UTC) each week to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   */\n  weekly(cronIdentifier, schedule, functionReference, ...args) {\n    const dayOfWeek = validatedDayOfWeek(schedule.dayOfWeek);\n    const hourUTC = validatedHourOfDay(schedule.hourUTC);\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { dayOfWeek, hourUTC, minuteUTC, type: \"weekly\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a monthly basis.\n   *\n   * Note that some months have fewer days than others, so e.g. a function\n   * scheduled to run on the 30th will not run in February.\n   *\n   * ```js\n   * crons.monthly(\n   *   \"Bill customers at \",\n   *   {\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *     day: 1,\n   *   },\n   *   api.billing.billCustomers\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What day and time (UTC) each month to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  monthly(cronIdentifier, schedule, functionReference, ...args) {\n    const day = validatedDayOfMonth(schedule.day);\n    const hourUTC = validatedHourOfDay(schedule.hourUTC);\n    const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);\n    this.schedule(\n      cronIdentifier,\n      { day, hourUTC, minuteUTC, type: \"monthly\" },\n      functionReference,\n      ...args\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a recurring basis.\n   *\n   * Like the unix command `cron`, Sunday is 0, Monday is 1, etc.\n   *\n   * ```\n   *   minute (0 - 59)\n   *    hour (0 - 23)\n   *     day of the month (1 - 31)\n   *      month (1 - 12)\n   *       day of the week (0 - 6) (Sunday to Saturday)\n   * \"* * * * *\"\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param cron - Cron string like `\"15 7 * * *\"` (Every day at 7:15 UTC)\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  cron(cronIdentifier, cron, functionReference, ...args) {\n    const c = validatedCronString(cron);\n    this.schedule(\n      cronIdentifier,\n      { cron: c, type: \"cron\" },\n      functionReference,\n      ...args\n    );\n  }\n  /** @internal */\n  export() {\n    return JSON.stringify(this.crons);\n  }\n}\n//# sourceMappingURL=cron.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { performJsSyscall } from \"./impl/syscall.js\";\nexport const ROUTABLE_HTTP_METHODS = [\n  \"GET\",\n  \"POST\",\n  \"PUT\",\n  \"DELETE\",\n  \"OPTIONS\",\n  \"PATCH\"\n];\nexport function normalizeMethod(method) {\n  if (method === \"HEAD\") return \"GET\";\n  return method;\n}\nexport const httpRouter = () => new HttpRouter();\nexport class HttpRouter {\n  constructor() {\n    __publicField(this, \"exactRoutes\", /* @__PURE__ */ new Map());\n    __publicField(this, \"prefixRoutes\", /* @__PURE__ */ new Map());\n    __publicField(this, \"isRouter\", true);\n    /**\n     * Specify an HttpAction to be used to respond to requests\n     * for an HTTP method (e.g. \"GET\") and a path or pathPrefix.\n     *\n     * Paths must begin with a slash. Path prefixes must also end in a slash.\n     *\n     * ```js\n     * // matches `/profile` (but not `/profile/`)\n     * http.route({ path: \"/profile\", method: \"GET\", handler: getProfile})\n     *\n     * // matches `/profiles/`, `/profiles/abc`, and `/profiles/a/c/b` (but not `/profile`)\n     * http.route({ pathPrefix: \"/profile/\", method: \"GET\", handler: getProfile})\n     * ```\n     */\n    __publicField(this, \"route\", (spec) => {\n      if (!spec.handler) throw new Error(`route requires handler`);\n      if (!spec.method) throw new Error(`route requires method`);\n      const { method, handler } = spec;\n      if (!ROUTABLE_HTTP_METHODS.includes(method)) {\n        throw new Error(\n          `'${method}' is not an allowed HTTP method (like GET, POST, PUT etc.)`\n        );\n      }\n      if (\"path\" in spec) {\n        if (\"pathPrefix\" in spec) {\n          throw new Error(\n            `Invalid httpRouter route: cannot contain both 'path' and 'pathPrefix'`\n          );\n        }\n        if (!spec.path.startsWith(\"/\")) {\n          throw new Error(`path '${spec.path}' does not start with a /`);\n        }\n        if (spec.path.startsWith(\"/.files/\") || spec.path === \"/.files\") {\n          throw new Error(`path '${spec.path}' is reserved`);\n        }\n        const methods = this.exactRoutes.has(spec.path) ? this.exactRoutes.get(spec.path) : /* @__PURE__ */ new Map();\n        if (methods.has(method)) {\n          throw new Error(\n            `Path '${spec.path}' for method ${method} already in use`\n          );\n        }\n        methods.set(method, handler);\n        this.exactRoutes.set(spec.path, methods);\n      } else if (\"pathPrefix\" in spec) {\n        if (!spec.pathPrefix.startsWith(\"/\")) {\n          throw new Error(\n            `pathPrefix '${spec.pathPrefix}' does not start with a /`\n          );\n        }\n        if (!spec.pathPrefix.endsWith(\"/\")) {\n          throw new Error(`pathPrefix ${spec.pathPrefix} must end with a /`);\n        }\n        if (spec.pathPrefix.startsWith(\"/.files/\")) {\n          throw new Error(`pathPrefix '${spec.pathPrefix}' is reserved`);\n        }\n        const prefixes = this.prefixRoutes.get(method) || /* @__PURE__ */ new Map();\n        if (prefixes.has(spec.pathPrefix)) {\n          throw new Error(\n            `${spec.method} pathPrefix ${spec.pathPrefix} is already defined`\n          );\n        }\n        prefixes.set(spec.pathPrefix, handler);\n        this.prefixRoutes.set(method, prefixes);\n      } else {\n        throw new Error(\n          `Invalid httpRouter route entry: must contain either field 'path' or 'pathPrefix'`\n        );\n      }\n    });\n    /**\n     * Returns a list of routed HTTP actions.\n     *\n     * These are used to populate the list of routes shown in the Functions page of the Convex dashboard.\n     *\n     * @returns - an array of [path, method, endpoint] tuples.\n     */\n    __publicField(this, \"getRoutes\", () => {\n      const exactPaths = [...this.exactRoutes.keys()].sort();\n      const exact = exactPaths.flatMap(\n        (path) => [...this.exactRoutes.get(path).keys()].sort().map(\n          (method) => [path, method, this.exactRoutes.get(path).get(method)]\n        )\n      );\n      const prefixPathMethods = [...this.prefixRoutes.keys()].sort();\n      const prefixes = prefixPathMethods.flatMap(\n        (method) => [...this.prefixRoutes.get(method).keys()].sort().map(\n          (pathPrefix) => [\n            `${pathPrefix}*`,\n            method,\n            this.prefixRoutes.get(method).get(pathPrefix)\n          ]\n        )\n      );\n      return [...exact, ...prefixes];\n    });\n    /**\n     * Returns the appropriate HTTP action and its routed request path and method.\n     *\n     * The path and method returned are used for logging and metrics, and should\n     * match up with one of the routes returned by `getRoutes`.\n     *\n     * For example,\n     *\n     * ```js\n     * http.route({ pathPrefix: \"/profile/\", method: \"GET\", handler: getProfile});\n     *\n     * http.lookup(\"/profile/abc\", \"GET\") // returns [getProfile, \"GET\", \"/profile/*\"]\n     *```\n     *\n     * @returns - a tuple [{@link PublicHttpAction}, method, path] or null.\n     */\n    __publicField(this, \"lookup\", (path, method) => {\n      method = normalizeMethod(method);\n      const exactMatch = this.exactRoutes.get(path)?.get(method);\n      if (exactMatch) return [exactMatch, method, path];\n      const prefixes = this.prefixRoutes.get(method) || /* @__PURE__ */ new Map();\n      const prefixesSorted = [...prefixes.entries()].sort(\n        ([prefixA, _a], [prefixB, _b]) => prefixB.length - prefixA.length\n      );\n      for (const [pathPrefix, endpoint] of prefixesSorted) {\n        if (path.startsWith(pathPrefix)) {\n          return [endpoint, method, `${pathPrefix}*`];\n        }\n      }\n      return null;\n    });\n    /**\n     * Given a JSON string representation of a Request object, return a Response\n     * by routing the request and running the appropriate endpoint or returning\n     * a 404 Response.\n     *\n     * @param argsStr - a JSON string representing a Request object.\n     *\n     * @returns - a Response object.\n     */\n    __publicField(this, \"runRequest\", async (argsStr, requestRoute) => {\n      const request = performJsSyscall(\"requestFromConvexJson\", {\n        convexJson: JSON.parse(argsStr)\n      });\n      let pathname = requestRoute;\n      if (!pathname || typeof pathname !== \"string\") {\n        pathname = new URL(request.url).pathname;\n      }\n      const method = request.method;\n      const match = this.lookup(pathname, method);\n      if (!match) {\n        const response2 = new Response(`No HttpAction routed for ${pathname}`, {\n          status: 404\n        });\n        return JSON.stringify(\n          performJsSyscall(\"convexJsonFromResponse\", { response: response2 })\n        );\n      }\n      const [endpoint, _method, _path] = match;\n      const response = await endpoint.invokeHttpAction(request);\n      return JSON.stringify(\n        performJsSyscall(\"convexJsonFromResponse\", { response })\n      );\n    });\n  }\n}\n//# sourceMappingURL=router.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexToJson } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"../impl/syscall.js\";\nimport {\n  getFunctionAddress,\n  setReferencePath,\n  toReferencePath\n} from \"./paths.js\";\nexport { getFunctionAddress } from \"./paths.js\";\nexport async function createFunctionHandle(functionReference) {\n  const address = getFunctionAddress(functionReference);\n  return await performAsyncSyscall(\"1.0/createFunctionHandle\", {\n    ...address,\n    version\n  });\n}\nclass InstalledComponent {\n  constructor(definition, name) {\n    /**\n     * @internal\n     */\n    __publicField(this, \"_definition\");\n    /**\n     * @internal\n     */\n    __publicField(this, \"_name\");\n    this._definition = definition;\n    this._name = name;\n    setReferencePath(this, `_reference/childComponent/${name}`);\n  }\n  get exports() {\n    return createExports(this._name, []);\n  }\n}\nfunction createExports(name, pathParts) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createExports(name, newParts);\n      } else if (prop === toReferencePath) {\n        let reference = `_reference/childComponent/${name}`;\n        for (const part of pathParts) {\n          reference += `/${part}`;\n        }\n        return reference;\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nfunction use(definition, options) {\n  const importedComponentDefinition = definition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\"\n    );\n  }\n  const name = options?.name || // added recently\n  importedComponentDefinition.defaultName || // can be removed once backend is out\n  importedComponentDefinition.componentDefinitionPath.split(\"/\").pop();\n  this._childComponents.push([name, importedComponentDefinition, {}]);\n  return new InstalledComponent(definition, name);\n}\nfunction exportAppForAnalysis() {\n  const definitionType = { type: \"app\" };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    definitionType,\n    childComponents,\n    httpMounts: {},\n    exports: serializeExportTree(this._exportTree)\n  };\n}\nfunction serializeExportTree(tree) {\n  const branch = [];\n  for (const [key, child] of Object.entries(tree)) {\n    let node;\n    if (typeof child === \"string\") {\n      node = { type: \"leaf\", leaf: child };\n    } else {\n      node = serializeExportTree(child);\n    }\n    branch.push([key, node]);\n  }\n  return { type: \"branch\", branch };\n}\nfunction serializeChildComponents(childComponents) {\n  return childComponents.map(([name, definition, p]) => {\n    let args = null;\n    if (p !== null) {\n      args = [];\n      for (const [name2, value] of Object.entries(p)) {\n        if (value !== void 0) {\n          args.push([\n            name2,\n            { type: \"value\", value: JSON.stringify(convexToJson(value)) }\n          ]);\n        }\n      }\n    }\n    const path = definition.componentDefinitionPath;\n    if (!path)\n      throw new Error(\n        \"no .componentPath for component definition \" + JSON.stringify(definition, null, 2)\n      );\n    return {\n      name,\n      path,\n      args\n    };\n  });\n}\nfunction exportComponentForAnalysis() {\n  const args = Object.entries(\n    this._args\n  ).map(([name, validator]) => [\n    name,\n    {\n      type: \"value\",\n      value: JSON.stringify(validator.json)\n    }\n  ]);\n  const definitionType = {\n    type: \"childComponent\",\n    name: this._name,\n    args\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    name: this._name,\n    definitionType,\n    childComponents,\n    httpMounts: {},\n    exports: serializeExportTree(this._exportTree)\n  };\n}\nexport function defineComponent(name) {\n  const ret = {\n    _isRoot: false,\n    _name: name,\n    _args: {},\n    _childComponents: [],\n    _exportTree: {},\n    _onInitCallbacks: {},\n    export: exportComponentForAnalysis,\n    use,\n    // pretend to conform to ComponentDefinition, which temporarily expects __args\n    ...{}\n  };\n  return ret;\n}\nexport function defineApp() {\n  const ret = {\n    _isRoot: true,\n    _childComponents: [],\n    _exportTree: {},\n    export: exportAppForAnalysis,\n    use\n  };\n  return ret;\n}\nexport function currentSystemUdfInComponent(componentId) {\n  return {\n    [toReferencePath]: `_reference/currentSystemUdfInComponent/${componentId}`\n  };\n}\nfunction createChildComponents(root, pathParts) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createChildComponents(root, newParts);\n      } else if (prop === toReferencePath) {\n        if (pathParts.length < 1) {\n          const found = [root, ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`${root}.childComponent.functionName\\`. Found: \\`${found}\\``\n          );\n        }\n        return `_reference/childComponent/` + pathParts.join(\"/\");\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nexport const componentsGeneric = () => createChildComponents(\"components\", []);\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport {\n  isValidator,\n  v\n} from \"../values/validator.js\";\nexport class TableDefinition {\n  /**\n   * @internal\n   */\n  constructor(documentType) {\n    __publicField(this, \"indexes\");\n    __publicField(this, \"stagedDbIndexes\");\n    __publicField(this, \"searchIndexes\");\n    __publicField(this, \"stagedSearchIndexes\");\n    __publicField(this, \"vectorIndexes\");\n    __publicField(this, \"stagedVectorIndexes\");\n    // The type of documents stored in this table.\n    __publicField(this, \"validator\");\n    this.indexes = [];\n    this.stagedDbIndexes = [];\n    this.searchIndexes = [];\n    this.stagedSearchIndexes = [];\n    this.vectorIndexes = [];\n    this.stagedVectorIndexes = [];\n    this.validator = documentType;\n  }\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Returns indexes defined on this table.\n   * Intended for the advanced use cases of dynamically deciding which index to use for a query.\n   * If you think you need this, please chime in on ths issue in the Convex JS GitHub repo.\n   * https://github.com/get-convex/convex-js/issues/49\n   */\n  \" indexes\"() {\n    return this.indexes;\n  }\n  index(name, indexConfig) {\n    if (Array.isArray(indexConfig)) {\n      this.indexes.push({\n        indexDescriptor: name,\n        fields: indexConfig\n      });\n    } else if (indexConfig.staged) {\n      this.stagedDbIndexes.push({\n        indexDescriptor: name,\n        fields: indexConfig.fields\n      });\n    } else {\n      this.indexes.push({\n        indexDescriptor: name,\n        fields: indexConfig.fields\n      });\n    }\n    return this;\n  }\n  searchIndex(name, indexConfig) {\n    if (indexConfig.staged) {\n      this.stagedSearchIndexes.push({\n        indexDescriptor: name,\n        searchField: indexConfig.searchField,\n        filterFields: indexConfig.filterFields || []\n      });\n    } else {\n      this.searchIndexes.push({\n        indexDescriptor: name,\n        searchField: indexConfig.searchField,\n        filterFields: indexConfig.filterFields || []\n      });\n    }\n    return this;\n  }\n  vectorIndex(name, indexConfig) {\n    if (indexConfig.staged) {\n      this.stagedVectorIndexes.push({\n        indexDescriptor: name,\n        vectorField: indexConfig.vectorField,\n        dimensions: indexConfig.dimensions,\n        filterFields: indexConfig.filterFields || []\n      });\n    } else {\n      this.vectorIndexes.push({\n        indexDescriptor: name,\n        vectorField: indexConfig.vectorField,\n        dimensions: indexConfig.dimensions,\n        filterFields: indexConfig.filterFields || []\n      });\n    }\n    return this;\n  }\n  /**\n   * Work around for https://github.com/microsoft/TypeScript/issues/57035\n   */\n  self() {\n    return this;\n  }\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    const documentType = this.validator.json;\n    if (typeof documentType !== \"object\") {\n      throw new Error(\n        \"Invalid validator: please make sure that the parameter of `defineTable` is valid (see https://docs.convex.dev/database/schemas)\"\n      );\n    }\n    return {\n      indexes: this.indexes,\n      stagedDbIndexes: this.stagedDbIndexes,\n      searchIndexes: this.searchIndexes,\n      stagedSearchIndexes: this.stagedSearchIndexes,\n      vectorIndexes: this.vectorIndexes,\n      stagedVectorIndexes: this.stagedVectorIndexes,\n      documentType\n    };\n  }\n}\nexport function defineTable(documentSchema) {\n  if (isValidator(documentSchema)) {\n    return new TableDefinition(documentSchema);\n  } else {\n    return new TableDefinition(v.object(documentSchema));\n  }\n}\nexport class SchemaDefinition {\n  /**\n   * @internal\n   */\n  constructor(tables, options) {\n    __publicField(this, \"tables\");\n    __publicField(this, \"strictTableNameTypes\");\n    __publicField(this, \"schemaValidation\");\n    this.tables = tables;\n    this.schemaValidation = options?.schemaValidation === void 0 ? true : options.schemaValidation;\n  }\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    return JSON.stringify({\n      tables: Object.entries(this.tables).map(([tableName, definition]) => {\n        const {\n          indexes,\n          stagedDbIndexes,\n          searchIndexes,\n          stagedSearchIndexes,\n          vectorIndexes,\n          stagedVectorIndexes,\n          documentType\n        } = definition.export();\n        return {\n          tableName,\n          indexes,\n          stagedDbIndexes,\n          searchIndexes,\n          stagedSearchIndexes,\n          vectorIndexes,\n          stagedVectorIndexes,\n          documentType\n        };\n      }),\n      schemaValidation: this.schemaValidation\n    });\n  }\n}\nexport function defineSchema(schema, options) {\n  return new SchemaDefinition(schema, options);\n}\nconst _systemSchema = defineSchema({\n  _scheduled_functions: defineTable({\n    name: v.string(),\n    args: v.array(v.any()),\n    scheduledTime: v.float64(),\n    completedTime: v.optional(v.float64()),\n    state: v.union(\n      v.object({ kind: v.literal(\"pending\") }),\n      v.object({ kind: v.literal(\"inProgress\") }),\n      v.object({ kind: v.literal(\"success\") }),\n      v.object({ kind: v.literal(\"failed\"), error: v.string() }),\n      v.object({ kind: v.literal(\"canceled\") })\n    )\n  }),\n  _storage: defineTable({\n    sha256: v.string(),\n    size: v.float64(),\n    contentType: v.optional(v.string())\n  })\n});\n//# sourceMappingURL=schema.js.map\n","\"use strict\";\nexport * from \"./database.js\";\nexport {\n  actionGeneric,\n  httpActionGeneric,\n  mutationGeneric,\n  queryGeneric,\n  internalActionGeneric,\n  internalMutationGeneric,\n  internalQueryGeneric\n} from \"./impl/registration_impl.js\";\nexport * from \"./pagination.js\";\nexport * from \"./search_filter_builder.js\";\nexport * from \"./storage.js\";\nexport { cronJobs } from \"./cron.js\";\nexport { httpRouter, HttpRouter, ROUTABLE_HTTP_METHODS } from \"./router.js\";\nexport {\n  anyApi,\n  getFunctionName,\n  makeFunctionReference,\n  filterApi\n} from \"./api.js\";\nexport {\n  defineApp,\n  defineComponent,\n  componentsGeneric,\n  createFunctionHandle\n} from \"./components/index.js\";\nexport { currentSystemUdfInComponent } from \"./components/index.js\";\nexport { getFunctionAddress } from \"./components/index.js\";\nexport { defineTable, defineSchema } from \"./schema.js\";\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nimport { convexToJson } from \"../../values/index.js\";\nexport function canonicalizeUdfPath(udfPath) {\n  const pieces = udfPath.split(\":\");\n  let moduleName;\n  let functionName;\n  if (pieces.length === 1) {\n    moduleName = pieces[0];\n    functionName = \"default\";\n  } else {\n    moduleName = pieces.slice(0, pieces.length - 1).join(\":\");\n    functionName = pieces[pieces.length - 1];\n  }\n  if (moduleName.endsWith(\".js\")) {\n    moduleName = moduleName.slice(0, -3);\n  }\n  return `${moduleName}:${functionName}`;\n}\nexport function serializePathAndArgs(udfPath, args) {\n  return JSON.stringify({\n    udfPath: canonicalizeUdfPath(udfPath),\n    args: convexToJson(args)\n  });\n}\nexport function serializePaginatedPathAndArgs(udfPath, args, options) {\n  const { initialNumItems, id } = options;\n  const result = JSON.stringify({\n    type: \"paginated\",\n    udfPath: canonicalizeUdfPath(udfPath),\n    args: convexToJson(args),\n    options: convexToJson({ initialNumItems, id })\n  });\n  return result;\n}\nexport function serializedQueryTokenIsPaginated(token) {\n  return JSON.parse(token).type === \"paginated\";\n}\n//# sourceMappingURL=udf_path_utils.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexToJson } from \"../../values/index.js\";\nimport {\n  canonicalizeUdfPath,\n  serializePathAndArgs\n} from \"./udf_path_utils.js\";\nexport class LocalSyncState {\n  constructor() {\n    __publicField(this, \"nextQueryId\");\n    __publicField(this, \"querySetVersion\");\n    __publicField(this, \"querySet\");\n    __publicField(this, \"queryIdToToken\");\n    __publicField(this, \"identityVersion\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"outstandingQueriesOlderThanRestart\");\n    __publicField(this, \"outstandingAuthOlderThanRestart\");\n    __publicField(this, \"paused\");\n    __publicField(this, \"pendingQuerySetModifications\");\n    this.nextQueryId = 0;\n    this.querySetVersion = 0;\n    this.identityVersion = 0;\n    this.querySet = /* @__PURE__ */ new Map();\n    this.queryIdToToken = /* @__PURE__ */ new Map();\n    this.outstandingQueriesOlderThanRestart = /* @__PURE__ */ new Set();\n    this.outstandingAuthOlderThanRestart = false;\n    this.paused = false;\n    this.pendingQuerySetModifications = /* @__PURE__ */ new Map();\n  }\n  hasSyncedPastLastReconnect() {\n    return this.outstandingQueriesOlderThanRestart.size === 0 && !this.outstandingAuthOlderThanRestart;\n  }\n  markAuthCompletion() {\n    this.outstandingAuthOlderThanRestart = false;\n  }\n  subscribe(udfPath, args, journal, componentPath) {\n    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);\n    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);\n    const existingEntry = this.querySet.get(queryToken);\n    if (existingEntry !== void 0) {\n      existingEntry.numSubscribers += 1;\n      return {\n        queryToken,\n        modification: null,\n        unsubscribe: () => this.removeSubscriber(queryToken)\n      };\n    } else {\n      const queryId = this.nextQueryId++;\n      const query = {\n        id: queryId,\n        canonicalizedUdfPath,\n        args,\n        numSubscribers: 1,\n        journal,\n        componentPath\n      };\n      this.querySet.set(queryToken, query);\n      this.queryIdToToken.set(queryId, queryToken);\n      const baseVersion = this.querySetVersion;\n      const newVersion = this.querySetVersion + 1;\n      const add = {\n        type: \"Add\",\n        queryId,\n        udfPath: canonicalizedUdfPath,\n        args: [convexToJson(args)],\n        journal,\n        componentPath\n      };\n      if (this.paused) {\n        this.pendingQuerySetModifications.set(queryId, add);\n      } else {\n        this.querySetVersion = newVersion;\n      }\n      const modification = {\n        type: \"ModifyQuerySet\",\n        baseVersion,\n        newVersion,\n        modifications: [add]\n      };\n      return {\n        queryToken,\n        modification,\n        unsubscribe: () => this.removeSubscriber(queryToken)\n      };\n    }\n  }\n  transition(transition) {\n    for (const modification of transition.modifications) {\n      switch (modification.type) {\n        case \"QueryUpdated\":\n        case \"QueryFailed\": {\n          this.outstandingQueriesOlderThanRestart.delete(modification.queryId);\n          const journal = modification.journal;\n          if (journal !== void 0) {\n            const queryToken = this.queryIdToToken.get(modification.queryId);\n            if (queryToken !== void 0) {\n              this.querySet.get(queryToken).journal = journal;\n            }\n          }\n          break;\n        }\n        case \"QueryRemoved\": {\n          this.outstandingQueriesOlderThanRestart.delete(modification.queryId);\n          break;\n        }\n        default: {\n          modification;\n          throw new Error(`Invalid modification ${modification.type}`);\n        }\n      }\n    }\n  }\n  queryId(udfPath, args) {\n    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);\n    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);\n    const existingEntry = this.querySet.get(queryToken);\n    if (existingEntry !== void 0) {\n      return existingEntry.id;\n    }\n    return null;\n  }\n  isCurrentOrNewerAuthVersion(version) {\n    return version >= this.identityVersion;\n  }\n  getAuth() {\n    return this.auth;\n  }\n  setAuth(value) {\n    this.auth = {\n      tokenType: \"User\",\n      value\n    };\n    const baseVersion = this.identityVersion;\n    if (!this.paused) {\n      this.identityVersion = baseVersion + 1;\n    }\n    return {\n      type: \"Authenticate\",\n      baseVersion,\n      ...this.auth\n    };\n  }\n  setAdminAuth(value, actingAs) {\n    const auth = {\n      tokenType: \"Admin\",\n      value,\n      impersonating: actingAs\n    };\n    this.auth = auth;\n    const baseVersion = this.identityVersion;\n    if (!this.paused) {\n      this.identityVersion = baseVersion + 1;\n    }\n    return {\n      type: \"Authenticate\",\n      baseVersion,\n      ...auth\n    };\n  }\n  clearAuth() {\n    this.auth = void 0;\n    this.markAuthCompletion();\n    const baseVersion = this.identityVersion;\n    if (!this.paused) {\n      this.identityVersion = baseVersion + 1;\n    }\n    return {\n      type: \"Authenticate\",\n      tokenType: \"None\",\n      baseVersion\n    };\n  }\n  hasAuth() {\n    return !!this.auth;\n  }\n  isNewAuth(value) {\n    return this.auth?.value !== value;\n  }\n  queryPath(queryId) {\n    const pathAndArgs = this.queryIdToToken.get(queryId);\n    if (pathAndArgs) {\n      return this.querySet.get(pathAndArgs).canonicalizedUdfPath;\n    }\n    return null;\n  }\n  queryArgs(queryId) {\n    const pathAndArgs = this.queryIdToToken.get(queryId);\n    if (pathAndArgs) {\n      return this.querySet.get(pathAndArgs).args;\n    }\n    return null;\n  }\n  queryToken(queryId) {\n    return this.queryIdToToken.get(queryId) ?? null;\n  }\n  queryJournal(queryToken) {\n    return this.querySet.get(queryToken)?.journal;\n  }\n  restart(oldRemoteQueryResults) {\n    this.unpause();\n    this.outstandingQueriesOlderThanRestart.clear();\n    const modifications = [];\n    for (const localQuery of this.querySet.values()) {\n      const add = {\n        type: \"Add\",\n        queryId: localQuery.id,\n        udfPath: localQuery.canonicalizedUdfPath,\n        args: [convexToJson(localQuery.args)],\n        journal: localQuery.journal,\n        componentPath: localQuery.componentPath\n      };\n      modifications.push(add);\n      if (!oldRemoteQueryResults.has(localQuery.id)) {\n        this.outstandingQueriesOlderThanRestart.add(localQuery.id);\n      }\n    }\n    this.querySetVersion = 1;\n    const querySet = {\n      type: \"ModifyQuerySet\",\n      baseVersion: 0,\n      newVersion: 1,\n      modifications\n    };\n    if (!this.auth) {\n      this.identityVersion = 0;\n      return [querySet, void 0];\n    }\n    this.outstandingAuthOlderThanRestart = true;\n    const authenticate = {\n      type: \"Authenticate\",\n      baseVersion: 0,\n      ...this.auth\n    };\n    this.identityVersion = 1;\n    return [querySet, authenticate];\n  }\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    const querySet = this.pendingQuerySetModifications.size > 0 ? {\n      type: \"ModifyQuerySet\",\n      baseVersion: this.querySetVersion,\n      newVersion: ++this.querySetVersion,\n      modifications: Array.from(\n        this.pendingQuerySetModifications.values()\n      )\n    } : void 0;\n    const authenticate = this.auth !== void 0 ? {\n      type: \"Authenticate\",\n      baseVersion: this.identityVersion++,\n      ...this.auth\n    } : void 0;\n    this.unpause();\n    return [querySet, authenticate];\n  }\n  unpause() {\n    this.paused = false;\n    this.pendingQuerySetModifications.clear();\n  }\n  removeSubscriber(queryToken) {\n    const localQuery = this.querySet.get(queryToken);\n    if (localQuery.numSubscribers > 1) {\n      localQuery.numSubscribers -= 1;\n      return null;\n    } else {\n      this.querySet.delete(queryToken);\n      this.queryIdToToken.delete(localQuery.id);\n      this.outstandingQueriesOlderThanRestart.delete(localQuery.id);\n      const baseVersion = this.querySetVersion;\n      const newVersion = this.querySetVersion + 1;\n      const remove = {\n        type: \"Remove\",\n        queryId: localQuery.id\n      };\n      if (this.paused) {\n        if (this.pendingQuerySetModifications.has(localQuery.id)) {\n          this.pendingQuerySetModifications.delete(localQuery.id);\n        } else {\n          this.pendingQuerySetModifications.set(localQuery.id, remove);\n        }\n      } else {\n        this.querySetVersion = newVersion;\n      }\n      return {\n        type: \"ModifyQuerySet\",\n        baseVersion,\n        newVersion,\n        modifications: [remove]\n      };\n    }\n  }\n}\n//# sourceMappingURL=local_state.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { logForFunction } from \"../logging.js\";\nexport class RequestManager {\n  constructor(logger, markConnectionStateDirty) {\n    this.logger = logger;\n    this.markConnectionStateDirty = markConnectionStateDirty;\n    __publicField(this, \"inflightRequests\");\n    __publicField(this, \"requestsOlderThanRestart\");\n    __publicField(this, \"inflightMutationsCount\", 0);\n    __publicField(this, \"inflightActionsCount\", 0);\n    this.inflightRequests = /* @__PURE__ */ new Map();\n    this.requestsOlderThanRestart = /* @__PURE__ */ new Set();\n  }\n  request(message, sent) {\n    const result = new Promise((resolve) => {\n      const status = sent ? \"Requested\" : \"NotSent\";\n      this.inflightRequests.set(message.requestId, {\n        message,\n        status: { status, requestedAt: /* @__PURE__ */ new Date(), onResult: resolve }\n      });\n      if (message.type === \"Mutation\") {\n        this.inflightMutationsCount++;\n      } else if (message.type === \"Action\") {\n        this.inflightActionsCount++;\n      }\n    });\n    this.markConnectionStateDirty();\n    return result;\n  }\n  /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise.\n   */\n  onResponse(response) {\n    const requestInfo = this.inflightRequests.get(response.requestId);\n    if (requestInfo === void 0) {\n      return null;\n    }\n    if (requestInfo.status.status === \"Completed\") {\n      return null;\n    }\n    const udfType = requestInfo.message.type === \"Mutation\" ? \"mutation\" : \"action\";\n    const udfPath = requestInfo.message.udfPath;\n    for (const line of response.logLines) {\n      logForFunction(this.logger, \"info\", udfType, udfPath, line);\n    }\n    const status = requestInfo.status;\n    let result;\n    let onResolve;\n    if (response.success) {\n      result = {\n        success: true,\n        logLines: response.logLines,\n        value: jsonToConvex(response.result)\n      };\n      onResolve = () => status.onResult(result);\n    } else {\n      const errorMessage = response.result;\n      const { errorData } = response;\n      logForFunction(this.logger, \"error\", udfType, udfPath, errorMessage);\n      result = {\n        success: false,\n        errorMessage,\n        errorData: errorData !== void 0 ? jsonToConvex(errorData) : void 0,\n        logLines: response.logLines\n      };\n      onResolve = () => status.onResult(result);\n    }\n    if (response.type === \"ActionResponse\" || !response.success) {\n      onResolve();\n      this.inflightRequests.delete(response.requestId);\n      this.requestsOlderThanRestart.delete(response.requestId);\n      if (requestInfo.message.type === \"Action\") {\n        this.inflightActionsCount--;\n      } else if (requestInfo.message.type === \"Mutation\") {\n        this.inflightMutationsCount--;\n      }\n      this.markConnectionStateDirty();\n      return { requestId: response.requestId, result };\n    }\n    requestInfo.status = {\n      status: \"Completed\",\n      result,\n      ts: response.ts,\n      onResolve\n    };\n    return null;\n  }\n  // Remove and returns completed requests.\n  removeCompleted(ts) {\n    const completeRequests = /* @__PURE__ */ new Map();\n    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {\n      const status = requestInfo.status;\n      if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n        status.onResolve();\n        completeRequests.set(requestId, status.result);\n        if (requestInfo.message.type === \"Mutation\") {\n          this.inflightMutationsCount--;\n        } else if (requestInfo.message.type === \"Action\") {\n          this.inflightActionsCount--;\n        }\n        this.inflightRequests.delete(requestId);\n        this.requestsOlderThanRestart.delete(requestId);\n      }\n    }\n    if (completeRequests.size > 0) {\n      this.markConnectionStateDirty();\n    }\n    return completeRequests;\n  }\n  restart() {\n    this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());\n    const allMessages = [];\n    for (const [requestId, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n      if (value.message.type === \"Mutation\") {\n        allMessages.push(value.message);\n      } else if (value.message.type === \"Action\") {\n        this.inflightRequests.delete(requestId);\n        this.requestsOlderThanRestart.delete(requestId);\n        this.inflightActionsCount--;\n        if (value.status.status === \"Completed\") {\n          throw new Error(\"Action should never be in 'Completed' state\");\n        }\n        value.status.onResult({\n          success: false,\n          errorMessage: \"Connection lost while action was in flight\",\n          logLines: []\n        });\n      }\n    }\n    this.markConnectionStateDirty();\n    return allMessages;\n  }\n  resume() {\n    const allMessages = [];\n    for (const [, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n    }\n    return allMessages;\n  }\n  /**\n   * @returns true if there are any requests that have been requested but have\n   * not be completed yet.\n   */\n  hasIncompleteRequests() {\n    for (const requestInfo of this.inflightRequests.values()) {\n      if (requestInfo.status.status === \"Requested\") {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @returns true if there are any inflight requests, including ones that have\n   * completed on the server, but have not been applied.\n   */\n  hasInflightRequests() {\n    return this.inflightRequests.size > 0;\n  }\n  /**\n   * @returns true if there are any inflight requests, that have been hanging around\n   * since prior to the most recent restart.\n   */\n  hasSyncedPastLastReconnect() {\n    return this.requestsOlderThanRestart.size === 0;\n  }\n  timeOfOldestInflightRequest() {\n    if (this.inflightRequests.size === 0) {\n      return null;\n    }\n    let oldestInflightRequest = Date.now();\n    for (const request of this.inflightRequests.values()) {\n      if (request.status.status !== \"Completed\") {\n        if (request.status.requestedAt.getTime() < oldestInflightRequest) {\n          oldestInflightRequest = request.status.requestedAt.getTime();\n        }\n      }\n    }\n    return new Date(oldestInflightRequest);\n  }\n  /**\n   * @returns The number of mutations currently in flight.\n   */\n  inflightMutations() {\n    return this.inflightMutationsCount;\n  }\n  /**\n   * @returns The number of actions currently in flight.\n   */\n  inflightActions() {\n    return this.inflightActionsCount;\n  }\n}\n//# sourceMappingURL=request_manager.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport {\n  getFunctionName\n} from \"../../server/api.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { createHybridErrorStacktrace, forwardData } from \"../logging.js\";\nimport {\n  canonicalizeUdfPath,\n  serializePathAndArgs\n} from \"./udf_path_utils.js\";\nimport { ConvexError } from \"../../values/errors.js\";\nclass OptimisticLocalStoreImpl {\n  constructor(queryResults) {\n    // A references of the query results in OptimisticQueryResults\n    __publicField(this, \"queryResults\");\n    // All of the queries modified by this class\n    __publicField(this, \"modifiedQueries\");\n    this.queryResults = queryResults;\n    this.modifiedQueries = [];\n  }\n  getQuery(query, ...args) {\n    const queryArgs = parseArgs(args[0]);\n    const name = getFunctionName(query);\n    const queryResult = this.queryResults.get(\n      serializePathAndArgs(name, queryArgs)\n    );\n    if (queryResult === void 0) {\n      return void 0;\n    }\n    return OptimisticLocalStoreImpl.queryValue(queryResult.result);\n  }\n  getAllQueries(query) {\n    const queriesWithName = [];\n    const name = getFunctionName(query);\n    for (const queryResult of this.queryResults.values()) {\n      if (queryResult.udfPath === canonicalizeUdfPath(name)) {\n        queriesWithName.push({\n          args: queryResult.args,\n          value: OptimisticLocalStoreImpl.queryValue(queryResult.result)\n        });\n      }\n    }\n    return queriesWithName;\n  }\n  setQuery(queryReference, args, value) {\n    const queryArgs = parseArgs(args);\n    const name = getFunctionName(queryReference);\n    const queryToken = serializePathAndArgs(name, queryArgs);\n    let result;\n    if (value === void 0) {\n      result = void 0;\n    } else {\n      result = {\n        success: true,\n        value,\n        // It's an optimistic update, so there are no function logs to show.\n        logLines: []\n      };\n    }\n    const query = {\n      udfPath: name,\n      args: queryArgs,\n      result\n    };\n    this.queryResults.set(queryToken, query);\n    this.modifiedQueries.push(queryToken);\n  }\n  static queryValue(result) {\n    if (result === void 0) {\n      return void 0;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      return void 0;\n    }\n  }\n}\nexport class OptimisticQueryResults {\n  constructor() {\n    __publicField(this, \"queryResults\");\n    __publicField(this, \"optimisticUpdates\");\n    this.queryResults = /* @__PURE__ */ new Map();\n    this.optimisticUpdates = [];\n  }\n  /**\n   * Apply all optimistic updates on top of server query results\n   */\n  ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {\n    this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId) => {\n      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n    });\n    const oldQueryResults = this.queryResults;\n    this.queryResults = new Map(serverQueryResults);\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    for (const updateAndId of this.optimisticUpdates) {\n      updateAndId.update(localStore);\n    }\n    const changedQueries = [];\n    for (const [queryToken, query] of this.queryResults) {\n      const oldQuery = oldQueryResults.get(queryToken);\n      if (oldQuery === void 0 || oldQuery.result !== query.result) {\n        changedQueries.push(queryToken);\n      }\n    }\n    return changedQueries;\n  }\n  applyOptimisticUpdate(update, mutationId) {\n    this.optimisticUpdates.push({\n      update,\n      mutationId\n    });\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    update(localStore);\n    return localStore.modifiedQueries;\n  }\n  /**\n   * \"Raw\" with respect to errors vs values, but query results still have\n   * optimistic updates applied.\n   *\n   * @internal\n   */\n  rawQueryResult(queryToken) {\n    const query = this.queryResults.get(queryToken);\n    if (query === void 0) {\n      return void 0;\n    }\n    return query.result;\n  }\n  queryResult(queryToken) {\n    const query = this.queryResults.get(queryToken);\n    if (query === void 0) {\n      return void 0;\n    }\n    const result = query.result;\n    if (result === void 0) {\n      return void 0;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      if (result.errorData !== void 0) {\n        throw forwardData(\n          result,\n          new ConvexError(\n            createHybridErrorStacktrace(\"query\", query.udfPath, result)\n          )\n        );\n      }\n      throw new Error(\n        createHybridErrorStacktrace(\"query\", query.udfPath, result)\n      );\n    }\n  }\n  hasQueryResult(queryToken) {\n    return this.queryResults.get(queryToken) !== void 0;\n  }\n  /**\n   * @internal\n   */\n  queryLogs(queryToken) {\n    const query = this.queryResults.get(queryToken);\n    return query?.result?.logLines;\n  }\n}\n//# sourceMappingURL=optimistic_updates_impl.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { Long } from \"../../vendor/long.js\";\nimport { logForFunction } from \"../logging.js\";\nexport class RemoteQuerySet {\n  constructor(queryPath, logger) {\n    __publicField(this, \"version\");\n    __publicField(this, \"remoteQuerySet\");\n    __publicField(this, \"queryPath\");\n    __publicField(this, \"logger\");\n    this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };\n    this.remoteQuerySet = /* @__PURE__ */ new Map();\n    this.queryPath = queryPath;\n    this.logger = logger;\n  }\n  transition(transition) {\n    const start = transition.startVersion;\n    if (this.version.querySet !== start.querySet || this.version.ts.notEquals(start.ts) || this.version.identity !== start.identity) {\n      throw new Error(\n        `Invalid start version: ${start.ts.toString()}:${start.querySet}:${start.identity}, transitioning from ${this.version.ts.toString()}:${this.version.querySet}:${this.version.identity}`\n      );\n    }\n    for (const modification of transition.modifications) {\n      switch (modification.type) {\n        case \"QueryUpdated\": {\n          const queryPath = this.queryPath(modification.queryId);\n          if (queryPath) {\n            for (const line of modification.logLines) {\n              logForFunction(this.logger, \"info\", \"query\", queryPath, line);\n            }\n          }\n          const value = jsonToConvex(modification.value ?? null);\n          this.remoteQuerySet.set(modification.queryId, {\n            success: true,\n            value,\n            logLines: modification.logLines\n          });\n          break;\n        }\n        case \"QueryFailed\": {\n          const queryPath = this.queryPath(modification.queryId);\n          if (queryPath) {\n            for (const line of modification.logLines) {\n              logForFunction(this.logger, \"info\", \"query\", queryPath, line);\n            }\n          }\n          const { errorData } = modification;\n          this.remoteQuerySet.set(modification.queryId, {\n            success: false,\n            errorMessage: modification.errorMessage,\n            errorData: errorData !== void 0 ? jsonToConvex(errorData) : void 0,\n            logLines: modification.logLines\n          });\n          break;\n        }\n        case \"QueryRemoved\": {\n          this.remoteQuerySet.delete(modification.queryId);\n          break;\n        }\n        default: {\n          modification;\n          throw new Error(`Invalid modification ${modification.type}`);\n        }\n      }\n    }\n    this.version = transition.endVersion;\n  }\n  remoteQueryResults() {\n    return this.remoteQuerySet;\n  }\n  timestamp() {\n    return this.version.ts;\n  }\n}\n//# sourceMappingURL=remote_query_set.js.map\n","\"use strict\";\nimport { Base64 } from \"../../values/index.js\";\nimport { Long } from \"../../vendor/long.js\";\nexport function u64ToLong(encoded) {\n  const integerBytes = Base64.toByteArray(encoded);\n  return Long.fromBytesLE(Array.from(integerBytes));\n}\nexport function longToU64(raw) {\n  const integerBytes = new Uint8Array(raw.toBytesLE());\n  return Base64.fromByteArray(integerBytes);\n}\nexport function parseServerMessage(encoded) {\n  switch (encoded.type) {\n    case \"FatalError\":\n    case \"AuthError\":\n    case \"ActionResponse\":\n    case \"TransitionChunk\":\n    case \"Ping\": {\n      return { ...encoded };\n    }\n    case \"MutationResponse\": {\n      if (encoded.success) {\n        return { ...encoded, ts: u64ToLong(encoded.ts) };\n      } else {\n        return { ...encoded };\n      }\n    }\n    case \"Transition\": {\n      return {\n        ...encoded,\n        startVersion: {\n          ...encoded.startVersion,\n          ts: u64ToLong(encoded.startVersion.ts)\n        },\n        endVersion: {\n          ...encoded.endVersion,\n          ts: u64ToLong(encoded.endVersion.ts)\n        }\n      };\n    }\n    default: {\n      encoded;\n    }\n  }\n  return void 0;\n}\nexport function encodeClientMessage(message) {\n  switch (message.type) {\n    case \"Authenticate\":\n    case \"ModifyQuerySet\":\n    case \"Mutation\":\n    case \"Action\":\n    case \"Event\": {\n      return { ...message };\n    }\n    case \"Connect\": {\n      if (message.maxObservedTimestamp !== void 0) {\n        return {\n          ...message,\n          maxObservedTimestamp: longToU64(message.maxObservedTimestamp)\n        };\n      } else {\n        return { ...message, maxObservedTimestamp: void 0 };\n      }\n    }\n    default: {\n      message;\n    }\n  }\n  return void 0;\n}\n//# sourceMappingURL=protocol.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport {\n  encodeClientMessage,\n  parseServerMessage\n} from \"./protocol.js\";\nconst CLOSE_NORMAL = 1e3;\nconst CLOSE_GOING_AWAY = 1001;\nconst CLOSE_NO_STATUS = 1005;\nconst CLOSE_NOT_FOUND = 4040;\nlet firstTime;\nfunction monotonicMillis() {\n  if (firstTime === void 0) {\n    firstTime = Date.now();\n  }\n  if (typeof performance === \"undefined\" || !performance.now) {\n    return Date.now();\n  }\n  return Math.round(firstTime + performance.now());\n}\nfunction prettyNow() {\n  return `t=${Math.round((monotonicMillis() - firstTime) / 100) / 10}s`;\n}\nconst serverDisconnectErrors = {\n  // A known error, e.g. during a restart or push\n  InternalServerError: { timeout: 1e3 },\n  // ErrorMetadata::overloaded() messages that we realy should back off\n  SubscriptionsWorkerFullError: { timeout: 3e3 },\n  TooManyConcurrentRequests: { timeout: 3e3 },\n  CommitterFullError: { timeout: 3e3 },\n  AwsTooManyRequestsException: { timeout: 3e3 },\n  ExecuteFullError: { timeout: 3e3 },\n  SystemTimeoutError: { timeout: 3e3 },\n  ExpiredInQueue: { timeout: 3e3 },\n  // ErrorMetadata::feature_temporarily_unavailable() that typically indicate a deploy just happened\n  VectorIndexesUnavailable: { timeout: 1e3 },\n  SearchIndexesUnavailable: { timeout: 1e3 },\n  TableSummariesUnavailable: { timeout: 1e3 },\n  // More ErrorMetadata::overloaded()\n  VectorIndexTooLarge: { timeout: 3e3 },\n  SearchIndexTooLarge: { timeout: 3e3 },\n  TooManyWritesInTimePeriod: { timeout: 3e3 }\n};\nfunction classifyDisconnectError(s) {\n  if (s === void 0) return \"Unknown\";\n  for (const prefix of Object.keys(\n    serverDisconnectErrors\n  )) {\n    if (s.startsWith(prefix)) {\n      return prefix;\n    }\n  }\n  return \"Unknown\";\n}\nexport class WebSocketManager {\n  constructor(uri, callbacks, webSocketConstructor, logger, markConnectionStateDirty, debug) {\n    this.markConnectionStateDirty = markConnectionStateDirty;\n    this.debug = debug;\n    __publicField(this, \"socket\");\n    __publicField(this, \"connectionCount\");\n    __publicField(this, \"_hasEverConnected\", false);\n    __publicField(this, \"lastCloseReason\");\n    // State for assembling the split-up Transition currently being received.\n    __publicField(this, \"transitionChunkBuffer\", null);\n    /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n    __publicField(this, \"defaultInitialBackoff\");\n    /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n    __publicField(this, \"maxBackoff\");\n    /** How many times have we failed consecutively? */\n    __publicField(this, \"retries\");\n    /** How long before lack of server response causes us to initiate a reconnect,\n     * in ms */\n    __publicField(this, \"serverInactivityThreshold\");\n    __publicField(this, \"reconnectDueToServerInactivityTimeout\");\n    __publicField(this, \"uri\");\n    __publicField(this, \"onOpen\");\n    __publicField(this, \"onResume\");\n    __publicField(this, \"onMessage\");\n    __publicField(this, \"webSocketConstructor\");\n    __publicField(this, \"logger\");\n    __publicField(this, \"onServerDisconnectError\");\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = { state: \"disconnected\" };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n    this.defaultInitialBackoff = 1e3;\n    this.maxBackoff = 16e3;\n    this.retries = 0;\n    this.serverInactivityThreshold = 6e4;\n    this.reconnectDueToServerInactivityTimeout = null;\n    this.uri = uri;\n    this.onOpen = callbacks.onOpen;\n    this.onResume = callbacks.onResume;\n    this.onMessage = callbacks.onMessage;\n    this.onServerDisconnectError = callbacks.onServerDisconnectError;\n    this.logger = logger;\n    this.connect();\n  }\n  setSocketState(state) {\n    this.socket = state;\n    this._logVerbose(\n      `socket state changed: ${this.socket.state}, paused: ${\"paused\" in this.socket ? this.socket.paused : void 0}`\n    );\n    this.markConnectionStateDirty();\n  }\n  assembleTransition(chunk) {\n    if (chunk.partNumber < 0 || chunk.partNumber >= chunk.totalParts || chunk.totalParts === 0 || this.transitionChunkBuffer && (this.transitionChunkBuffer.totalParts !== chunk.totalParts || this.transitionChunkBuffer.transitionId !== chunk.transitionId)) {\n      this.transitionChunkBuffer = null;\n      throw new Error(\"Invalid TransitionChunk\");\n    }\n    if (this.transitionChunkBuffer === null) {\n      this.transitionChunkBuffer = {\n        chunks: [],\n        totalParts: chunk.totalParts,\n        transitionId: chunk.transitionId\n      };\n    }\n    if (chunk.partNumber !== this.transitionChunkBuffer.chunks.length) {\n      const expectedLength = this.transitionChunkBuffer.chunks.length;\n      this.transitionChunkBuffer = null;\n      throw new Error(\n        `TransitionChunk received out of order: expected part ${expectedLength}, got ${chunk.partNumber}`\n      );\n    }\n    this.transitionChunkBuffer.chunks.push(chunk.chunk);\n    if (this.transitionChunkBuffer.chunks.length === chunk.totalParts) {\n      const fullJson = this.transitionChunkBuffer.chunks.join(\"\");\n      this.transitionChunkBuffer = null;\n      const transition = parseServerMessage(JSON.parse(fullJson));\n      if (transition.type !== \"Transition\") {\n        throw new Error(\n          `Expected Transition, got ${transition.type} after assembling chunks`\n        );\n      }\n      return transition;\n    }\n    return null;\n  }\n  connect() {\n    if (this.socket.state === \"terminated\") {\n      return;\n    }\n    if (this.socket.state !== \"disconnected\" && this.socket.state !== \"stopped\") {\n      throw new Error(\n        \"Didn't start connection from disconnected state: \" + this.socket.state\n      );\n    }\n    const ws = new this.webSocketConstructor(this.uri);\n    this._logVerbose(\"constructed WebSocket\");\n    this.setSocketState({\n      state: \"connecting\",\n      ws,\n      paused: \"no\"\n    });\n    this.resetServerInactivityTimeout();\n    ws.onopen = () => {\n      this.logger.logVerbose(\"begin ws.onopen\");\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.setSocketState({\n        state: \"ready\",\n        ws,\n        paused: this.socket.paused === \"yes\" ? \"uninitialized\" : \"no\"\n      });\n      this.resetServerInactivityTimeout();\n      if (this.socket.paused === \"no\") {\n        this._hasEverConnected = true;\n        this.onOpen({\n          connectionCount: this.connectionCount,\n          lastCloseReason: this.lastCloseReason,\n          clientTs: monotonicMillis()\n        });\n      }\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        if (this.lastCloseReason) {\n          this.logger.log(\n            \"WebSocket reconnected at\",\n            prettyNow(),\n            \"after disconnect due to\",\n            this.lastCloseReason\n          );\n        } else {\n          this.logger.log(\"WebSocket reconnected at\", prettyNow());\n        }\n      }\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    ws.onerror = (error) => {\n      this.transitionChunkBuffer = null;\n      const message = error.message;\n      if (message) {\n        this.logger.log(`WebSocket error message: ${message}`);\n      }\n    };\n    ws.onmessage = (message) => {\n      this.resetServerInactivityTimeout();\n      const messageLength = message.data.length;\n      let serverMessage = parseServerMessage(JSON.parse(message.data));\n      this._logVerbose(`received ws message with type ${serverMessage.type}`);\n      if (serverMessage.type === \"Ping\") {\n        return;\n      }\n      if (serverMessage.type === \"TransitionChunk\") {\n        const transition = this.assembleTransition(serverMessage);\n        if (!transition) {\n          return;\n        }\n        serverMessage = transition;\n        this._logVerbose(\n          `assembled full ws message of type ${serverMessage.type}`\n        );\n      }\n      if (this.transitionChunkBuffer !== null) {\n        this.transitionChunkBuffer = null;\n        this.logger.log(\n          `Received unexpected ${serverMessage.type} while buffering TransitionChunks`\n        );\n      }\n      if (serverMessage.type === \"Transition\") {\n        this.reportLargeTransition({\n          messageLength,\n          transition: serverMessage\n        });\n      }\n      const response = this.onMessage(serverMessage);\n      if (response.hasSyncedPastLastReconnect) {\n        this.retries = 0;\n        this.markConnectionStateDirty();\n      }\n    };\n    ws.onclose = (event) => {\n      this._logVerbose(\"begin ws.onclose\");\n      this.transitionChunkBuffer = null;\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason || `closed with code ${event.code}`;\n      }\n      if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded\n      event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {\n        let msg = `WebSocket closed with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        this.logger.log(msg);\n        if (this.onServerDisconnectError && event.reason) {\n          this.onServerDisconnectError(msg);\n        }\n      }\n      const reason = classifyDisconnectError(event.reason);\n      this.scheduleReconnect(reason);\n      return;\n    };\n  }\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState() {\n    return this.socket.state;\n  }\n  /**\n   * @param message - A ClientMessage to send.\n   * @returns Whether the message (might have been) sent.\n   */\n  sendMessage(message) {\n    const messageForLog = {\n      type: message.type,\n      ...message.type === \"Authenticate\" && message.tokenType === \"User\" ? {\n        value: `...${message.value.slice(-7)}`\n      } : {}\n    };\n    if (this.socket.state === \"ready\" && this.socket.paused === \"no\") {\n      const encodedMessage = encodeClientMessage(message);\n      const request = JSON.stringify(encodedMessage);\n      let sent = false;\n      try {\n        this.socket.ws.send(request);\n        sent = true;\n      } catch (error) {\n        this.logger.log(\n          `Failed to send message on WebSocket, reconnecting: ${error}`\n        );\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n      this._logVerbose(\n        `${sent ? \"sent\" : \"failed to send\"} message with type ${message.type}: ${JSON.stringify(\n          messageForLog\n        )}`\n      );\n      return true;\n    }\n    this._logVerbose(\n      `message not sent (socket state: ${this.socket.state}, paused: ${\"paused\" in this.socket ? this.socket.paused : void 0}): ${JSON.stringify(\n        messageForLog\n      )}`\n    );\n    return false;\n  }\n  resetServerInactivityTimeout() {\n    if (this.socket.state === \"terminated\") {\n      return;\n    }\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n  scheduleReconnect(reason) {\n    this.socket = { state: \"disconnected\" };\n    const backoff = this.nextBackoff(reason);\n    this.markConnectionStateDirty();\n    this.logger.log(`Attempting reconnect in ${Math.round(backoff)}ms`);\n    setTimeout(() => this.connect(), backoff);\n  }\n  /**\n   * Close the WebSocket and schedule a reconnect.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  closeAndReconnect(closeReason) {\n    this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"terminated\":\n      case \"stopped\":\n        return;\n      case \"connecting\":\n      case \"ready\": {\n        this.lastCloseReason = closeReason;\n        void this.close();\n        this.scheduleReconnect(\"client\");\n        return;\n      }\n      default: {\n        this.socket;\n      }\n    }\n  }\n  /**\n   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant\n   * calls. Use this instead of directly calling `ws.close()`\n   *\n   * It is the callers responsibility to update the state after this method is called so that the\n   * closed socket is not accessible or used again after this method is called\n   */\n  close() {\n    this.transitionChunkBuffer = null;\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"terminated\":\n      case \"stopped\":\n        return Promise.resolve();\n      case \"connecting\": {\n        const ws = this.socket.ws;\n        ws.onmessage = (_message) => {\n          this._logVerbose(\"Ignoring message received after close\");\n        };\n        return new Promise((r) => {\n          ws.onclose = () => {\n            this._logVerbose(\"Closed after connecting\");\n            r();\n          };\n          ws.onopen = () => {\n            this._logVerbose(\"Opened after connecting\");\n            ws.close();\n          };\n        });\n      }\n      case \"ready\": {\n        this._logVerbose(\"ws.close called\");\n        const ws = this.socket.ws;\n        ws.onmessage = (_message) => {\n          this._logVerbose(\"Ignoring message received after close\");\n        };\n        const result = new Promise((r) => {\n          ws.onclose = () => {\n            r();\n          };\n        });\n        ws.close();\n        return result;\n      }\n      default: {\n        this.socket;\n        return Promise.resolve();\n      }\n    }\n  }\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  terminate() {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"terminated\":\n      case \"stopped\":\n      case \"disconnected\":\n      case \"connecting\":\n      case \"ready\": {\n        const result = this.close();\n        this.setSocketState({ state: \"terminated\" });\n        return result;\n      }\n      default: {\n        this.socket;\n        throw new Error(\n          `Invalid websocket state: ${this.socket.state}`\n        );\n      }\n    }\n  }\n  stop() {\n    switch (this.socket.state) {\n      case \"terminated\":\n        return Promise.resolve();\n      case \"connecting\":\n      case \"stopped\":\n      case \"disconnected\":\n      case \"ready\": {\n        const result = this.close();\n        this.socket = { state: \"stopped\" };\n        return result;\n      }\n      default: {\n        this.socket;\n        return Promise.resolve();\n      }\n    }\n  }\n  /**\n   * Create a new WebSocket after a previous `stop()`, unless `terminate()` was\n   * called before.\n   */\n  tryRestart() {\n    switch (this.socket.state) {\n      case \"stopped\":\n        break;\n      case \"terminated\":\n      case \"connecting\":\n      case \"ready\":\n      case \"disconnected\":\n        this.logger.logVerbose(\"Restart called without stopping first\");\n        return;\n      default: {\n        this.socket;\n      }\n    }\n    this.connect();\n  }\n  pause() {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"stopped\":\n      case \"terminated\":\n        return;\n      case \"connecting\":\n      case \"ready\": {\n        this.socket = { ...this.socket, paused: \"yes\" };\n        return;\n      }\n      default: {\n        this.socket;\n        return;\n      }\n    }\n  }\n  /**\n   * Resume the state machine if previously paused.\n   */\n  resume() {\n    switch (this.socket.state) {\n      case \"connecting\":\n        this.socket = { ...this.socket, paused: \"no\" };\n        return;\n      case \"ready\":\n        if (this.socket.paused === \"uninitialized\") {\n          this.socket = { ...this.socket, paused: \"no\" };\n          this.onOpen({\n            connectionCount: this.connectionCount,\n            lastCloseReason: this.lastCloseReason,\n            clientTs: monotonicMillis()\n          });\n        } else if (this.socket.paused === \"yes\") {\n          this.socket = { ...this.socket, paused: \"no\" };\n          this.onResume();\n        }\n        return;\n      case \"terminated\":\n      case \"stopped\":\n      case \"disconnected\":\n        return;\n      default: {\n        this.socket;\n      }\n    }\n    this.connect();\n  }\n  connectionState() {\n    return {\n      isConnected: this.socket.state === \"ready\",\n      hasEverConnected: this._hasEverConnected,\n      connectionCount: this.connectionCount,\n      connectionRetries: this.retries\n    };\n  }\n  _logVerbose(message) {\n    this.logger.logVerbose(message);\n  }\n  nextBackoff(reason) {\n    const initialBackoff = reason === \"client\" ? 100 : reason === \"Unknown\" ? this.defaultInitialBackoff : serverDisconnectErrors[reason].timeout;\n    const baseBackoff = initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n  reportLargeTransition({\n    transition,\n    messageLength\n  }) {\n    if (transition.clientClockSkew === void 0 || transition.serverTs === void 0) {\n      return;\n    }\n    const transitionTransitTime = monotonicMillis() - // client time now\n    // clientClockSkew = (server time + upstream latency) - client time\n    // clientClockSkew is \"how many milliseconds behind (slow) is the client clock\"\n    // but the latency of the Connect message inflates this, making it appear further behind\n    transition.clientClockSkew - transition.serverTs / 1e6;\n    const prettyTransitionTime = `${Math.round(transitionTransitTime)}ms`;\n    const prettyMessageMB = `${Math.round(messageLength / 1e4) / 100}MB`;\n    const bytesPerSecond = messageLength / (transitionTransitTime / 1e3);\n    const prettyBytesPerSecond = `${Math.round(bytesPerSecond / 1e4) / 100}MB per second`;\n    this._logVerbose(\n      `received ${prettyMessageMB} transition in ${prettyTransitionTime} at ${prettyBytesPerSecond}`\n    );\n    if (messageLength > 2e7) {\n      this.logger.log(\n        `received query results totaling more that 20MB (${prettyMessageMB}) which will take a long time to download on slower connections`\n      );\n    } else if (transitionTransitTime > 2e4) {\n      this.logger.log(\n        `received query results totaling ${prettyMessageMB} which took more than 20s to arrive (${prettyTransitionTime})`\n      );\n    }\n    if (this.debug) {\n      this.sendMessage({\n        type: \"Event\",\n        eventType: \"ClientReceivedTransition\",\n        event: { transitionTransitTime, messageLength }\n      });\n    }\n  }\n}\n//# sourceMappingURL=web_socket_manager.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { jwtDecode } from \"../../vendor/jwt-decode/index.js\";\nconst MAXIMUM_REFRESH_DELAY = 20 * 24 * 60 * 60 * 1e3;\nconst MAX_TOKEN_CONFIRMATION_ATTEMPTS = 2;\nexport class AuthenticationManager {\n  constructor(syncState, callbacks, config) {\n    __publicField(this, \"authState\", { state: \"noAuth\" });\n    // Used to detect races involving `setConfig` calls\n    // while a token is being fetched.\n    __publicField(this, \"configVersion\", 0);\n    // Shared by the BaseClient so that the auth manager can easily inspect it\n    __publicField(this, \"syncState\");\n    // Passed down by BaseClient, sends a message to the server\n    __publicField(this, \"authenticate\");\n    __publicField(this, \"stopSocket\");\n    __publicField(this, \"tryRestartSocket\");\n    __publicField(this, \"pauseSocket\");\n    __publicField(this, \"resumeSocket\");\n    // Passed down by BaseClient, sends a message to the server\n    __publicField(this, \"clearAuth\");\n    __publicField(this, \"logger\");\n    __publicField(this, \"refreshTokenLeewaySeconds\");\n    // Number of times we have attempted to confirm the latest token. We retry up\n    // to `MAX_TOKEN_CONFIRMATION_ATTEMPTS` times.\n    __publicField(this, \"tokenConfirmationAttempts\", 0);\n    this.syncState = syncState;\n    this.authenticate = callbacks.authenticate;\n    this.stopSocket = callbacks.stopSocket;\n    this.tryRestartSocket = callbacks.tryRestartSocket;\n    this.pauseSocket = callbacks.pauseSocket;\n    this.resumeSocket = callbacks.resumeSocket;\n    this.clearAuth = callbacks.clearAuth;\n    this.logger = config.logger;\n    this.refreshTokenLeewaySeconds = config.refreshTokenLeewaySeconds;\n  }\n  async setConfig(fetchToken, onChange) {\n    this.resetAuthState();\n    this._logVerbose(\"pausing WS for auth token fetch\");\n    this.pauseSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {\n      forceRefreshToken: false\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfCachedToken\",\n        config: { fetchToken, onAuthChange: onChange },\n        hasRetried: false\n      });\n      this.authenticate(token.value);\n    } else {\n      this.setAuthState({\n        state: \"initialRefetch\",\n        config: { fetchToken, onAuthChange: onChange }\n      });\n      await this.refetchToken();\n    }\n    this._logVerbose(\"resuming WS after auth token fetch\");\n    this.resumeSocket();\n  }\n  onTransition(serverMessage) {\n    if (!this.syncState.isCurrentOrNewerAuthVersion(\n      serverMessage.endVersion.identity\n    )) {\n      return;\n    }\n    if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) {\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfCachedToken\") {\n      this._logVerbose(\"server confirmed auth token is valid\");\n      void this.refetchToken();\n      this.authState.config.onAuthChange(true);\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this._logVerbose(\"server confirmed new auth token is valid\");\n      this.scheduleTokenRefetch(this.authState.token);\n      this.tokenConfirmationAttempts = 0;\n      if (!this.authState.hadAuth) {\n        this.authState.config.onAuthChange(true);\n      }\n    }\n  }\n  onAuthError(serverMessage) {\n    if (serverMessage.authUpdateAttempted === false && (this.authState.state === \"waitingForServerConfirmationOfFreshToken\" || this.authState.state === \"waitingForServerConfirmationOfCachedToken\")) {\n      this._logVerbose(\"ignoring non-auth token expired error\");\n      return;\n    }\n    const { baseVersion } = serverMessage;\n    if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {\n      this._logVerbose(\"ignoring auth error for previous auth attempt\");\n      return;\n    }\n    void this.tryToReauthenticate(serverMessage);\n    return;\n  }\n  // This is similar to `refetchToken` defined below, in fact we\n  // don't represent them as different states, but it is different\n  // in that we pause the WebSocket so that mutations\n  // don't retry with bad auth.\n  async tryToReauthenticate(serverMessage) {\n    this._logVerbose(`attempting to reauthenticate: ${serverMessage.error}`);\n    if (\n      // No way to fetch another token, kaboom\n      this.authState.state === \"noAuth\" || // We failed on a fresh token. After a small number of retries, we give up\n      // and clear the auth state to avoid infinite retries.\n      this.authState.state === \"waitingForServerConfirmationOfFreshToken\" && this.tokenConfirmationAttempts >= MAX_TOKEN_CONFIRMATION_ATTEMPTS\n    ) {\n      this.logger.error(\n        `Failed to authenticate: \"${serverMessage.error}\", check your server auth config`\n      );\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      if (this.authState.state !== \"noAuth\") {\n        this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n      }\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this.tokenConfirmationAttempts++;\n      this._logVerbose(\n        `retrying reauthentication, ${MAX_TOKEN_CONFIRMATION_ATTEMPTS - this.tokenConfirmationAttempts} attempts remaining`\n      );\n    }\n    await this.stopSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true\n      }\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value && this.syncState.isNewAuth(token.value)) {\n      this.authenticate(token.value);\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfFreshToken\",\n        config: this.authState.config,\n        token: token.value,\n        hadAuth: this.authState.state === \"notRefetching\" || this.authState.state === \"waitingForScheduledRefetch\"\n      });\n    } else {\n      this._logVerbose(\"reauthentication failed, could not fetch a new token\");\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    this.tryRestartSocket();\n  }\n  // Force refetch the token and schedule another refetch\n  // before the token expires - an active client should never\n  // need to reauthenticate.\n  async refetchToken() {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    this._logVerbose(\"refetching auth token\");\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true\n      }\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      if (this.syncState.isNewAuth(token.value)) {\n        this.setAuthState({\n          state: \"waitingForServerConfirmationOfFreshToken\",\n          hadAuth: this.syncState.hasAuth(),\n          token: token.value,\n          config: this.authState.config\n        });\n        this.authenticate(token.value);\n      } else {\n        this.setAuthState({\n          state: \"notRefetching\",\n          config: this.authState.config\n        });\n      }\n    } else {\n      this._logVerbose(\"refetching token failed\");\n      if (this.syncState.hasAuth()) {\n        this.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    this._logVerbose(\n      \"restarting WS after auth token fetch (if currently stopped)\"\n    );\n    this.tryRestartSocket();\n  }\n  scheduleTokenRefetch(token) {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    const decodedToken = this.decodeToken(token);\n    if (!decodedToken) {\n      this.logger.error(\n        \"Auth token is not a valid JWT, cannot refetch the token\"\n      );\n      return;\n    }\n    const { iat, exp } = decodedToken;\n    if (!iat || !exp) {\n      this.logger.error(\n        \"Auth token does not have required fields, cannot refetch the token\"\n      );\n      return;\n    }\n    const tokenValiditySeconds = exp - iat;\n    if (tokenValiditySeconds <= 2) {\n      this.logger.error(\n        \"Auth token does not live long enough, cannot refetch the token\"\n      );\n      return;\n    }\n    let delay = Math.min(\n      MAXIMUM_REFRESH_DELAY,\n      (tokenValiditySeconds - this.refreshTokenLeewaySeconds) * 1e3\n    );\n    if (delay <= 0) {\n      this.logger.warn(\n        `Refetching auth token immediately, configured leeway ${this.refreshTokenLeewaySeconds}s is larger than the token's lifetime ${tokenValiditySeconds}s`\n      );\n      delay = 0;\n    }\n    const refetchTokenTimeoutId = setTimeout(() => {\n      this._logVerbose(\"running scheduled token refetch\");\n      void this.refetchToken();\n    }, delay);\n    this.setAuthState({\n      state: \"waitingForScheduledRefetch\",\n      refetchTokenTimeoutId,\n      config: this.authState.config\n    });\n    this._logVerbose(\n      `scheduled preemptive auth token refetching in ${delay}ms`\n    );\n  }\n  // Protects against simultaneous calls to `setConfig`\n  // while we're fetching a token\n  async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {\n    const originalConfigVersion = ++this.configVersion;\n    this._logVerbose(\n      `fetching token with config version ${originalConfigVersion}`\n    );\n    const token = await fetchToken(fetchArgs);\n    if (this.configVersion !== originalConfigVersion) {\n      this._logVerbose(\n        `stale config version, expected ${originalConfigVersion}, got ${this.configVersion}`\n      );\n      return { isFromOutdatedConfig: true };\n    }\n    return { isFromOutdatedConfig: false, value: token };\n  }\n  stop() {\n    this.resetAuthState();\n    this.configVersion++;\n    this._logVerbose(`config version bumped to ${this.configVersion}`);\n  }\n  setAndReportAuthFailed(onAuthChange) {\n    onAuthChange(false);\n    this.resetAuthState();\n  }\n  resetAuthState() {\n    this.setAuthState({ state: \"noAuth\" });\n  }\n  setAuthState(newAuth) {\n    const authStateForLog = newAuth.state === \"waitingForServerConfirmationOfFreshToken\" ? {\n      hadAuth: newAuth.hadAuth,\n      state: newAuth.state,\n      token: `...${newAuth.token.slice(-7)}`\n    } : { state: newAuth.state };\n    this._logVerbose(\n      `setting auth state to ${JSON.stringify(authStateForLog)}`\n    );\n    switch (newAuth.state) {\n      case \"waitingForScheduledRefetch\":\n      case \"notRefetching\":\n      case \"noAuth\":\n        this.tokenConfirmationAttempts = 0;\n        break;\n      case \"waitingForServerConfirmationOfFreshToken\":\n      case \"waitingForServerConfirmationOfCachedToken\":\n      case \"initialRefetch\":\n        break;\n      default: {\n        newAuth;\n      }\n    }\n    if (this.authState.state === \"waitingForScheduledRefetch\") {\n      clearTimeout(this.authState.refetchTokenTimeoutId);\n      this.syncState.markAuthCompletion();\n    }\n    this.authState = newAuth;\n  }\n  decodeToken(token) {\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      this._logVerbose(\n        `Error decoding token: ${e instanceof Error ? e.message : \"Unknown error\"}`\n      );\n      return null;\n    }\n  }\n  _logVerbose(message) {\n    this.logger.logVerbose(`${message} [v${this.configVersion}]`);\n  }\n}\n//# sourceMappingURL=authentication_manager.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { version } from \"../../index.js\";\nimport { convexToJson } from \"../../values/index.js\";\nimport {\n  createHybridErrorStacktrace,\n  forwardData,\n  instantiateDefaultLogger,\n  instantiateNoopLogger,\n  logFatalError\n} from \"../logging.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { RequestManager } from \"./request_manager.js\";\nimport {\n  OptimisticQueryResults\n} from \"./optimistic_updates_impl.js\";\nimport { RemoteQuerySet } from \"./remote_query_set.js\";\nimport { serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { WebSocketManager } from \"./web_socket_manager.js\";\nimport { newSessionId } from \"./session.js\";\nimport {\n  AuthenticationManager\n} from \"./authentication_manager.js\";\nimport { getMarksReport, mark } from \"./metrics.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../../common/index.js\";\nimport { ConvexError } from \"../../values/errors.js\";\nimport { jwtDecode } from \"../../vendor/jwt-decode/index.js\";\nexport class BaseConvexClient {\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed -- additional handlers\n   * can be added via `addOnTransitionHandler`.\n   * @param options - See {@link BaseConvexClientOptions} for a full description.\n   */\n  constructor(address, onTransition, options) {\n    __publicField(this, \"address\");\n    __publicField(this, \"state\");\n    __publicField(this, \"requestManager\");\n    __publicField(this, \"webSocketManager\");\n    __publicField(this, \"authenticationManager\");\n    __publicField(this, \"remoteQuerySet\");\n    __publicField(this, \"optimisticQueryResults\");\n    __publicField(this, \"_transitionHandlerCounter\", 0);\n    __publicField(this, \"_nextRequestId\");\n    __publicField(this, \"_onTransitionFns\", /* @__PURE__ */ new Map());\n    __publicField(this, \"_sessionId\");\n    __publicField(this, \"firstMessageReceived\", false);\n    __publicField(this, \"debug\");\n    __publicField(this, \"logger\");\n    __publicField(this, \"maxObservedTimestamp\");\n    __publicField(this, \"connectionStateSubscribers\", /* @__PURE__ */ new Map());\n    __publicField(this, \"nextConnectionStateSubscriberId\", 0);\n    __publicField(this, \"_lastPublishedConnectionState\");\n    /**\n     * Call this whenever the connection state may have changed in a way that could\n     * require publishing it. Schedules a possibly update.\n     */\n    __publicField(this, \"markConnectionStateDirty\", () => {\n      void Promise.resolve().then(() => {\n        const curConnectionState = this.connectionState();\n        if (JSON.stringify(curConnectionState) !== JSON.stringify(this._lastPublishedConnectionState)) {\n          this._lastPublishedConnectionState = curConnectionState;\n          for (const cb of this.connectionStateSubscribers.values()) {\n            cb(curConnectionState);\n          }\n        }\n      });\n    });\n    // Instance property so that `mark()` doesn't need to be called as a method.\n    __publicField(this, \"mark\", (name) => {\n      if (this.debug) {\n        mark(name, this.sessionId);\n      }\n    });\n    if (typeof address === \"object\") {\n      throw new Error(\n        \"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\"\n      );\n    }\n    if (options?.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    options = { ...options };\n    const authRefreshTokenLeewaySeconds = options.authRefreshTokenLeewaySeconds ?? 2;\n    let webSocketConstructor = options.webSocketConstructor;\n    if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n      throw new Error(\n        \"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\"\n      );\n    }\n    webSocketConstructor = webSocketConstructor || WebSocket;\n    this.debug = options.reportDebugInfoToConvex ?? false;\n    this.address = address;\n    this.logger = options.logger === false ? instantiateNoopLogger({ verbose: options.verbose ?? false }) : options.logger !== true && options.logger ? options.logger : instantiateDefaultLogger({ verbose: options.verbose ?? false });\n    const i = address.search(\"://\");\n    if (i === -1) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    const origin = address.substring(i + 3);\n    const protocol = address.substring(0, i);\n    let wsProtocol;\n    if (protocol === \"http\") {\n      wsProtocol = \"ws\";\n    } else if (protocol === \"https\") {\n      wsProtocol = \"wss\";\n    } else {\n      throw new Error(`Unknown parent protocol ${protocol}`);\n    }\n    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;\n    this.state = new LocalSyncState();\n    this.remoteQuerySet = new RemoteQuerySet(\n      (queryId) => this.state.queryPath(queryId),\n      this.logger\n    );\n    this.requestManager = new RequestManager(\n      this.logger,\n      this.markConnectionStateDirty\n    );\n    const pauseSocket = () => {\n      this.webSocketManager.pause();\n      this.state.pause();\n    };\n    this.authenticationManager = new AuthenticationManager(\n      this.state,\n      {\n        authenticate: (token) => {\n          const message = this.state.setAuth(token);\n          this.webSocketManager.sendMessage(message);\n          return message.baseVersion;\n        },\n        stopSocket: () => this.webSocketManager.stop(),\n        tryRestartSocket: () => this.webSocketManager.tryRestart(),\n        pauseSocket,\n        resumeSocket: () => this.webSocketManager.resume(),\n        clearAuth: () => {\n          this.clearAuth();\n        }\n      },\n      {\n        logger: this.logger,\n        refreshTokenLeewaySeconds: authRefreshTokenLeewaySeconds\n      }\n    );\n    this.optimisticQueryResults = new OptimisticQueryResults();\n    this.addOnTransitionHandler((transition) => {\n      onTransition(transition.queries.map((q) => q.token));\n    });\n    this._nextRequestId = 0;\n    this._sessionId = newSessionId();\n    const { unsavedChangesWarning } = options;\n    if (typeof window === \"undefined\" || typeof window.addEventListener === \"undefined\") {\n      if (unsavedChangesWarning === true) {\n        throw new Error(\n          \"unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.\"\n        );\n      }\n    } else if (unsavedChangesWarning !== false) {\n      window.addEventListener(\"beforeunload\", (e) => {\n        if (this.requestManager.hasIncompleteRequests()) {\n          e.preventDefault();\n          const confirmationMessage = \"Are you sure you want to leave? Your changes may not be saved.\";\n          (e || window.event).returnValue = confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n    }\n    this.webSocketManager = new WebSocketManager(\n      wsUri,\n      {\n        onOpen: (reconnectMetadata) => {\n          this.mark(\"convexWebSocketOpen\");\n          this.webSocketManager.sendMessage({\n            ...reconnectMetadata,\n            type: \"Connect\",\n            sessionId: this._sessionId,\n            maxObservedTimestamp: this.maxObservedTimestamp\n          });\n          const oldRemoteQueryResults = new Set(\n            this.remoteQuerySet.remoteQueryResults().keys()\n          );\n          this.remoteQuerySet = new RemoteQuerySet(\n            (queryId) => this.state.queryPath(queryId),\n            this.logger\n          );\n          const [querySetModification, authModification] = this.state.restart(\n            oldRemoteQueryResults\n          );\n          if (authModification) {\n            this.webSocketManager.sendMessage(authModification);\n          }\n          this.webSocketManager.sendMessage(querySetModification);\n          for (const message of this.requestManager.restart()) {\n            this.webSocketManager.sendMessage(message);\n          }\n        },\n        onResume: () => {\n          const [querySetModification, authModification] = this.state.resume();\n          if (authModification) {\n            this.webSocketManager.sendMessage(authModification);\n          }\n          if (querySetModification) {\n            this.webSocketManager.sendMessage(querySetModification);\n          }\n          for (const message of this.requestManager.resume()) {\n            this.webSocketManager.sendMessage(message);\n          }\n        },\n        onMessage: (serverMessage) => {\n          if (!this.firstMessageReceived) {\n            this.firstMessageReceived = true;\n            this.mark(\"convexFirstMessageReceived\");\n            this.reportMarks();\n          }\n          switch (serverMessage.type) {\n            case \"Transition\": {\n              this.observedTimestamp(serverMessage.endVersion.ts);\n              this.authenticationManager.onTransition(serverMessage);\n              this.remoteQuerySet.transition(serverMessage);\n              this.state.transition(serverMessage);\n              const completedRequests = this.requestManager.removeCompleted(\n                this.remoteQuerySet.timestamp()\n              );\n              this.notifyOnQueryResultChanges(completedRequests);\n              break;\n            }\n            case \"MutationResponse\": {\n              if (serverMessage.success) {\n                this.observedTimestamp(serverMessage.ts);\n              }\n              const completedMutationInfo = this.requestManager.onResponse(serverMessage);\n              if (completedMutationInfo !== null) {\n                this.notifyOnQueryResultChanges(\n                  /* @__PURE__ */ new Map([\n                    [\n                      completedMutationInfo.requestId,\n                      completedMutationInfo.result\n                    ]\n                  ])\n                );\n              }\n              break;\n            }\n            case \"ActionResponse\": {\n              this.requestManager.onResponse(serverMessage);\n              break;\n            }\n            case \"AuthError\": {\n              this.authenticationManager.onAuthError(serverMessage);\n              break;\n            }\n            case \"FatalError\": {\n              const error = logFatalError(this.logger, serverMessage.error);\n              void this.webSocketManager.terminate();\n              throw error;\n            }\n            default: {\n              serverMessage;\n            }\n          }\n          return {\n            hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect()\n          };\n        },\n        onServerDisconnectError: options.onServerDisconnectError\n      },\n      webSocketConstructor,\n      this.logger,\n      this.markConnectionStateDirty,\n      this.debug\n    );\n    this.mark(\"convexClientConstructed\");\n    if (options.expectAuth) {\n      pauseSocket();\n    }\n  }\n  /**\n   * Return true if there is outstanding work from prior to the time of the most recent restart.\n   * This indicates that the client has not proven itself to have gotten past the issue that\n   * potentially led to the restart. Use this to influence when to reset backoff after a failure.\n   */\n  hasSyncedPastLastReconnect() {\n    const hasSyncedPastLastReconnect = this.requestManager.hasSyncedPastLastReconnect() || this.state.hasSyncedPastLastReconnect();\n    return hasSyncedPastLastReconnect;\n  }\n  observedTimestamp(observedTs) {\n    if (this.maxObservedTimestamp === void 0 || this.maxObservedTimestamp.lessThanOrEqual(observedTs)) {\n      this.maxObservedTimestamp = observedTs;\n    }\n  }\n  getMaxObservedTimestamp() {\n    return this.maxObservedTimestamp;\n  }\n  /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */\n  notifyOnQueryResultChanges(completedRequests) {\n    const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();\n    const queryTokenToValue = /* @__PURE__ */ new Map();\n    for (const [queryId, result] of remoteQueryResults) {\n      const queryToken = this.state.queryToken(queryId);\n      if (queryToken !== null) {\n        const query = {\n          result,\n          udfPath: this.state.queryPath(queryId),\n          args: this.state.queryArgs(queryId)\n        };\n        queryTokenToValue.set(queryToken, query);\n      }\n    }\n    const changedQueryTokens = this.optimisticQueryResults.ingestQueryResultsFromServer(\n      queryTokenToValue,\n      new Set(completedRequests.keys())\n    );\n    this.handleTransition({\n      queries: changedQueryTokens.map((token) => {\n        const optimisticResult = this.optimisticQueryResults.rawQueryResult(token);\n        return {\n          token,\n          modification: {\n            kind: \"Updated\",\n            result: optimisticResult\n          }\n        };\n      }),\n      reflectedMutations: Array.from(completedRequests).map(\n        ([requestId, result]) => ({\n          requestId,\n          result\n        })\n      ),\n      timestamp: this.remoteQuerySet.timestamp()\n    });\n  }\n  handleTransition(transition) {\n    for (const fn of this._onTransitionFns.values()) {\n      fn(transition);\n    }\n  }\n  /**\n   * Add a handler that will be called on a transition.\n   *\n   * Any external side effects (e.g. setting React state) should be handled here.\n   *\n   * @param fn\n   *\n   * @returns\n   */\n  addOnTransitionHandler(fn) {\n    const id = this._transitionHandlerCounter++;\n    this._onTransitionFns.set(id, fn);\n    return () => this._onTransitionFns.delete(id);\n  }\n  /**\n   * Get the current JWT auth token and decoded claims.\n   */\n  getCurrentAuthClaims() {\n    const authToken = this.state.getAuth();\n    let decoded = {};\n    if (authToken && authToken.tokenType === \"User\") {\n      try {\n        decoded = authToken ? jwtDecode(authToken.value) : {};\n      } catch {\n        decoded = {};\n      }\n    } else {\n      return void 0;\n    }\n    return { token: authToken.value, decoded };\n  }\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(fetchToken, onChange) {\n    void this.authenticationManager.setConfig(fetchToken, onChange);\n  }\n  hasAuth() {\n    return this.state.hasAuth();\n  }\n  /** @internal */\n  setAdminAuth(value, fakeUserIdentity) {\n    const message = this.state.setAdminAuth(value, fakeUserIdentity);\n    this.webSocketManager.sendMessage(message);\n  }\n  clearAuth() {\n    const message = this.state.clearAuth();\n    this.webSocketManager.sendMessage(message);\n  }\n  /**\n     * Subscribe to a query function.\n     *\n     * Whenever this query's result changes, the `onTransition` callback\n     * passed into the constructor will be called.\n     *\n     * @param name - The name of the query.\n     * @param args - An arguments object for the query. If this is omitted, the\n     * arguments will be `{}`.\n     * @param options - A {@link SubscribeOptions} options object for this query.\n  \n     * @returns An object containing a {@link QueryToken} corresponding to this\n     * query and an `unsubscribe` callback.\n     */\n  subscribe(name, args, options) {\n    const argsObject = parseArgs(args);\n    const { modification, queryToken, unsubscribe } = this.state.subscribe(\n      name,\n      argsObject,\n      options?.journal,\n      options?.componentPath\n    );\n    if (modification !== null) {\n      this.webSocketManager.sendMessage(modification);\n    }\n    return {\n      queryToken,\n      unsubscribe: () => {\n        const modification2 = unsubscribe();\n        if (modification2) {\n          this.webSocketManager.sendMessage(modification2);\n        }\n      }\n    };\n  }\n  /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */\n  localQueryResult(udfPath, args) {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n  /**\n   * Get query result by query token based on current, local state\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   *\n   * @internal\n   */\n  localQueryResultByToken(queryToken) {\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n  /**\n   * Whether local query result is available for a token.\n   *\n   * This method does not throw if the result is an error.\n   *\n   * @internal\n   */\n  hasLocalQueryResultByToken(queryToken) {\n    return this.optimisticQueryResults.hasQueryResult(queryToken);\n  }\n  /**\n   * @internal\n   */\n  localQueryLogs(udfPath, args) {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryLogs(queryToken);\n  }\n  /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */\n  queryJournal(name, args) {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(name, argsObject);\n    return this.state.queryJournal(queryToken);\n  }\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState() {\n    const wsConnectionState = this.webSocketManager.connectionState();\n    return {\n      hasInflightRequests: this.requestManager.hasInflightRequests(),\n      isWebSocketConnected: wsConnectionState.isConnected,\n      hasEverConnected: wsConnectionState.hasEverConnected,\n      connectionCount: wsConnectionState.connectionCount,\n      connectionRetries: wsConnectionState.connectionRetries,\n      timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest(),\n      inflightMutations: this.requestManager.inflightMutations(),\n      inflightActions: this.requestManager.inflightActions()\n    };\n  }\n  /**\n   * Subscribe to the {@link ConnectionState} between the client and the Convex\n   * backend, calling a callback each time it changes.\n   *\n   * Subscribed callbacks will be called when any part of ConnectionState changes.\n   * ConnectionState may grow in future versions (e.g. to provide a array of\n   * inflight requests) in which case callbacks would be called more frequently.\n   *\n   * @returns An unsubscribe function to stop listening.\n   */\n  subscribeToConnectionState(cb) {\n    const id = this.nextConnectionStateSubscriberId++;\n    this.connectionStateSubscribers.set(id, cb);\n    return () => {\n      this.connectionStateSubscribers.delete(id);\n    };\n  }\n  /**\n     * Execute a mutation function.\n     *\n     * @param name - The name of the mutation.\n     * @param args - An arguments object for the mutation. If this is omitted,\n     * the arguments will be `{}`.\n     * @param options - A {@link MutationOptions} options object for this mutation.\n  \n     * @returns - A promise of the mutation's result.\n     */\n  async mutation(name, args, options) {\n    const result = await this.mutationInternal(name, args, options);\n    if (!result.success) {\n      if (result.errorData !== void 0) {\n        throw forwardData(\n          result,\n          new ConvexError(\n            createHybridErrorStacktrace(\"mutation\", name, result)\n          )\n        );\n      }\n      throw new Error(createHybridErrorStacktrace(\"mutation\", name, result));\n    }\n    return result.value;\n  }\n  /**\n   * @internal\n   */\n  async mutationInternal(udfPath, args, options, componentPath) {\n    const { mutationPromise } = this.enqueueMutation(\n      udfPath,\n      args,\n      options,\n      componentPath\n    );\n    return mutationPromise;\n  }\n  /**\n   * @internal\n   */\n  enqueueMutation(udfPath, args, options, componentPath) {\n    const mutationArgs = parseArgs(args);\n    this.tryReportLongDisconnect();\n    const requestId = this.nextRequestId;\n    this._nextRequestId++;\n    if (options !== void 0) {\n      const optimisticUpdate = options.optimisticUpdate;\n      if (optimisticUpdate !== void 0) {\n        const wrappedUpdate = (localQueryStore) => {\n          const result = optimisticUpdate(\n            localQueryStore,\n            mutationArgs\n          );\n          if (result instanceof Promise) {\n            this.logger.warn(\n              \"Optimistic update handler returned a Promise. Optimistic updates should be synchronous.\"\n            );\n          }\n        };\n        const changedQueryTokens = this.optimisticQueryResults.applyOptimisticUpdate(\n          wrappedUpdate,\n          requestId\n        );\n        const changedQueries = changedQueryTokens.map((token) => {\n          const localResult = this.localQueryResultByToken(token);\n          return {\n            token,\n            modification: {\n              kind: \"Updated\",\n              result: localResult === void 0 ? void 0 : {\n                success: true,\n                value: localResult,\n                logLines: []\n              }\n            }\n          };\n        });\n        this.handleTransition({\n          queries: changedQueries,\n          reflectedMutations: [],\n          timestamp: this.remoteQuerySet.timestamp()\n        });\n      }\n    }\n    const message = {\n      type: \"Mutation\",\n      requestId,\n      udfPath,\n      componentPath,\n      args: [convexToJson(mutationArgs)]\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    const mutationPromise = this.requestManager.request(message, mightBeSent);\n    return {\n      requestId,\n      mutationPromise\n    };\n  }\n  /**\n   * Execute an action function.\n   *\n   * @param name - The name of the action.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action(name, args) {\n    const result = await this.actionInternal(name, args);\n    if (!result.success) {\n      if (result.errorData !== void 0) {\n        throw forwardData(\n          result,\n          new ConvexError(createHybridErrorStacktrace(\"action\", name, result))\n        );\n      }\n      throw new Error(createHybridErrorStacktrace(\"action\", name, result));\n    }\n    return result.value;\n  }\n  /**\n   * @internal\n   */\n  async actionInternal(udfPath, args, componentPath) {\n    const actionArgs = parseArgs(args);\n    const requestId = this.nextRequestId;\n    this._nextRequestId++;\n    this.tryReportLongDisconnect();\n    const message = {\n      type: \"Action\",\n      requestId,\n      udfPath,\n      componentPath,\n      args: [convexToJson(actionArgs)]\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with an {@link BaseConvexClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close() {\n    this.authenticationManager.stop();\n    return this.webSocketManager.terminate();\n  }\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n  /**\n   * @internal\n   */\n  get nextRequestId() {\n    return this._nextRequestId;\n  }\n  /**\n   * @internal\n   */\n  get sessionId() {\n    return this._sessionId;\n  }\n  /**\n   * Reports performance marks to the server. This should only be called when\n   * we have a functional websocket.\n   */\n  reportMarks() {\n    if (this.debug) {\n      const report = getMarksReport(this.sessionId);\n      this.webSocketManager.sendMessage({\n        type: \"Event\",\n        eventType: \"ClientConnect\",\n        event: report\n      });\n    }\n  }\n  tryReportLongDisconnect() {\n    if (!this.debug) {\n      return;\n    }\n    const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;\n    if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {\n      return;\n    }\n    const endpoint = `${this.address}/api/debug_event`;\n    fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`\n      },\n      body: JSON.stringify({ event: \"LongWebsocketDisconnect\" })\n    }).then((response) => {\n      if (!response.ok) {\n        this.logger.warn(\n          \"Analytics request failed with response:\",\n          response.body\n        );\n      }\n    }).catch((error) => {\n      this.logger.warn(\"Analytics response failed with error:\", error);\n    });\n  }\n}\n//# sourceMappingURL=client.js.map\n","import {createRequire} from 'module';import {resolve as nodePathResolve} from 'path';const require=createRequire(nodePathResolve('.'));\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/stream.js\nvar require_stream = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/stream.js\"(exports, module) {\n    \"use strict\";\n    var { Duplex } = __require(\"stream\");\n    function emitClose(stream) {\n      stream.emit(\"close\");\n    }\n    function duplexOnEnd() {\n      if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n      }\n    }\n    function duplexOnError(err) {\n      this.removeListener(\"error\", duplexOnError);\n      this.destroy();\n      if (this.listenerCount(\"error\") === 0) {\n        this.emit(\"error\", err);\n      }\n    }\n    function createWebSocketStream2(ws, options) {\n      let terminateOnDestroy = true;\n      const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n      });\n      ws.on(\"message\", function message(msg, isBinary) {\n        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n        if (!duplex.push(data)) ws.pause();\n      });\n      ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n      });\n      ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n      });\n      duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n          callback(err);\n          process.nextTick(emitClose, duplex);\n          return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err2) {\n          called = true;\n          callback(err2);\n        });\n        ws.once(\"close\", function close() {\n          if (!called) callback(err);\n          process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n      };\n      duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n          ws.once(\"open\", function open() {\n            duplex._final(callback);\n          });\n          return;\n        }\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n          callback();\n          if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n          ws._socket.once(\"finish\", function finish() {\n            callback();\n          });\n          ws.close();\n        }\n      };\n      duplex._read = function() {\n        if (ws.isPaused) ws.resume();\n      };\n      duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n          ws.once(\"open\", function open() {\n            duplex._write(chunk, encoding, callback);\n          });\n          return;\n        }\n        ws.send(chunk, callback);\n      };\n      duplex.on(\"end\", duplexOnEnd);\n      duplex.on(\"error\", duplexOnError);\n      return duplex;\n    }\n    module.exports = createWebSocketStream2;\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/constants.js\nvar require_constants = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/constants.js\"(exports, module) {\n    \"use strict\";\n    var BINARY_TYPES = [\"nodebuffer\", \"arraybuffer\", \"fragments\"];\n    var hasBlob = typeof Blob !== \"undefined\";\n    if (hasBlob) BINARY_TYPES.push(\"blob\");\n    module.exports = {\n      BINARY_TYPES,\n      EMPTY_BUFFER: Buffer.alloc(0),\n      GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n      hasBlob,\n      kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n      kListener: Symbol(\"kListener\"),\n      kStatusCode: Symbol(\"status-code\"),\n      kWebSocket: Symbol(\"websocket\"),\n      NOOP: () => {\n      }\n    };\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/node-gyp-build.js\nvar require_node_gyp_build = __commonJS({\n  \"../common/temp/node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/node-gyp-build.js\"(exports, module) {\n    var fs = __require(\"fs\");\n    var path = __require(\"path\");\n    var os = __require(\"os\");\n    var runtimeRequire = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : __require;\n    var vars = process.config && process.config.variables || {};\n    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;\n    var abi = process.versions.modules;\n    var runtime = isElectron() ? \"electron\" : isNwjs() ? \"node-webkit\" : \"node\";\n    var arch = process.env.npm_config_arch || os.arch();\n    var platform = process.env.npm_config_platform || os.platform();\n    var libc = process.env.LIBC || (isAlpine(platform) ? \"musl\" : \"glibc\");\n    var armv = process.env.ARM_VERSION || (arch === \"arm64\" ? \"8\" : vars.arm_version) || \"\";\n    var uv = (process.versions.uv || \"\").split(\".\")[0];\n    module.exports = load;\n    function load(dir) {\n      return runtimeRequire(load.resolve(dir));\n    }\n    load.resolve = load.path = function(dir) {\n      dir = path.resolve(dir || \".\");\n      try {\n        var name = runtimeRequire(path.join(dir, \"package.json\")).name.toUpperCase().replace(/-/g, \"_\");\n        if (process.env[name + \"_PREBUILD\"]) dir = process.env[name + \"_PREBUILD\"];\n      } catch (err) {\n      }\n      if (!prebuildsOnly) {\n        var release = getFirst(path.join(dir, \"build/Release\"), matchBuild);\n        if (release) return release;\n        var debug = getFirst(path.join(dir, \"build/Debug\"), matchBuild);\n        if (debug) return debug;\n      }\n      var prebuild = resolve(dir);\n      if (prebuild) return prebuild;\n      var nearby = resolve(path.dirname(process.execPath));\n      if (nearby) return nearby;\n      var target = [\n        \"platform=\" + platform,\n        \"arch=\" + arch,\n        \"runtime=\" + runtime,\n        \"abi=\" + abi,\n        \"uv=\" + uv,\n        armv ? \"armv=\" + armv : \"\",\n        \"libc=\" + libc,\n        \"node=\" + process.versions.node,\n        process.versions.electron ? \"electron=\" + process.versions.electron : \"\",\n        typeof __webpack_require__ === \"function\" ? \"webpack=true\" : \"\"\n        // eslint-disable-line\n      ].filter(Boolean).join(\" \");\n      throw new Error(\"No native build was found for \" + target + \"\\n    loaded from: \" + dir + \"\\n\");\n      function resolve(dir2) {\n        var tuples = readdirSync(path.join(dir2, \"prebuilds\")).map(parseTuple);\n        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];\n        if (!tuple) return;\n        var prebuilds = path.join(dir2, \"prebuilds\", tuple.name);\n        var parsed = readdirSync(prebuilds).map(parseTags);\n        var candidates = parsed.filter(matchTags(runtime, abi));\n        var winner = candidates.sort(compareTags(runtime))[0];\n        if (winner) return path.join(prebuilds, winner.file);\n      }\n    };\n    function readdirSync(dir) {\n      try {\n        return fs.readdirSync(dir);\n      } catch (err) {\n        return [];\n      }\n    }\n    function getFirst(dir, filter) {\n      var files = readdirSync(dir).filter(filter);\n      return files[0] && path.join(dir, files[0]);\n    }\n    function matchBuild(name) {\n      return /\\.node$/.test(name);\n    }\n    function parseTuple(name) {\n      var arr = name.split(\"-\");\n      if (arr.length !== 2) return;\n      var platform2 = arr[0];\n      var architectures = arr[1].split(\"+\");\n      if (!platform2) return;\n      if (!architectures.length) return;\n      if (!architectures.every(Boolean)) return;\n      return { name, platform: platform2, architectures };\n    }\n    function matchTuple(platform2, arch2) {\n      return function(tuple) {\n        if (tuple == null) return false;\n        if (tuple.platform !== platform2) return false;\n        return tuple.architectures.includes(arch2);\n      };\n    }\n    function compareTuples(a, b) {\n      return a.architectures.length - b.architectures.length;\n    }\n    function parseTags(file) {\n      var arr = file.split(\".\");\n      var extension = arr.pop();\n      var tags = { file, specificity: 0 };\n      if (extension !== \"node\") return;\n      for (var i = 0; i < arr.length; i++) {\n        var tag = arr[i];\n        if (tag === \"node\" || tag === \"electron\" || tag === \"node-webkit\") {\n          tags.runtime = tag;\n        } else if (tag === \"napi\") {\n          tags.napi = true;\n        } else if (tag.slice(0, 3) === \"abi\") {\n          tags.abi = tag.slice(3);\n        } else if (tag.slice(0, 2) === \"uv\") {\n          tags.uv = tag.slice(2);\n        } else if (tag.slice(0, 4) === \"armv\") {\n          tags.armv = tag.slice(4);\n        } else if (tag === \"glibc\" || tag === \"musl\") {\n          tags.libc = tag;\n        } else {\n          continue;\n        }\n        tags.specificity++;\n      }\n      return tags;\n    }\n    function matchTags(runtime2, abi2) {\n      return function(tags) {\n        if (tags == null) return false;\n        if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;\n        if (tags.abi && tags.abi !== abi2 && !tags.napi) return false;\n        if (tags.uv && tags.uv !== uv) return false;\n        if (tags.armv && tags.armv !== armv) return false;\n        if (tags.libc && tags.libc !== libc) return false;\n        return true;\n      };\n    }\n    function runtimeAgnostic(tags) {\n      return tags.runtime === \"node\" && tags.napi;\n    }\n    function compareTags(runtime2) {\n      return function(a, b) {\n        if (a.runtime !== b.runtime) {\n          return a.runtime === runtime2 ? -1 : 1;\n        } else if (a.abi !== b.abi) {\n          return a.abi ? -1 : 1;\n        } else if (a.specificity !== b.specificity) {\n          return a.specificity > b.specificity ? -1 : 1;\n        } else {\n          return 0;\n        }\n      };\n    }\n    function isNwjs() {\n      return !!(process.versions && process.versions.nw);\n    }\n    function isElectron() {\n      if (process.versions && process.versions.electron) return true;\n      if (process.env.ELECTRON_RUN_AS_NODE) return true;\n      return typeof window !== \"undefined\" && window.process && window.process.type === \"renderer\";\n    }\n    function isAlpine(platform2) {\n      return platform2 === \"linux\" && fs.existsSync(\"/etc/alpine-release\");\n    }\n    load.parseTags = parseTags;\n    load.matchTags = matchTags;\n    load.compareTags = compareTags;\n    load.parseTuple = parseTuple;\n    load.matchTuple = matchTuple;\n    load.compareTuples = compareTuples;\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/index.js\nvar require_node_gyp_build2 = __commonJS({\n  \"../common/temp/node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/index.js\"(exports, module) {\n    var runtimeRequire = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : __require;\n    if (typeof runtimeRequire.addon === \"function\") {\n      module.exports = runtimeRequire.addon.bind(runtimeRequire);\n    } else {\n      module.exports = require_node_gyp_build();\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/bufferutil@4.0.9/node_modules/bufferutil/fallback.js\nvar require_fallback = __commonJS({\n  \"../common/temp/node_modules/.pnpm/bufferutil@4.0.9/node_modules/bufferutil/fallback.js\"(exports, module) {\n    \"use strict\";\n    var mask = (source, mask2, output, offset, length) => {\n      for (var i = 0; i < length; i++) {\n        output[offset + i] = source[i] ^ mask2[i & 3];\n      }\n    };\n    var unmask = (buffer, mask2) => {\n      const length = buffer.length;\n      for (var i = 0; i < length; i++) {\n        buffer[i] ^= mask2[i & 3];\n      }\n    };\n    module.exports = { mask, unmask };\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/bufferutil@4.0.9/node_modules/bufferutil/index.js\nvar require_bufferutil = __commonJS({\n  \"../common/temp/node_modules/.pnpm/bufferutil@4.0.9/node_modules/bufferutil/index.js\"(exports, module) {\n    \"use strict\";\n    try {\n      module.exports = require_node_gyp_build2()(__dirname);\n    } catch (e) {\n      module.exports = require_fallback();\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/buffer-util.js\nvar require_buffer_util = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/buffer-util.js\"(exports, module) {\n    \"use strict\";\n    var { EMPTY_BUFFER } = require_constants();\n    var FastBuffer = Buffer[Symbol.species];\n    function concat(list, totalLength) {\n      if (list.length === 0) return EMPTY_BUFFER;\n      if (list.length === 1) return list[0];\n      const target = Buffer.allocUnsafe(totalLength);\n      let offset = 0;\n      for (let i = 0; i < list.length; i++) {\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n      }\n      if (offset < totalLength) {\n        return new FastBuffer(target.buffer, target.byteOffset, offset);\n      }\n      return target;\n    }\n    function _mask(source, mask, output, offset, length) {\n      for (let i = 0; i < length; i++) {\n        output[offset + i] = source[i] ^ mask[i & 3];\n      }\n    }\n    function _unmask(buffer, mask) {\n      for (let i = 0; i < buffer.length; i++) {\n        buffer[i] ^= mask[i & 3];\n      }\n    }\n    function toArrayBuffer(buf) {\n      if (buf.length === buf.buffer.byteLength) {\n        return buf.buffer;\n      }\n      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n    }\n    function toBuffer(data) {\n      toBuffer.readOnly = true;\n      if (Buffer.isBuffer(data)) return data;\n      let buf;\n      if (data instanceof ArrayBuffer) {\n        buf = new FastBuffer(data);\n      } else if (ArrayBuffer.isView(data)) {\n        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n      } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n      }\n      return buf;\n    }\n    module.exports = {\n      concat,\n      mask: _mask,\n      toArrayBuffer,\n      toBuffer,\n      unmask: _unmask\n    };\n    if (!process.env.WS_NO_BUFFER_UTIL) {\n      try {\n        const bufferUtil = require_bufferutil();\n        module.exports.mask = function(source, mask, output, offset, length) {\n          if (length < 48) _mask(source, mask, output, offset, length);\n          else bufferUtil.mask(source, mask, output, offset, length);\n        };\n        module.exports.unmask = function(buffer, mask) {\n          if (buffer.length < 32) _unmask(buffer, mask);\n          else bufferUtil.unmask(buffer, mask);\n        };\n      } catch (e) {\n      }\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/limiter.js\nvar require_limiter = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/limiter.js\"(exports, module) {\n    \"use strict\";\n    var kDone = Symbol(\"kDone\");\n    var kRun = Symbol(\"kRun\");\n    var Limiter = class {\n      /**\n       * Creates a new `Limiter`.\n       *\n       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n       *     to run concurrently\n       */\n      constructor(concurrency) {\n        this[kDone] = () => {\n          this.pending--;\n          this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n      }\n      /**\n       * Adds a job to the queue.\n       *\n       * @param {Function} job The job to run\n       * @public\n       */\n      add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n      }\n      /**\n       * Removes a job from the queue and runs it if possible.\n       *\n       * @private\n       */\n      [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n          const job = this.jobs.shift();\n          this.pending++;\n          job(this[kDone]);\n        }\n      }\n    };\n    module.exports = Limiter;\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/permessage-deflate.js\nvar require_permessage_deflate = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/permessage-deflate.js\"(exports, module) {\n    \"use strict\";\n    var zlib = __require(\"zlib\");\n    var bufferUtil = require_buffer_util();\n    var Limiter = require_limiter();\n    var { kStatusCode } = require_constants();\n    var FastBuffer = Buffer[Symbol.species];\n    var TRAILER = Buffer.from([0, 0, 255, 255]);\n    var kPerMessageDeflate = Symbol(\"permessage-deflate\");\n    var kTotalLength = Symbol(\"total-length\");\n    var kCallback = Symbol(\"callback\");\n    var kBuffers = Symbol(\"buffers\");\n    var kError = Symbol(\"error\");\n    var zlibLimiter;\n    var PerMessageDeflate = class {\n      /**\n       * Creates a PerMessageDeflate instance.\n       *\n       * @param {Object} [options] Configuration options\n       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n       *     for, or request, a custom client window size\n       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n       *     acknowledge disabling of client context takeover\n       * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n       *     calls to zlib\n       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n       *     use of a custom server window size\n       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n       *     disabling of server context takeover\n       * @param {Number} [options.threshold=1024] Size (in bytes) below which\n       *     messages should not be compressed if context takeover is disabled\n       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n       *     deflate\n       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n       *     inflate\n       * @param {Boolean} [isServer=false] Create the instance in either server or\n       *     client mode\n       * @param {Number} [maxPayload=0] The maximum allowed message length\n       */\n      constructor(options, isServer, maxPayload) {\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n          zlibLimiter = new Limiter(concurrency);\n        }\n      }\n      /**\n       * @type {String}\n       */\n      static get extensionName() {\n        return \"permessage-deflate\";\n      }\n      /**\n       * Create an extension negotiation offer.\n       *\n       * @return {Object} Extension parameters\n       * @public\n       */\n      offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n          params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n          params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n          params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n          params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n          params.client_max_window_bits = true;\n        }\n        return params;\n      }\n      /**\n       * Accept an extension negotiation offer/response.\n       *\n       * @param {Array} configurations The extension negotiation offers/reponse\n       * @return {Object} Accepted configuration\n       * @public\n       */\n      accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n      }\n      /**\n       * Releases all resources used by the extension.\n       *\n       * @public\n       */\n      cleanup() {\n        if (this._inflate) {\n          this._inflate.close();\n          this._inflate = null;\n        }\n        if (this._deflate) {\n          const callback = this._deflate[kCallback];\n          this._deflate.close();\n          this._deflate = null;\n          if (callback) {\n            callback(\n              new Error(\n                \"The deflate stream was closed while data was being processed\"\n              )\n            );\n          }\n        }\n      }\n      /**\n       *  Accept an extension negotiation offer.\n       *\n       * @param {Array} offers The extension negotiation offers\n       * @return {Object} Accepted configuration\n       * @private\n       */\n      acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params) => {\n          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n            return false;\n          }\n          return true;\n        });\n        if (!accepted) {\n          throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n          accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n          accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n          accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n          accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n          delete accepted.client_max_window_bits;\n        }\n        return accepted;\n      }\n      /**\n       * Accept the extension negotiation response.\n       *\n       * @param {Array} response The extension negotiation response\n       * @return {Object} Accepted configuration\n       * @private\n       */\n      acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n          throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n          if (typeof this._options.clientMaxWindowBits === \"number\") {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n          }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n          throw new Error(\n            'Unexpected or invalid parameter \"client_max_window_bits\"'\n          );\n        }\n        return params;\n      }\n      /**\n       * Normalize parameters.\n       *\n       * @param {Array} configurations The extension negotiation offers/reponse\n       * @return {Array} The offers/response with normalized parameters\n       * @private\n       */\n      normalizeParams(configurations) {\n        configurations.forEach((params) => {\n          Object.keys(params).forEach((key) => {\n            let value = params[key];\n            if (value.length > 1) {\n              throw new Error(`Parameter \"${key}\" must have only a single value`);\n            }\n            value = value[0];\n            if (key === \"client_max_window_bits\") {\n              if (value !== true) {\n                const num = +value;\n                if (!Number.isInteger(num) || num < 8 || num > 15) {\n                  throw new TypeError(\n                    `Invalid value for parameter \"${key}\": ${value}`\n                  );\n                }\n                value = num;\n              } else if (!this._isServer) {\n                throw new TypeError(\n                  `Invalid value for parameter \"${key}\": ${value}`\n                );\n              }\n            } else if (key === \"server_max_window_bits\") {\n              const num = +value;\n              if (!Number.isInteger(num) || num < 8 || num > 15) {\n                throw new TypeError(\n                  `Invalid value for parameter \"${key}\": ${value}`\n                );\n              }\n              value = num;\n            } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n              if (value !== true) {\n                throw new TypeError(\n                  `Invalid value for parameter \"${key}\": ${value}`\n                );\n              }\n            } else {\n              throw new Error(`Unknown parameter \"${key}\"`);\n            }\n            params[key] = value;\n          });\n        });\n        return configurations;\n      }\n      /**\n       * Decompress data. Concurrency limited.\n       *\n       * @param {Buffer} data Compressed data\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @public\n       */\n      decompress(data, fin, callback) {\n        zlibLimiter.add((done) => {\n          this._decompress(data, fin, (err, result) => {\n            done();\n            callback(err, result);\n          });\n        });\n      }\n      /**\n       * Compress data. Concurrency limited.\n       *\n       * @param {(Buffer|String)} data Data to compress\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @public\n       */\n      compress(data, fin, callback) {\n        zlibLimiter.add((done) => {\n          this._compress(data, fin, (err, result) => {\n            done();\n            callback(err, result);\n          });\n        });\n      }\n      /**\n       * Decompress data.\n       *\n       * @param {Buffer} data Compressed data\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @private\n       */\n      _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n          const key = `${endpoint}_max_window_bits`;\n          const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n          this._inflate = zlib.createInflateRaw({\n            ...this._options.zlibInflateOptions,\n            windowBits\n          });\n          this._inflate[kPerMessageDeflate] = this;\n          this._inflate[kTotalLength] = 0;\n          this._inflate[kBuffers] = [];\n          this._inflate.on(\"error\", inflateOnError);\n          this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(() => {\n          const err = this._inflate[kError];\n          if (err) {\n            this._inflate.close();\n            this._inflate = null;\n            callback(err);\n            return;\n          }\n          const data2 = bufferUtil.concat(\n            this._inflate[kBuffers],\n            this._inflate[kTotalLength]\n          );\n          if (this._inflate._readableState.endEmitted) {\n            this._inflate.close();\n            this._inflate = null;\n          } else {\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n              this._inflate.reset();\n            }\n          }\n          callback(null, data2);\n        });\n      }\n      /**\n       * Compress data.\n       *\n       * @param {(Buffer|String)} data Data to compress\n       * @param {Boolean} fin Specifies whether or not this is the last fragment\n       * @param {Function} callback Callback\n       * @private\n       */\n      _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n          const key = `${endpoint}_max_window_bits`;\n          const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n          this._deflate = zlib.createDeflateRaw({\n            ...this._options.zlibDeflateOptions,\n            windowBits\n          });\n          this._deflate[kTotalLength] = 0;\n          this._deflate[kBuffers] = [];\n          this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n          if (!this._deflate) {\n            return;\n          }\n          let data2 = bufferUtil.concat(\n            this._deflate[kBuffers],\n            this._deflate[kTotalLength]\n          );\n          if (fin) {\n            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);\n          }\n          this._deflate[kCallback] = null;\n          this._deflate[kTotalLength] = 0;\n          this._deflate[kBuffers] = [];\n          if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n            this._deflate.reset();\n          }\n          callback(null, data2);\n        });\n      }\n    };\n    module.exports = PerMessageDeflate;\n    function deflateOnData(chunk) {\n      this[kBuffers].push(chunk);\n      this[kTotalLength] += chunk.length;\n    }\n    function inflateOnData(chunk) {\n      this[kTotalLength] += chunk.length;\n      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n      }\n      this[kError] = new RangeError(\"Max payload size exceeded\");\n      this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n      this[kError][kStatusCode] = 1009;\n      this.removeListener(\"data\", inflateOnData);\n      this.reset();\n    }\n    function inflateOnError(err) {\n      this[kPerMessageDeflate]._inflate = null;\n      err[kStatusCode] = 1007;\n      this[kCallback](err);\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/validation.js\nvar require_validation = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/validation.js\"(exports, module) {\n    \"use strict\";\n    var { isUtf8 } = __require(\"buffer\");\n    var { hasBlob } = require_constants();\n    var tokenChars = [\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // 0 - 15\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // 16 - 31\n      0,\n      1,\n      0,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      1,\n      1,\n      0,\n      1,\n      1,\n      0,\n      // 32 - 47\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // 48 - 63\n      0,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      // 64 - 79\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      0,\n      1,\n      1,\n      // 80 - 95\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      // 96 - 111\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0\n      // 112 - 127\n    ];\n    function isValidStatusCode(code) {\n      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n    }\n    function _isValidUTF8(buf) {\n      const len = buf.length;\n      let i = 0;\n      while (i < len) {\n        if ((buf[i] & 128) === 0) {\n          i++;\n        } else if ((buf[i] & 224) === 192) {\n          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n            return false;\n          }\n          i += 2;\n        } else if ((buf[i] & 240) === 224) {\n          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong\n          buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n            return false;\n          }\n          i += 3;\n        } else if ((buf[i] & 248) === 240) {\n          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong\n          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n            return false;\n          }\n          i += 4;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    }\n    function isBlob(value) {\n      return hasBlob && typeof value === \"object\" && typeof value.arrayBuffer === \"function\" && typeof value.type === \"string\" && typeof value.stream === \"function\" && (value[Symbol.toStringTag] === \"Blob\" || value[Symbol.toStringTag] === \"File\");\n    }\n    module.exports = {\n      isBlob,\n      isValidStatusCode,\n      isValidUTF8: _isValidUTF8,\n      tokenChars\n    };\n    if (isUtf8) {\n      module.exports.isValidUTF8 = function(buf) {\n        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n      };\n    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n      try {\n        const isValidUTF8 = __require(\"utf-8-validate\");\n        module.exports.isValidUTF8 = function(buf) {\n          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        };\n      } catch (e) {\n      }\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/receiver.js\nvar require_receiver = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/receiver.js\"(exports, module) {\n    \"use strict\";\n    var { Writable } = __require(\"stream\");\n    var PerMessageDeflate = require_permessage_deflate();\n    var {\n      BINARY_TYPES,\n      EMPTY_BUFFER,\n      kStatusCode,\n      kWebSocket\n    } = require_constants();\n    var { concat, toArrayBuffer, unmask } = require_buffer_util();\n    var { isValidStatusCode, isValidUTF8 } = require_validation();\n    var FastBuffer = Buffer[Symbol.species];\n    var GET_INFO = 0;\n    var GET_PAYLOAD_LENGTH_16 = 1;\n    var GET_PAYLOAD_LENGTH_64 = 2;\n    var GET_MASK = 3;\n    var GET_DATA = 4;\n    var INFLATING = 5;\n    var DEFER_EVENT = 6;\n    var Receiver2 = class extends Writable {\n      /**\n       * Creates a Receiver instance.\n       *\n       * @param {Object} [options] Options object\n       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n       *     multiple times in the same tick\n       * @param {String} [options.binaryType=nodebuffer] The type for binary data\n       * @param {Object} [options.extensions] An object containing the negotiated\n       *     extensions\n       * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n       *     client or server mode\n       * @param {Number} [options.maxPayload=0] The maximum allowed message length\n       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n       *     not to skip UTF-8 validation for text and close messages\n       */\n      constructor(options = {}) {\n        super();\n        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;\n        this._binaryType = options.binaryType || BINARY_TYPES[0];\n        this._extensions = options.extensions || {};\n        this._isServer = !!options.isServer;\n        this._maxPayload = options.maxPayload | 0;\n        this._skipUTF8Validation = !!options.skipUTF8Validation;\n        this[kWebSocket] = void 0;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = void 0;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._errored = false;\n        this._loop = false;\n        this._state = GET_INFO;\n      }\n      /**\n       * Implements `Writable.prototype._write()`.\n       *\n       * @param {Buffer} chunk The chunk of data to write\n       * @param {String} encoding The character encoding of `chunk`\n       * @param {Function} cb Callback\n       * @private\n       */\n      _write(chunk, encoding, cb) {\n        if (this._opcode === 8 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n      }\n      /**\n       * Consumes `n` bytes from the buffered data.\n       *\n       * @param {Number} n The number of bytes to consume\n       * @return {Buffer} The consumed bytes\n       * @private\n       */\n      consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n          const buf = this._buffers[0];\n          this._buffers[0] = new FastBuffer(\n            buf.buffer,\n            buf.byteOffset + n,\n            buf.length - n\n          );\n          return new FastBuffer(buf.buffer, buf.byteOffset, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n          const buf = this._buffers[0];\n          const offset = dst.length - n;\n          if (n >= buf.length) {\n            dst.set(this._buffers.shift(), offset);\n          } else {\n            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n            this._buffers[0] = new FastBuffer(\n              buf.buffer,\n              buf.byteOffset + n,\n              buf.length - n\n            );\n          }\n          n -= buf.length;\n        } while (n > 0);\n        return dst;\n      }\n      /**\n       * Starts the parsing loop.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      startLoop(cb) {\n        this._loop = true;\n        do {\n          switch (this._state) {\n            case GET_INFO:\n              this.getInfo(cb);\n              break;\n            case GET_PAYLOAD_LENGTH_16:\n              this.getPayloadLength16(cb);\n              break;\n            case GET_PAYLOAD_LENGTH_64:\n              this.getPayloadLength64(cb);\n              break;\n            case GET_MASK:\n              this.getMask();\n              break;\n            case GET_DATA:\n              this.getData(cb);\n              break;\n            case INFLATING:\n            case DEFER_EVENT:\n              this._loop = false;\n              return;\n          }\n        } while (this._loop);\n        if (!this._errored) cb();\n      }\n      /**\n       * Reads the first two bytes of a frame.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getInfo(cb) {\n        if (this._bufferedBytes < 2) {\n          this._loop = false;\n          return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 48) !== 0) {\n          const error = this.createError(\n            RangeError,\n            \"RSV2 and RSV3 must be clear\",\n            true,\n            1002,\n            \"WS_ERR_UNEXPECTED_RSV_2_3\"\n          );\n          cb(error);\n          return;\n        }\n        const compressed = (buf[0] & 64) === 64;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n          const error = this.createError(\n            RangeError,\n            \"RSV1 must be clear\",\n            true,\n            1002,\n            \"WS_ERR_UNEXPECTED_RSV_1\"\n          );\n          cb(error);\n          return;\n        }\n        this._fin = (buf[0] & 128) === 128;\n        this._opcode = buf[0] & 15;\n        this._payloadLength = buf[1] & 127;\n        if (this._opcode === 0) {\n          if (compressed) {\n            const error = this.createError(\n              RangeError,\n              \"RSV1 must be clear\",\n              true,\n              1002,\n              \"WS_ERR_UNEXPECTED_RSV_1\"\n            );\n            cb(error);\n            return;\n          }\n          if (!this._fragmented) {\n            const error = this.createError(\n              RangeError,\n              \"invalid opcode 0\",\n              true,\n              1002,\n              \"WS_ERR_INVALID_OPCODE\"\n            );\n            cb(error);\n            return;\n          }\n          this._opcode = this._fragmented;\n        } else if (this._opcode === 1 || this._opcode === 2) {\n          if (this._fragmented) {\n            const error = this.createError(\n              RangeError,\n              `invalid opcode ${this._opcode}`,\n              true,\n              1002,\n              \"WS_ERR_INVALID_OPCODE\"\n            );\n            cb(error);\n            return;\n          }\n          this._compressed = compressed;\n        } else if (this._opcode > 7 && this._opcode < 11) {\n          if (!this._fin) {\n            const error = this.createError(\n              RangeError,\n              \"FIN must be set\",\n              true,\n              1002,\n              \"WS_ERR_EXPECTED_FIN\"\n            );\n            cb(error);\n            return;\n          }\n          if (compressed) {\n            const error = this.createError(\n              RangeError,\n              \"RSV1 must be clear\",\n              true,\n              1002,\n              \"WS_ERR_UNEXPECTED_RSV_1\"\n            );\n            cb(error);\n            return;\n          }\n          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n            const error = this.createError(\n              RangeError,\n              `invalid payload length ${this._payloadLength}`,\n              true,\n              1002,\n              \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\n            );\n            cb(error);\n            return;\n          }\n        } else {\n          const error = this.createError(\n            RangeError,\n            `invalid opcode ${this._opcode}`,\n            true,\n            1002,\n            \"WS_ERR_INVALID_OPCODE\"\n          );\n          cb(error);\n          return;\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 128) === 128;\n        if (this._isServer) {\n          if (!this._masked) {\n            const error = this.createError(\n              RangeError,\n              \"MASK must be set\",\n              true,\n              1002,\n              \"WS_ERR_EXPECTED_MASK\"\n            );\n            cb(error);\n            return;\n          }\n        } else if (this._masked) {\n          const error = this.createError(\n            RangeError,\n            \"MASK must be clear\",\n            true,\n            1002,\n            \"WS_ERR_UNEXPECTED_MASK\"\n          );\n          cb(error);\n          return;\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else this.haveLength(cb);\n      }\n      /**\n       * Gets extended payload length (7+16).\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getPayloadLength16(cb) {\n        if (this._bufferedBytes < 2) {\n          this._loop = false;\n          return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        this.haveLength(cb);\n      }\n      /**\n       * Gets extended payload length (7+64).\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getPayloadLength64(cb) {\n        if (this._bufferedBytes < 8) {\n          this._loop = false;\n          return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        if (num > Math.pow(2, 53 - 32) - 1) {\n          const error = this.createError(\n            RangeError,\n            \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\n            false,\n            1009,\n            \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\n          );\n          cb(error);\n          return;\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        this.haveLength(cb);\n      }\n      /**\n       * Payload length has been read.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      haveLength(cb) {\n        if (this._payloadLength && this._opcode < 8) {\n          this._totalPayloadLength += this._payloadLength;\n          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n            const error = this.createError(\n              RangeError,\n              \"Max payload size exceeded\",\n              false,\n              1009,\n              \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n            );\n            cb(error);\n            return;\n          }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n      }\n      /**\n       * Reads mask bytes.\n       *\n       * @private\n       */\n      getMask() {\n        if (this._bufferedBytes < 4) {\n          this._loop = false;\n          return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n      }\n      /**\n       * Reads data bytes.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n          if (this._bufferedBytes < this._payloadLength) {\n            this._loop = false;\n            return;\n          }\n          data = this.consume(this._payloadLength);\n          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n            unmask(data, this._mask);\n          }\n        }\n        if (this._opcode > 7) {\n          this.controlMessage(data, cb);\n          return;\n        }\n        if (this._compressed) {\n          this._state = INFLATING;\n          this.decompress(data, cb);\n          return;\n        }\n        if (data.length) {\n          this._messageLength = this._totalPayloadLength;\n          this._fragments.push(data);\n        }\n        this.dataMessage(cb);\n      }\n      /**\n       * Decompresses data.\n       *\n       * @param {Buffer} data Compressed data\n       * @param {Function} cb Callback\n       * @private\n       */\n      decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n          if (err) return cb(err);\n          if (buf.length) {\n            this._messageLength += buf.length;\n            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n              const error = this.createError(\n                RangeError,\n                \"Max payload size exceeded\",\n                false,\n                1009,\n                \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n              );\n              cb(error);\n              return;\n            }\n            this._fragments.push(buf);\n          }\n          this.dataMessage(cb);\n          if (this._state === GET_INFO) this.startLoop(cb);\n        });\n      }\n      /**\n       * Handles a data message.\n       *\n       * @param {Function} cb Callback\n       * @private\n       */\n      dataMessage(cb) {\n        if (!this._fin) {\n          this._state = GET_INFO;\n          return;\n        }\n        const messageLength = this._messageLength;\n        const fragments = this._fragments;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragmented = 0;\n        this._fragments = [];\n        if (this._opcode === 2) {\n          let data;\n          if (this._binaryType === \"nodebuffer\") {\n            data = concat(fragments, messageLength);\n          } else if (this._binaryType === \"arraybuffer\") {\n            data = toArrayBuffer(concat(fragments, messageLength));\n          } else if (this._binaryType === \"blob\") {\n            data = new Blob(fragments);\n          } else {\n            data = fragments;\n          }\n          if (this._allowSynchronousEvents) {\n            this.emit(\"message\", data, true);\n            this._state = GET_INFO;\n          } else {\n            this._state = DEFER_EVENT;\n            setImmediate(() => {\n              this.emit(\"message\", data, true);\n              this._state = GET_INFO;\n              this.startLoop(cb);\n            });\n          }\n        } else {\n          const buf = concat(fragments, messageLength);\n          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n            const error = this.createError(\n              Error,\n              \"invalid UTF-8 sequence\",\n              true,\n              1007,\n              \"WS_ERR_INVALID_UTF8\"\n            );\n            cb(error);\n            return;\n          }\n          if (this._state === INFLATING || this._allowSynchronousEvents) {\n            this.emit(\"message\", buf, false);\n            this._state = GET_INFO;\n          } else {\n            this._state = DEFER_EVENT;\n            setImmediate(() => {\n              this.emit(\"message\", buf, false);\n              this._state = GET_INFO;\n              this.startLoop(cb);\n            });\n          }\n        }\n      }\n      /**\n       * Handles a control message.\n       *\n       * @param {Buffer} data Data to handle\n       * @return {(Error|RangeError|undefined)} A possible error\n       * @private\n       */\n      controlMessage(data, cb) {\n        if (this._opcode === 8) {\n          if (data.length === 0) {\n            this._loop = false;\n            this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n            this.end();\n          } else {\n            const code = data.readUInt16BE(0);\n            if (!isValidStatusCode(code)) {\n              const error = this.createError(\n                RangeError,\n                `invalid status code ${code}`,\n                true,\n                1002,\n                \"WS_ERR_INVALID_CLOSE_CODE\"\n              );\n              cb(error);\n              return;\n            }\n            const buf = new FastBuffer(\n              data.buffer,\n              data.byteOffset + 2,\n              data.length - 2\n            );\n            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n              const error = this.createError(\n                Error,\n                \"invalid UTF-8 sequence\",\n                true,\n                1007,\n                \"WS_ERR_INVALID_UTF8\"\n              );\n              cb(error);\n              return;\n            }\n            this._loop = false;\n            this.emit(\"conclude\", code, buf);\n            this.end();\n          }\n          this._state = GET_INFO;\n          return;\n        }\n        if (this._allowSynchronousEvents) {\n          this.emit(this._opcode === 9 ? \"ping\" : \"pong\", data);\n          this._state = GET_INFO;\n        } else {\n          this._state = DEFER_EVENT;\n          setImmediate(() => {\n            this.emit(this._opcode === 9 ? \"ping\" : \"pong\", data);\n            this._state = GET_INFO;\n            this.startLoop(cb);\n          });\n        }\n      }\n      /**\n       * Builds an error object.\n       *\n       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n       * @param {String} message The error message\n       * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n       *     `message`\n       * @param {Number} statusCode The status code\n       * @param {String} errorCode The exposed error code\n       * @return {(Error|RangeError)} The error\n       * @private\n       */\n      createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n        this._loop = false;\n        this._errored = true;\n        const err = new ErrorCtor(\n          prefix ? `Invalid WebSocket frame: ${message}` : message\n        );\n        Error.captureStackTrace(err, this.createError);\n        err.code = errorCode;\n        err[kStatusCode] = statusCode;\n        return err;\n      }\n    };\n    module.exports = Receiver2;\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/sender.js\nvar require_sender = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/sender.js\"(exports, module) {\n    \"use strict\";\n    var { Duplex } = __require(\"stream\");\n    var { randomFillSync } = __require(\"crypto\");\n    var PerMessageDeflate = require_permessage_deflate();\n    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();\n    var { isBlob, isValidStatusCode } = require_validation();\n    var { mask: applyMask, toBuffer } = require_buffer_util();\n    var kByteLength = Symbol(\"kByteLength\");\n    var maskBuffer = Buffer.alloc(4);\n    var RANDOM_POOL_SIZE = 8 * 1024;\n    var randomPool;\n    var randomPoolPointer = RANDOM_POOL_SIZE;\n    var DEFAULT = 0;\n    var DEFLATING = 1;\n    var GET_BLOB_DATA = 2;\n    var Sender2 = class _Sender {\n      /**\n       * Creates a Sender instance.\n       *\n       * @param {Duplex} socket The connection socket\n       * @param {Object} [extensions] An object containing the negotiated extensions\n       * @param {Function} [generateMask] The function used to generate the masking\n       *     key\n       */\n      constructor(socket, extensions, generateMask) {\n        this._extensions = extensions || {};\n        if (generateMask) {\n          this._generateMask = generateMask;\n          this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = void 0;\n      }\n      /**\n       * Frames a piece of data according to the HyBi WebSocket protocol.\n       *\n       * @param {(Buffer|String)} data The data to frame\n       * @param {Object} options Options object\n       * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n       *     FIN bit\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n       *     key\n       * @param {Number} options.opcode The opcode\n       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n       *     modified\n       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n       *     RSV1 bit\n       * @return {(Buffer|String)[]} The framed data\n       * @public\n       */\n      static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n          mask = options.maskBuffer || maskBuffer;\n          if (options.generateMask) {\n            options.generateMask(mask);\n          } else {\n            if (randomPoolPointer === RANDOM_POOL_SIZE) {\n              if (randomPool === void 0) {\n                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n              }\n              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n              randomPoolPointer = 0;\n            }\n            mask[0] = randomPool[randomPoolPointer++];\n            mask[1] = randomPool[randomPoolPointer++];\n            mask[2] = randomPool[randomPoolPointer++];\n            mask[3] = randomPool[randomPoolPointer++];\n          }\n          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n          offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n            dataLength = options[kByteLength];\n          } else {\n            data = Buffer.from(data);\n            dataLength = data.length;\n          }\n        } else {\n          dataLength = data.length;\n          merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n          offset += 8;\n          payloadLength = 127;\n        } else if (dataLength > 125) {\n          offset += 2;\n          payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 128 : options.opcode;\n        if (options.rsv1) target[0] |= 64;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n          target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n          target[2] = target[3] = 0;\n          target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [target, data];\n        target[1] |= 128;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [target, data];\n        if (merge) {\n          applyMask(data, mask, target, offset, dataLength);\n          return [target];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [target, data];\n      }\n      /**\n       * Sends a close message to the other peer.\n       *\n       * @param {Number} [code] The status code component of the body\n       * @param {(String|Buffer)} [data] The message component of the body\n       * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      close(code, data, mask, cb) {\n        let buf;\n        if (code === void 0) {\n          buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n          throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === void 0 || !data.length) {\n          buf = Buffer.allocUnsafe(2);\n          buf.writeUInt16BE(code, 0);\n        } else {\n          const length = Buffer.byteLength(data);\n          if (length > 123) {\n            throw new RangeError(\"The message must not be greater than 123 bytes\");\n          }\n          buf = Buffer.allocUnsafe(2 + length);\n          buf.writeUInt16BE(code, 0);\n          if (typeof data === \"string\") {\n            buf.write(data, 2);\n          } else {\n            buf.set(data, 2);\n          }\n        }\n        const options = {\n          [kByteLength]: buf.length,\n          fin: true,\n          generateMask: this._generateMask,\n          mask,\n          maskBuffer: this._maskBuffer,\n          opcode: 8,\n          readOnly: false,\n          rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, buf, false, options, cb]);\n        } else {\n          this.sendFrame(_Sender.frame(buf, options), cb);\n        }\n      }\n      /**\n       * Sends a ping message to the other peer.\n       *\n       * @param {*} data The message to send\n       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n          byteLength = Buffer.byteLength(data);\n          readOnly = false;\n        } else if (isBlob(data)) {\n          byteLength = data.size;\n          readOnly = false;\n        } else {\n          data = toBuffer(data);\n          byteLength = data.length;\n          readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n          throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n          [kByteLength]: byteLength,\n          fin: true,\n          generateMask: this._generateMask,\n          mask,\n          maskBuffer: this._maskBuffer,\n          opcode: 9,\n          readOnly,\n          rsv1: false\n        };\n        if (isBlob(data)) {\n          if (this._state !== DEFAULT) {\n            this.enqueue([this.getBlobData, data, false, options, cb]);\n          } else {\n            this.getBlobData(data, false, options, cb);\n          }\n        } else if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, data, false, options, cb]);\n        } else {\n          this.sendFrame(_Sender.frame(data, options), cb);\n        }\n      }\n      /**\n       * Sends a pong message to the other peer.\n       *\n       * @param {*} data The message to send\n       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n          byteLength = Buffer.byteLength(data);\n          readOnly = false;\n        } else if (isBlob(data)) {\n          byteLength = data.size;\n          readOnly = false;\n        } else {\n          data = toBuffer(data);\n          byteLength = data.length;\n          readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n          throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n          [kByteLength]: byteLength,\n          fin: true,\n          generateMask: this._generateMask,\n          mask,\n          maskBuffer: this._maskBuffer,\n          opcode: 10,\n          readOnly,\n          rsv1: false\n        };\n        if (isBlob(data)) {\n          if (this._state !== DEFAULT) {\n            this.enqueue([this.getBlobData, data, false, options, cb]);\n          } else {\n            this.getBlobData(data, false, options, cb);\n          }\n        } else if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, data, false, options, cb]);\n        } else {\n          this.sendFrame(_Sender.frame(data, options), cb);\n        }\n      }\n      /**\n       * Sends a data message to the other peer.\n       *\n       * @param {*} data The message to send\n       * @param {Object} options Options object\n       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n       *     or text\n       * @param {Boolean} [options.compress=false] Specifies whether or not to\n       *     compress `data`\n       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n       *     last one\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Function} [cb] Callback\n       * @public\n       */\n      send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n          byteLength = Buffer.byteLength(data);\n          readOnly = false;\n        } else if (isBlob(data)) {\n          byteLength = data.size;\n          readOnly = false;\n        } else {\n          data = toBuffer(data);\n          byteLength = data.length;\n          readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n          this._firstFragment = false;\n          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n            rsv1 = byteLength >= perMessageDeflate._threshold;\n          }\n          this._compress = rsv1;\n        } else {\n          rsv1 = false;\n          opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1\n        };\n        if (isBlob(data)) {\n          if (this._state !== DEFAULT) {\n            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n          } else {\n            this.getBlobData(data, this._compress, opts, cb);\n          }\n        } else if (this._state !== DEFAULT) {\n          this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n        } else {\n          this.dispatch(data, this._compress, opts, cb);\n        }\n      }\n      /**\n       * Gets the contents of a blob as binary data.\n       *\n       * @param {Blob} blob The blob\n       * @param {Boolean} [compress=false] Specifies whether or not to compress\n       *     the data\n       * @param {Object} options Options object\n       * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n       *     FIN bit\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n       *     key\n       * @param {Number} options.opcode The opcode\n       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n       *     modified\n       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n       *     RSV1 bit\n       * @param {Function} [cb] Callback\n       * @private\n       */\n      getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer) => {\n          if (this._socket.destroyed) {\n            const err = new Error(\n              \"The socket was closed while the blob was being read\"\n            );\n            process.nextTick(callCallbacks, this, err, cb);\n            return;\n          }\n          this._bufferedBytes -= options[kByteLength];\n          const data = toBuffer(arrayBuffer);\n          if (!compress) {\n            this._state = DEFAULT;\n            this.sendFrame(_Sender.frame(data, options), cb);\n            this.dequeue();\n          } else {\n            this.dispatch(data, compress, options, cb);\n          }\n        }).catch((err) => {\n          process.nextTick(onError, this, err, cb);\n        });\n      }\n      /**\n       * Dispatches a message.\n       *\n       * @param {(Buffer|String)} data The message to send\n       * @param {Boolean} [compress=false] Specifies whether or not to compress\n       *     `data`\n       * @param {Object} options Options object\n       * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n       *     FIN bit\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n       *     `data`\n       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n       *     key\n       * @param {Number} options.opcode The opcode\n       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n       *     modified\n       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n       *     RSV1 bit\n       * @param {Function} [cb] Callback\n       * @private\n       */\n      dispatch(data, compress, options, cb) {\n        if (!compress) {\n          this.sendFrame(_Sender.frame(data, options), cb);\n          return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf) => {\n          if (this._socket.destroyed) {\n            const err = new Error(\n              \"The socket was closed while data was being compressed\"\n            );\n            callCallbacks(this, err, cb);\n            return;\n          }\n          this._bufferedBytes -= options[kByteLength];\n          this._state = DEFAULT;\n          options.readOnly = false;\n          this.sendFrame(_Sender.frame(buf, options), cb);\n          this.dequeue();\n        });\n      }\n      /**\n       * Executes queued send operations.\n       *\n       * @private\n       */\n      dequeue() {\n        while (this._state === DEFAULT && this._queue.length) {\n          const params = this._queue.shift();\n          this._bufferedBytes -= params[3][kByteLength];\n          Reflect.apply(params[0], this, params.slice(1));\n        }\n      }\n      /**\n       * Enqueues a send operation.\n       *\n       * @param {Array} params Send operation parameters.\n       * @private\n       */\n      enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n      }\n      /**\n       * Sends a frame.\n       *\n       * @param {Buffer[]} list The frame to send\n       * @param {Function} [cb] Callback\n       * @private\n       */\n      sendFrame(list, cb) {\n        if (list.length === 2) {\n          this._socket.cork();\n          this._socket.write(list[0]);\n          this._socket.write(list[1], cb);\n          this._socket.uncork();\n        } else {\n          this._socket.write(list[0], cb);\n        }\n      }\n    };\n    module.exports = Sender2;\n    function callCallbacks(sender, err, cb) {\n      if (typeof cb === \"function\") cb(err);\n      for (let i = 0; i < sender._queue.length; i++) {\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === \"function\") callback(err);\n      }\n    }\n    function onError(sender, err, cb) {\n      callCallbacks(sender, err, cb);\n      sender.onerror(err);\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/event-target.js\nvar require_event_target = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/event-target.js\"(exports, module) {\n    \"use strict\";\n    var { kForOnEventAttribute, kListener } = require_constants();\n    var kCode = Symbol(\"kCode\");\n    var kData = Symbol(\"kData\");\n    var kError = Symbol(\"kError\");\n    var kMessage = Symbol(\"kMessage\");\n    var kReason = Symbol(\"kReason\");\n    var kTarget = Symbol(\"kTarget\");\n    var kType = Symbol(\"kType\");\n    var kWasClean = Symbol(\"kWasClean\");\n    var Event = class {\n      /**\n       * Create a new `Event`.\n       *\n       * @param {String} type The name of the event\n       * @throws {TypeError} If the `type` argument is not specified\n       */\n      constructor(type) {\n        this[kTarget] = null;\n        this[kType] = type;\n      }\n      /**\n       * @type {*}\n       */\n      get target() {\n        return this[kTarget];\n      }\n      /**\n       * @type {String}\n       */\n      get type() {\n        return this[kType];\n      }\n    };\n    Object.defineProperty(Event.prototype, \"target\", { enumerable: true });\n    Object.defineProperty(Event.prototype, \"type\", { enumerable: true });\n    var CloseEvent = class extends Event {\n      /**\n       * Create a new `CloseEvent`.\n       *\n       * @param {String} type The name of the event\n       * @param {Object} [options] A dictionary object that allows for setting\n       *     attributes via object members of the same name\n       * @param {Number} [options.code=0] The status code explaining why the\n       *     connection was closed\n       * @param {String} [options.reason=''] A human-readable string explaining why\n       *     the connection was closed\n       * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n       *     connection was cleanly closed\n       */\n      constructor(type, options = {}) {\n        super(type);\n        this[kCode] = options.code === void 0 ? 0 : options.code;\n        this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n      }\n      /**\n       * @type {Number}\n       */\n      get code() {\n        return this[kCode];\n      }\n      /**\n       * @type {String}\n       */\n      get reason() {\n        return this[kReason];\n      }\n      /**\n       * @type {Boolean}\n       */\n      get wasClean() {\n        return this[kWasClean];\n      }\n    };\n    Object.defineProperty(CloseEvent.prototype, \"code\", { enumerable: true });\n    Object.defineProperty(CloseEvent.prototype, \"reason\", { enumerable: true });\n    Object.defineProperty(CloseEvent.prototype, \"wasClean\", { enumerable: true });\n    var ErrorEvent = class extends Event {\n      /**\n       * Create a new `ErrorEvent`.\n       *\n       * @param {String} type The name of the event\n       * @param {Object} [options] A dictionary object that allows for setting\n       *     attributes via object members of the same name\n       * @param {*} [options.error=null] The error that generated this event\n       * @param {String} [options.message=''] The error message\n       */\n      constructor(type, options = {}) {\n        super(type);\n        this[kError] = options.error === void 0 ? null : options.error;\n        this[kMessage] = options.message === void 0 ? \"\" : options.message;\n      }\n      /**\n       * @type {*}\n       */\n      get error() {\n        return this[kError];\n      }\n      /**\n       * @type {String}\n       */\n      get message() {\n        return this[kMessage];\n      }\n    };\n    Object.defineProperty(ErrorEvent.prototype, \"error\", { enumerable: true });\n    Object.defineProperty(ErrorEvent.prototype, \"message\", { enumerable: true });\n    var MessageEvent = class extends Event {\n      /**\n       * Create a new `MessageEvent`.\n       *\n       * @param {String} type The name of the event\n       * @param {Object} [options] A dictionary object that allows for setting\n       *     attributes via object members of the same name\n       * @param {*} [options.data=null] The message content\n       */\n      constructor(type, options = {}) {\n        super(type);\n        this[kData] = options.data === void 0 ? null : options.data;\n      }\n      /**\n       * @type {*}\n       */\n      get data() {\n        return this[kData];\n      }\n    };\n    Object.defineProperty(MessageEvent.prototype, \"data\", { enumerable: true });\n    var EventTarget = {\n      /**\n       * Register an event listener.\n       *\n       * @param {String} type A string representing the event type to listen for\n       * @param {(Function|Object)} handler The listener to add\n       * @param {Object} [options] An options object specifies characteristics about\n       *     the event listener\n       * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n       *     listener should be invoked at most once after being added. If `true`,\n       *     the listener would be automatically removed when invoked.\n       * @public\n       */\n      addEventListener(type, handler, options = {}) {\n        for (const listener of this.listeners(type)) {\n          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n            return;\n          }\n        }\n        let wrapper;\n        if (type === \"message\") {\n          wrapper = function onMessage(data, isBinary) {\n            const event = new MessageEvent(\"message\", {\n              data: isBinary ? data : data.toString()\n            });\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else if (type === \"close\") {\n          wrapper = function onClose(code, message) {\n            const event = new CloseEvent(\"close\", {\n              code,\n              reason: message.toString(),\n              wasClean: this._closeFrameReceived && this._closeFrameSent\n            });\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else if (type === \"error\") {\n          wrapper = function onError(error) {\n            const event = new ErrorEvent(\"error\", {\n              error,\n              message: error.message\n            });\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else if (type === \"open\") {\n          wrapper = function onOpen() {\n            const event = new Event(\"open\");\n            event[kTarget] = this;\n            callListener(handler, this, event);\n          };\n        } else {\n          return;\n        }\n        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n        wrapper[kListener] = handler;\n        if (options.once) {\n          this.once(type, wrapper);\n        } else {\n          this.on(type, wrapper);\n        }\n      },\n      /**\n       * Remove an event listener.\n       *\n       * @param {String} type A string representing the event type to remove\n       * @param {(Function|Object)} handler The listener to remove\n       * @public\n       */\n      removeEventListener(type, handler) {\n        for (const listener of this.listeners(type)) {\n          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n            this.removeListener(type, listener);\n            break;\n          }\n        }\n      }\n    };\n    module.exports = {\n      CloseEvent,\n      ErrorEvent,\n      Event,\n      EventTarget,\n      MessageEvent\n    };\n    function callListener(listener, thisArg, event) {\n      if (typeof listener === \"object\" && listener.handleEvent) {\n        listener.handleEvent.call(listener, event);\n      } else {\n        listener.call(thisArg, event);\n      }\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/extension.js\nvar require_extension = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/extension.js\"(exports, module) {\n    \"use strict\";\n    var { tokenChars } = require_validation();\n    function push(dest, name, elem) {\n      if (dest[name] === void 0) dest[name] = [elem];\n      else dest[name].push(elem);\n    }\n    function parse(header) {\n      const offers = /* @__PURE__ */ Object.create(null);\n      let params = /* @__PURE__ */ Object.create(null);\n      let mustUnescape = false;\n      let isEscaping = false;\n      let inQuotes = false;\n      let extensionName;\n      let paramName;\n      let start = -1;\n      let code = -1;\n      let end = -1;\n      let i = 0;\n      for (; i < header.length; i++) {\n        code = header.charCodeAt(i);\n        if (extensionName === void 0) {\n          if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n          } else if (i !== 0 && (code === 32 || code === 9)) {\n            if (end === -1 && start !== -1) end = i;\n          } else if (code === 59 || code === 44) {\n            if (start === -1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            const name = header.slice(start, end);\n            if (code === 44) {\n              push(offers, name, params);\n              params = /* @__PURE__ */ Object.create(null);\n            } else {\n              extensionName = name;\n            }\n            start = end = -1;\n          } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n        } else if (paramName === void 0) {\n          if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n          } else if (code === 32 || code === 9) {\n            if (end === -1 && start !== -1) end = i;\n          } else if (code === 59 || code === 44) {\n            if (start === -1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            push(params, header.slice(start, end), true);\n            if (code === 44) {\n              push(offers, extensionName, params);\n              params = /* @__PURE__ */ Object.create(null);\n              extensionName = void 0;\n            }\n            start = end = -1;\n          } else if (code === 61 && start !== -1 && end === -1) {\n            paramName = header.slice(start, i);\n            start = end = -1;\n          } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n        } else {\n          if (isEscaping) {\n            if (tokenChars[code] !== 1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (start === -1) start = i;\n            else if (!mustUnescape) mustUnescape = true;\n            isEscaping = false;\n          } else if (inQuotes) {\n            if (tokenChars[code] === 1) {\n              if (start === -1) start = i;\n            } else if (code === 34 && start !== -1) {\n              inQuotes = false;\n              end = i;\n            } else if (code === 92) {\n              isEscaping = true;\n            } else {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n            inQuotes = true;\n          } else if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n          } else if (start !== -1 && (code === 32 || code === 9)) {\n            if (end === -1) end = i;\n          } else if (code === 59 || code === 44) {\n            if (start === -1) {\n              throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            let value = header.slice(start, end);\n            if (mustUnescape) {\n              value = value.replace(/\\\\/g, \"\");\n              mustUnescape = false;\n            }\n            push(params, paramName, value);\n            if (code === 44) {\n              push(offers, extensionName, params);\n              params = /* @__PURE__ */ Object.create(null);\n              extensionName = void 0;\n            }\n            paramName = void 0;\n            start = end = -1;\n          } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n        }\n      }\n      if (start === -1 || inQuotes || code === 32 || code === 9) {\n        throw new SyntaxError(\"Unexpected end of input\");\n      }\n      if (end === -1) end = i;\n      const token = header.slice(start, end);\n      if (extensionName === void 0) {\n        push(offers, token, params);\n      } else {\n        if (paramName === void 0) {\n          push(params, token, true);\n        } else if (mustUnescape) {\n          push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n          push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n      }\n      return offers;\n    }\n    function format(extensions) {\n      return Object.keys(extensions).map((extension) => {\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [configurations];\n        return configurations.map((params) => {\n          return [extension].concat(\n            Object.keys(params).map((k) => {\n              let values = params[k];\n              if (!Array.isArray(values)) values = [values];\n              return values.map((v) => v === true ? k : `${k}=${v}`).join(\"; \");\n            })\n          ).join(\"; \");\n        }).join(\", \");\n      }).join(\", \");\n    }\n    module.exports = { format, parse };\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/websocket.js\nvar require_websocket = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/websocket.js\"(exports, module) {\n    \"use strict\";\n    var EventEmitter = __require(\"events\");\n    var https = __require(\"https\");\n    var http = __require(\"http\");\n    var net = __require(\"net\");\n    var tls = __require(\"tls\");\n    var { randomBytes, createHash } = __require(\"crypto\");\n    var { Duplex, Readable } = __require(\"stream\");\n    var { URL } = __require(\"url\");\n    var PerMessageDeflate = require_permessage_deflate();\n    var Receiver2 = require_receiver();\n    var Sender2 = require_sender();\n    var { isBlob } = require_validation();\n    var {\n      BINARY_TYPES,\n      EMPTY_BUFFER,\n      GUID,\n      kForOnEventAttribute,\n      kListener,\n      kStatusCode,\n      kWebSocket,\n      NOOP\n    } = require_constants();\n    var {\n      EventTarget: { addEventListener, removeEventListener }\n    } = require_event_target();\n    var { format, parse } = require_extension();\n    var { toBuffer } = require_buffer_util();\n    var closeTimeout = 30 * 1e3;\n    var kAborted = Symbol(\"kAborted\");\n    var protocolVersions = [8, 13];\n    var readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\n    var subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n    var WebSocket2 = class _WebSocket extends EventEmitter {\n      /**\n       * Create a new `WebSocket`.\n       *\n       * @param {(String|URL)} address The URL to which to connect\n       * @param {(String|String[])} [protocols] The subprotocols\n       * @param {Object} [options] Connection options\n       */\n      constructor(address, protocols, options) {\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = EMPTY_BUFFER;\n        this._closeTimer = null;\n        this._errorEmitted = false;\n        this._extensions = {};\n        this._paused = false;\n        this._protocol = \"\";\n        this._readyState = _WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n          this._bufferedAmount = 0;\n          this._isServer = false;\n          this._redirects = 0;\n          if (protocols === void 0) {\n            protocols = [];\n          } else if (!Array.isArray(protocols)) {\n            if (typeof protocols === \"object\" && protocols !== null) {\n              options = protocols;\n              protocols = [];\n            } else {\n              protocols = [protocols];\n            }\n          }\n          initAsClient(this, address, protocols, options);\n        } else {\n          this._autoPong = options.autoPong;\n          this._isServer = true;\n        }\n      }\n      /**\n       * For historical reasons, the custom \"nodebuffer\" type is used by the default\n       * instead of \"blob\".\n       *\n       * @type {String}\n       */\n      get binaryType() {\n        return this._binaryType;\n      }\n      set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        if (this._receiver) this._receiver._binaryType = type;\n      }\n      /**\n       * @type {Number}\n       */\n      get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n      }\n      /**\n       * @type {String}\n       */\n      get extensions() {\n        return Object.keys(this._extensions).join();\n      }\n      /**\n       * @type {Boolean}\n       */\n      get isPaused() {\n        return this._paused;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onclose() {\n        return null;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onerror() {\n        return null;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onopen() {\n        return null;\n      }\n      /**\n       * @type {Function}\n       */\n      /* istanbul ignore next */\n      get onmessage() {\n        return null;\n      }\n      /**\n       * @type {String}\n       */\n      get protocol() {\n        return this._protocol;\n      }\n      /**\n       * @type {Number}\n       */\n      get readyState() {\n        return this._readyState;\n      }\n      /**\n       * @type {String}\n       */\n      get url() {\n        return this._url;\n      }\n      /**\n       * Set up the socket and the internal resources.\n       *\n       * @param {Duplex} socket The network socket between the server and client\n       * @param {Buffer} head The first packet of the upgraded stream\n       * @param {Object} options Options object\n       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n       *     multiple times in the same tick\n       * @param {Function} [options.generateMask] The function used to generate the\n       *     masking key\n       * @param {Number} [options.maxPayload=0] The maximum allowed message size\n       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n       *     not to skip UTF-8 validation for text and close messages\n       * @private\n       */\n      setSocket(socket, head, options) {\n        const receiver = new Receiver2({\n          allowSynchronousEvents: options.allowSynchronousEvents,\n          binaryType: this.binaryType,\n          extensions: this._extensions,\n          isServer: this._isServer,\n          maxPayload: options.maxPayload,\n          skipUTF8Validation: options.skipUTF8Validation\n        });\n        const sender = new Sender2(socket, this._extensions, options.generateMask);\n        this._receiver = receiver;\n        this._sender = sender;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        sender[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        sender.onerror = senderOnError;\n        if (socket.setTimeout) socket.setTimeout(0);\n        if (socket.setNoDelay) socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = _WebSocket.OPEN;\n        this.emit(\"open\");\n      }\n      /**\n       * Emit the `'close'` event.\n       *\n       * @private\n       */\n      emitClose() {\n        if (!this._socket) {\n          this._readyState = _WebSocket.CLOSED;\n          this.emit(\"close\", this._closeCode, this._closeMessage);\n          return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n          this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = _WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n      }\n      /**\n       * Start a closing handshake.\n       *\n       *          +----------+   +-----------+   +----------+\n       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n       *    |     +----------+   +-----------+   +----------+     |\n       *          +----------+   +-----------+         |\n       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n       *          +----------+   +-----------+   |\n       *    |           |                        |   +---+        |\n       *                +------------------------+-->|fin| - - - -\n       *    |         +---+                      |   +---+\n       *     - - - - -|fin|<---------------------+\n       *              +---+\n       *\n       * @param {Number} [code] Status code explaining why the connection is closing\n       * @param {(String|Buffer)} [data] The reason why the connection is\n       *     closing\n       * @public\n       */\n      close(code, data) {\n        if (this.readyState === _WebSocket.CLOSED) return;\n        if (this.readyState === _WebSocket.CONNECTING) {\n          const msg = \"WebSocket was closed before the connection was established\";\n          abortHandshake(this, this._req, msg);\n          return;\n        }\n        if (this.readyState === _WebSocket.CLOSING) {\n          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n            this._socket.end();\n          }\n          return;\n        }\n        this._readyState = _WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err) => {\n          if (err) return;\n          this._closeFrameSent = true;\n          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n            this._socket.end();\n          }\n        });\n        setCloseTimer(this);\n      }\n      /**\n       * Pause the socket.\n       *\n       * @public\n       */\n      pause() {\n        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {\n          return;\n        }\n        this._paused = true;\n        this._socket.pause();\n      }\n      /**\n       * Send a ping.\n       *\n       * @param {*} [data] The data to send\n       * @param {Boolean} [mask] Indicates whether or not to mask `data`\n       * @param {Function} [cb] Callback which is executed when the ping is sent\n       * @public\n       */\n      ping(data, mask, cb) {\n        if (this.readyState === _WebSocket.CONNECTING) {\n          throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n          cb = data;\n          data = mask = void 0;\n        } else if (typeof mask === \"function\") {\n          cb = mask;\n          mask = void 0;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== _WebSocket.OPEN) {\n          sendAfterClose(this, data, cb);\n          return;\n        }\n        if (mask === void 0) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n      }\n      /**\n       * Send a pong.\n       *\n       * @param {*} [data] The data to send\n       * @param {Boolean} [mask] Indicates whether or not to mask `data`\n       * @param {Function} [cb] Callback which is executed when the pong is sent\n       * @public\n       */\n      pong(data, mask, cb) {\n        if (this.readyState === _WebSocket.CONNECTING) {\n          throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n          cb = data;\n          data = mask = void 0;\n        } else if (typeof mask === \"function\") {\n          cb = mask;\n          mask = void 0;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== _WebSocket.OPEN) {\n          sendAfterClose(this, data, cb);\n          return;\n        }\n        if (mask === void 0) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n      }\n      /**\n       * Resume the socket.\n       *\n       * @public\n       */\n      resume() {\n        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {\n          return;\n        }\n        this._paused = false;\n        if (!this._receiver._writableState.needDrain) this._socket.resume();\n      }\n      /**\n       * Send a data message.\n       *\n       * @param {*} data The message to send\n       * @param {Object} [options] Options object\n       * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n       *     text\n       * @param {Boolean} [options.compress] Specifies whether or not to compress\n       *     `data`\n       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n       *     last one\n       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n       * @param {Function} [cb] Callback which is executed when data is written out\n       * @public\n       */\n      send(data, options, cb) {\n        if (this.readyState === _WebSocket.CONNECTING) {\n          throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n          cb = options;\n          options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== _WebSocket.OPEN) {\n          sendAfterClose(this, data, cb);\n          return;\n        }\n        const opts = {\n          binary: typeof data !== \"string\",\n          mask: !this._isServer,\n          compress: true,\n          fin: true,\n          ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n          opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n      }\n      /**\n       * Forcibly close the connection.\n       *\n       * @public\n       */\n      terminate() {\n        if (this.readyState === _WebSocket.CLOSED) return;\n        if (this.readyState === _WebSocket.CONNECTING) {\n          const msg = \"WebSocket was closed before the connection was established\";\n          abortHandshake(this, this._req, msg);\n          return;\n        }\n        if (this._socket) {\n          this._readyState = _WebSocket.CLOSING;\n          this._socket.destroy();\n        }\n      }\n    };\n    Object.defineProperty(WebSocket2, \"CONNECTING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CONNECTING\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"CONNECTING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CONNECTING\")\n    });\n    Object.defineProperty(WebSocket2, \"OPEN\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"OPEN\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"OPEN\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"OPEN\")\n    });\n    Object.defineProperty(WebSocket2, \"CLOSING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSING\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"CLOSING\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSING\")\n    });\n    Object.defineProperty(WebSocket2, \"CLOSED\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSED\")\n    });\n    Object.defineProperty(WebSocket2.prototype, \"CLOSED\", {\n      enumerable: true,\n      value: readyStates.indexOf(\"CLOSED\")\n    });\n    [\n      \"binaryType\",\n      \"bufferedAmount\",\n      \"extensions\",\n      \"isPaused\",\n      \"protocol\",\n      \"readyState\",\n      \"url\"\n    ].forEach((property) => {\n      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });\n    });\n    [\"open\", \"error\", \"close\", \"message\"].forEach((method) => {\n      Object.defineProperty(WebSocket2.prototype, `on${method}`, {\n        enumerable: true,\n        get() {\n          for (const listener of this.listeners(method)) {\n            if (listener[kForOnEventAttribute]) return listener[kListener];\n          }\n          return null;\n        },\n        set(handler) {\n          for (const listener of this.listeners(method)) {\n            if (listener[kForOnEventAttribute]) {\n              this.removeListener(method, listener);\n              break;\n            }\n          }\n          if (typeof handler !== \"function\") return;\n          this.addEventListener(method, handler, {\n            [kForOnEventAttribute]: true\n          });\n        }\n      });\n    });\n    WebSocket2.prototype.addEventListener = addEventListener;\n    WebSocket2.prototype.removeEventListener = removeEventListener;\n    module.exports = WebSocket2;\n    function initAsClient(websocket, address, protocols, options) {\n      const opts = {\n        allowSynchronousEvents: true,\n        autoPong: true,\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        skipUTF8Validation: false,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        socketPath: void 0,\n        hostname: void 0,\n        protocol: void 0,\n        timeout: void 0,\n        method: \"GET\",\n        host: void 0,\n        path: void 0,\n        port: void 0\n      };\n      websocket._autoPong = opts.autoPong;\n      if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(\n          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`\n        );\n      }\n      let parsedUrl;\n      if (address instanceof URL) {\n        parsedUrl = address;\n      } else {\n        try {\n          parsedUrl = new URL(address);\n        } catch (e) {\n          throw new SyntaxError(`Invalid URL: ${address}`);\n        }\n      }\n      if (parsedUrl.protocol === \"http:\") {\n        parsedUrl.protocol = \"ws:\";\n      } else if (parsedUrl.protocol === \"https:\") {\n        parsedUrl.protocol = \"wss:\";\n      }\n      websocket._url = parsedUrl.href;\n      const isSecure = parsedUrl.protocol === \"wss:\";\n      const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n      let invalidUrlMessage;\n      if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n        invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https\", or \"ws+unix:\"`;\n      } else if (isIpcUrl && !parsedUrl.pathname) {\n        invalidUrlMessage = \"The URL's pathname is empty\";\n      } else if (parsedUrl.hash) {\n        invalidUrlMessage = \"The URL contains a fragment identifier\";\n      }\n      if (invalidUrlMessage) {\n        const err = new SyntaxError(invalidUrlMessage);\n        if (websocket._redirects === 0) {\n          throw err;\n        } else {\n          emitErrorAndClose(websocket, err);\n          return;\n        }\n      }\n      const defaultPort = isSecure ? 443 : 80;\n      const key = randomBytes(16).toString(\"base64\");\n      const request = isSecure ? https.request : http.request;\n      const protocolSet = /* @__PURE__ */ new Set();\n      let perMessageDeflate;\n      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n      opts.defaultPort = opts.defaultPort || defaultPort;\n      opts.port = parsedUrl.port || defaultPort;\n      opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n      opts.headers = {\n        ...opts.headers,\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\"\n      };\n      opts.path = parsedUrl.pathname + parsedUrl.search;\n      opts.timeout = opts.handshakeTimeout;\n      if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(\n          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n          false,\n          opts.maxPayload\n        );\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n      }\n      if (protocols.length) {\n        for (const protocol of protocols) {\n          if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n            throw new SyntaxError(\n              \"An invalid or duplicated subprotocol was specified\"\n            );\n          }\n          protocolSet.add(protocol);\n        }\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n      }\n      if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n          opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n          opts.headers.Origin = opts.origin;\n        }\n      }\n      if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n      }\n      if (isIpcUrl) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n      }\n      let req;\n      if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n          websocket._originalIpc = isIpcUrl;\n          websocket._originalSecure = isSecure;\n          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n          const headers = options && options.headers;\n          options = { ...options, headers: {} };\n          if (headers) {\n            for (const [key2, value] of Object.entries(headers)) {\n              options.headers[key2.toLowerCase()] = value;\n            }\n          }\n        } else if (websocket.listenerCount(\"redirect\") === 0) {\n          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n          if (!isSameHost || websocket._originalSecure && !isSecure) {\n            delete opts.headers.authorization;\n            delete opts.headers.cookie;\n            if (!isSameHost) delete opts.headers.host;\n            opts.auth = void 0;\n          }\n        }\n        if (opts.auth && !options.headers.authorization) {\n          options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n        req = websocket._req = request(opts);\n        if (websocket._redirects) {\n          websocket.emit(\"redirect\", websocket.url, req);\n        }\n      } else {\n        req = websocket._req = request(opts);\n      }\n      if (opts.timeout) {\n        req.on(\"timeout\", () => {\n          abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n      }\n      req.on(\"error\", (err) => {\n        if (req === null || req[kAborted]) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n      });\n      req.on(\"response\", (res) => {\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n          if (++websocket._redirects > opts.maxRedirects) {\n            abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n            return;\n          }\n          req.abort();\n          let addr;\n          try {\n            addr = new URL(location, address);\n          } catch (e) {\n            const err = new SyntaxError(`Invalid URL: ${location}`);\n            emitErrorAndClose(websocket, err);\n            return;\n          }\n          initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n          abortHandshake(\n            websocket,\n            req,\n            `Unexpected server response: ${res.statusCode}`\n          );\n        }\n      });\n      req.on(\"upgrade\", (res, socket, head) => {\n        websocket.emit(\"upgrade\", res);\n        if (websocket.readyState !== WebSocket2.CONNECTING) return;\n        req = websocket._req = null;\n        const upgrade = res.headers.upgrade;\n        if (upgrade === void 0 || upgrade.toLowerCase() !== \"websocket\") {\n          abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n          return;\n        }\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n          abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n          return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        let protError;\n        if (serverProt !== void 0) {\n          if (!protocolSet.size) {\n            protError = \"Server sent a subprotocol but none was requested\";\n          } else if (!protocolSet.has(serverProt)) {\n            protError = \"Server sent an invalid subprotocol\";\n          }\n        } else if (protocolSet.size) {\n          protError = \"Server sent no subprotocol\";\n        }\n        if (protError) {\n          abortHandshake(websocket, socket, protError);\n          return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== void 0) {\n          if (!perMessageDeflate) {\n            const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          let extensions;\n          try {\n            extensions = parse(secWebSocketExtensions);\n          } catch (err) {\n            const message = \"Invalid Sec-WebSocket-Extensions header\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          const extensionNames = Object.keys(extensions);\n          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n            const message = \"Server indicated an extension that was not requested\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          try {\n            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          } catch (err) {\n            const message = \"Invalid Sec-WebSocket-Extensions header\";\n            abortHandshake(websocket, socket, message);\n            return;\n          }\n          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n        websocket.setSocket(socket, head, {\n          allowSynchronousEvents: opts.allowSynchronousEvents,\n          generateMask: opts.generateMask,\n          maxPayload: opts.maxPayload,\n          skipUTF8Validation: opts.skipUTF8Validation\n        });\n      });\n      if (opts.finishRequest) {\n        opts.finishRequest(req, websocket);\n      } else {\n        req.end();\n      }\n    }\n    function emitErrorAndClose(websocket, err) {\n      websocket._readyState = WebSocket2.CLOSING;\n      websocket._errorEmitted = true;\n      websocket.emit(\"error\", err);\n      websocket.emitClose();\n    }\n    function netConnect(options) {\n      options.path = options.socketPath;\n      return net.connect(options);\n    }\n    function tlsConnect(options) {\n      options.path = void 0;\n      if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n      }\n      return tls.connect(options);\n    }\n    function abortHandshake(websocket, stream, message) {\n      websocket._readyState = WebSocket2.CLOSING;\n      const err = new Error(message);\n      Error.captureStackTrace(err, abortHandshake);\n      if (stream.setHeader) {\n        stream[kAborted] = true;\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n          stream.socket.destroy();\n        }\n        process.nextTick(emitErrorAndClose, websocket, err);\n      } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n      }\n    }\n    function sendAfterClose(websocket, data, cb) {\n      if (data) {\n        const length = isBlob(data) ? data.size : toBuffer(data).length;\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n      }\n      if (cb) {\n        const err = new Error(\n          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`\n        );\n        process.nextTick(cb, err);\n      }\n    }\n    function receiverOnConclude(code, reason) {\n      const websocket = this[kWebSocket];\n      websocket._closeFrameReceived = true;\n      websocket._closeMessage = reason;\n      websocket._closeCode = code;\n      if (websocket._socket[kWebSocket] === void 0) return;\n      websocket._socket.removeListener(\"data\", socketOnData);\n      process.nextTick(resume, websocket._socket);\n      if (code === 1005) websocket.close();\n      else websocket.close(code, reason);\n    }\n    function receiverOnDrain() {\n      const websocket = this[kWebSocket];\n      if (!websocket.isPaused) websocket._socket.resume();\n    }\n    function receiverOnError(err) {\n      const websocket = this[kWebSocket];\n      if (websocket._socket[kWebSocket] !== void 0) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n      }\n      if (!websocket._errorEmitted) {\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n      }\n    }\n    function receiverOnFinish() {\n      this[kWebSocket].emitClose();\n    }\n    function receiverOnMessage(data, isBinary) {\n      this[kWebSocket].emit(\"message\", data, isBinary);\n    }\n    function receiverOnPing(data) {\n      const websocket = this[kWebSocket];\n      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n      websocket.emit(\"ping\", data);\n    }\n    function receiverOnPong(data) {\n      this[kWebSocket].emit(\"pong\", data);\n    }\n    function resume(stream) {\n      stream.resume();\n    }\n    function senderOnError(err) {\n      const websocket = this[kWebSocket];\n      if (websocket.readyState === WebSocket2.CLOSED) return;\n      if (websocket.readyState === WebSocket2.OPEN) {\n        websocket._readyState = WebSocket2.CLOSING;\n        setCloseTimer(websocket);\n      }\n      this._socket.end();\n      if (!websocket._errorEmitted) {\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n      }\n    }\n    function setCloseTimer(websocket) {\n      websocket._closeTimer = setTimeout(\n        websocket._socket.destroy.bind(websocket._socket),\n        closeTimeout\n      );\n    }\n    function socketOnClose() {\n      const websocket = this[kWebSocket];\n      this.removeListener(\"close\", socketOnClose);\n      this.removeListener(\"data\", socketOnData);\n      this.removeListener(\"end\", socketOnEnd);\n      websocket._readyState = WebSocket2.CLOSING;\n      let chunk;\n      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n        websocket._receiver.write(chunk);\n      }\n      websocket._receiver.end();\n      this[kWebSocket] = void 0;\n      clearTimeout(websocket._closeTimer);\n      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n      } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n      }\n    }\n    function socketOnData(chunk) {\n      if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n      }\n    }\n    function socketOnEnd() {\n      const websocket = this[kWebSocket];\n      websocket._readyState = WebSocket2.CLOSING;\n      websocket._receiver.end();\n      this.end();\n    }\n    function socketOnError() {\n      const websocket = this[kWebSocket];\n      this.removeListener(\"error\", socketOnError);\n      this.on(\"error\", NOOP);\n      if (websocket) {\n        websocket._readyState = WebSocket2.CLOSING;\n        this.destroy();\n      }\n    }\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/subprotocol.js\nvar require_subprotocol = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/subprotocol.js\"(exports, module) {\n    \"use strict\";\n    var { tokenChars } = require_validation();\n    function parse(header) {\n      const protocols = /* @__PURE__ */ new Set();\n      let start = -1;\n      let end = -1;\n      let i = 0;\n      for (i; i < header.length; i++) {\n        const code = header.charCodeAt(i);\n        if (end === -1 && tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (i !== 0 && (code === 32 || code === 9)) {\n          if (end === -1 && start !== -1) end = i;\n        } else if (code === 44) {\n          if (start === -1) {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n          if (end === -1) end = i;\n          const protocol2 = header.slice(start, end);\n          if (protocols.has(protocol2)) {\n            throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n          }\n          protocols.add(protocol2);\n          start = end = -1;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      }\n      if (start === -1 || end !== -1) {\n        throw new SyntaxError(\"Unexpected end of input\");\n      }\n      const protocol = header.slice(start, i);\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol);\n      return protocols;\n    }\n    module.exports = { parse };\n  }\n});\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/websocket-server.js\nvar require_websocket_server = __commonJS({\n  \"../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/lib/websocket-server.js\"(exports, module) {\n    \"use strict\";\n    var EventEmitter = __require(\"events\");\n    var http = __require(\"http\");\n    var { Duplex } = __require(\"stream\");\n    var { createHash } = __require(\"crypto\");\n    var extension = require_extension();\n    var PerMessageDeflate = require_permessage_deflate();\n    var subprotocol = require_subprotocol();\n    var WebSocket2 = require_websocket();\n    var { GUID, kWebSocket } = require_constants();\n    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n    var RUNNING = 0;\n    var CLOSING = 1;\n    var CLOSED = 2;\n    var WebSocketServer2 = class extends EventEmitter {\n      /**\n       * Create a `WebSocketServer` instance.\n       *\n       * @param {Object} options Configuration options\n       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n       *     multiple times in the same tick\n       * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n       *     automatically send a pong in response to a ping\n       * @param {Number} [options.backlog=511] The maximum length of the queue of\n       *     pending connections\n       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n       *     track clients\n       * @param {Function} [options.handleProtocols] A hook to handle protocols\n       * @param {String} [options.host] The hostname where to bind the server\n       * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n       *     size\n       * @param {Boolean} [options.noServer=false] Enable no server mode\n       * @param {String} [options.path] Accept only connections matching this path\n       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n       *     permessage-deflate\n       * @param {Number} [options.port] The port where to bind the server\n       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n       *     server to use\n       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n       *     not to skip UTF-8 validation for text and close messages\n       * @param {Function} [options.verifyClient] A hook to reject connections\n       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n       *     class to use. It must be the `WebSocket` class or class that extends it\n       * @param {Function} [callback] A listener for the `listening` event\n       */\n      constructor(options, callback) {\n        super();\n        options = {\n          allowSynchronousEvents: true,\n          autoPong: true,\n          maxPayload: 100 * 1024 * 1024,\n          skipUTF8Validation: false,\n          perMessageDeflate: false,\n          handleProtocols: null,\n          clientTracking: true,\n          verifyClient: null,\n          noServer: false,\n          backlog: null,\n          // use default (511 as implemented in net.js)\n          server: null,\n          host: null,\n          path: null,\n          port: null,\n          WebSocket: WebSocket2,\n          ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n          throw new TypeError(\n            'One and only one of the \"port\", \"server\", or \"noServer\" options must be specified'\n          );\n        }\n        if (options.port != null) {\n          this._server = http.createServer((req, res) => {\n            const body = http.STATUS_CODES[426];\n            res.writeHead(426, {\n              \"Content-Length\": body.length,\n              \"Content-Type\": \"text/plain\"\n            });\n            res.end(body);\n          });\n          this._server.listen(\n            options.port,\n            options.host,\n            options.backlog,\n            callback\n          );\n        } else if (options.server) {\n          this._server = options.server;\n        }\n        if (this._server) {\n          const emitConnection = this.emit.bind(this, \"connection\");\n          this._removeListeners = addListeners(this._server, {\n            listening: this.emit.bind(this, \"listening\"),\n            error: this.emit.bind(this, \"error\"),\n            upgrade: (req, socket, head) => {\n              this.handleUpgrade(req, socket, head, emitConnection);\n            }\n          });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) {\n          this.clients = /* @__PURE__ */ new Set();\n          this._shouldEmitClose = false;\n        }\n        this.options = options;\n        this._state = RUNNING;\n      }\n      /**\n       * Returns the bound address, the address family name, and port of the server\n       * as reported by the operating system if listening on an IP socket.\n       * If the server is listening on a pipe or UNIX domain socket, the name is\n       * returned as a string.\n       *\n       * @return {(Object|String|null)} The address of the server\n       * @public\n       */\n      address() {\n        if (this.options.noServer) {\n          throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n      }\n      /**\n       * Stop the server from accepting new connections and emit the `'close'` event\n       * when all existing connections are closed.\n       *\n       * @param {Function} [cb] A one-time listener for the `'close'` event\n       * @public\n       */\n      close(cb) {\n        if (this._state === CLOSED) {\n          if (cb) {\n            this.once(\"close\", () => {\n              cb(new Error(\"The server is not running\"));\n            });\n          }\n          process.nextTick(emitClose, this);\n          return;\n        }\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        if (this.options.noServer || this.options.server) {\n          if (this._server) {\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n          }\n          if (this.clients) {\n            if (!this.clients.size) {\n              process.nextTick(emitClose, this);\n            } else {\n              this._shouldEmitClose = true;\n            }\n          } else {\n            process.nextTick(emitClose, this);\n          }\n        } else {\n          const server = this._server;\n          this._removeListeners();\n          this._removeListeners = this._server = null;\n          server.close(() => {\n            emitClose(this);\n          });\n        }\n      }\n      /**\n       * See if a given request should be handled by this server instance.\n       *\n       * @param {http.IncomingMessage} req Request object to inspect\n       * @return {Boolean} `true` if the request is valid, else `false`\n       * @public\n       */\n      shouldHandle(req) {\n        if (this.options.path) {\n          const index = req.url.indexOf(\"?\");\n          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n          if (pathname !== this.options.path) return false;\n        }\n        return true;\n      }\n      /**\n       * Handle a HTTP Upgrade request.\n       *\n       * @param {http.IncomingMessage} req The request object\n       * @param {Duplex} socket The network socket between the server and client\n       * @param {Buffer} head The first packet of the upgraded stream\n       * @param {Function} cb Callback\n       * @public\n       */\n      handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"];\n        const upgrade = req.headers.upgrade;\n        const version = +req.headers[\"sec-websocket-version\"];\n        if (req.method !== \"GET\") {\n          const message = \"Invalid HTTP method\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n          return;\n        }\n        if (upgrade === void 0 || upgrade.toLowerCase() !== \"websocket\") {\n          const message = \"Invalid Upgrade header\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n          return;\n        }\n        if (key === void 0 || !keyRegex.test(key)) {\n          const message = \"Missing or invalid Sec-WebSocket-Key header\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n          return;\n        }\n        if (version !== 8 && version !== 13) {\n          const message = \"Missing or invalid Sec-WebSocket-Version header\";\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n          return;\n        }\n        if (!this.shouldHandle(req)) {\n          abortHandshake(socket, 400);\n          return;\n        }\n        const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n        let protocols = /* @__PURE__ */ new Set();\n        if (secWebSocketProtocol !== void 0) {\n          try {\n            protocols = subprotocol.parse(secWebSocketProtocol);\n          } catch (err) {\n            const message = \"Invalid Sec-WebSocket-Protocol header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n          }\n        }\n        const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n        const extensions = {};\n        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n          const perMessageDeflate = new PerMessageDeflate(\n            this.options.perMessageDeflate,\n            true,\n            this.options.maxPayload\n          );\n          try {\n            const offers = extension.parse(secWebSocketExtensions);\n            if (offers[PerMessageDeflate.extensionName]) {\n              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n            }\n          } catch (err) {\n            const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n          }\n        }\n        if (this.options.verifyClient) {\n          const info = {\n            origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n            secure: !!(req.socket.authorized || req.socket.encrypted),\n            req\n          };\n          if (this.options.verifyClient.length === 2) {\n            this.options.verifyClient(info, (verified, code, message, headers) => {\n              if (!verified) {\n                return abortHandshake(socket, code || 401, message, headers);\n              }\n              this.completeUpgrade(\n                extensions,\n                key,\n                protocols,\n                req,\n                socket,\n                head,\n                cb\n              );\n            });\n            return;\n          }\n          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n      }\n      /**\n       * Upgrade the connection to WebSocket.\n       *\n       * @param {Object} extensions The accepted extensions\n       * @param {String} key The value of the `Sec-WebSocket-Key` header\n       * @param {Set} protocols The subprotocols\n       * @param {http.IncomingMessage} req The request object\n       * @param {Duplex} socket The network socket between the server and client\n       * @param {Buffer} head The first packet of the upgraded stream\n       * @param {Function} cb Callback\n       * @throws {Error} If called more than once with the same socket\n       * @private\n       */\n      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n          throw new Error(\n            \"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\"\n          );\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n          \"HTTP/1.1 101 Switching Protocols\",\n          \"Upgrade: websocket\",\n          \"Connection: Upgrade\",\n          `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new this.options.WebSocket(null, void 0, this.options);\n        if (protocols.size) {\n          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n          if (protocol) {\n            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n            ws._protocol = protocol;\n          }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n          const params = extensions[PerMessageDeflate.extensionName].params;\n          const value = extension.format({\n            [PerMessageDeflate.extensionName]: [params]\n          });\n          headers.push(`Sec-WebSocket-Extensions: ${value}`);\n          ws._extensions = extensions;\n        }\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, {\n          allowSynchronousEvents: this.options.allowSynchronousEvents,\n          maxPayload: this.options.maxPayload,\n          skipUTF8Validation: this.options.skipUTF8Validation\n        });\n        if (this.clients) {\n          this.clients.add(ws);\n          ws.on(\"close\", () => {\n            this.clients.delete(ws);\n            if (this._shouldEmitClose && !this.clients.size) {\n              process.nextTick(emitClose, this);\n            }\n          });\n        }\n        cb(ws, req);\n      }\n    };\n    module.exports = WebSocketServer2;\n    function addListeners(server, map) {\n      for (const event of Object.keys(map)) server.on(event, map[event]);\n      return function removeListeners() {\n        for (const event of Object.keys(map)) {\n          server.removeListener(event, map[event]);\n        }\n      };\n    }\n    function emitClose(server) {\n      server._state = CLOSED;\n      server.emit(\"close\");\n    }\n    function socketOnError() {\n      this.destroy();\n    }\n    function abortHandshake(socket, code, message, headers) {\n      message = message || http.STATUS_CODES[code];\n      headers = {\n        Connection: \"close\",\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": Buffer.byteLength(message),\n        ...headers\n      };\n      socket.once(\"finish\", socket.destroy);\n      socket.end(\n        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message\n      );\n    }\n    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n      if (server.listenerCount(\"wsClientError\")) {\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n        server.emit(\"wsClientError\", err, socket, req);\n      } else {\n        abortHandshake(socket, code, message);\n      }\n    }\n  }\n});\n\n// src/browser/simple_client-node.ts\nimport {\n  ConvexClient,\n  setDefaultWebSocketConstructor\n} from \"./simple_client.js\";\n\n// ../common/temp/node_modules/.pnpm/ws@8.18.0_bufferutil@4.0.9/node_modules/ws/wrapper.mjs\nvar import_stream = __toESM(require_stream(), 1);\nvar import_receiver = __toESM(require_receiver(), 1);\nvar import_sender = __toESM(require_sender(), 1);\nvar import_websocket = __toESM(require_websocket(), 1);\nvar import_websocket_server = __toESM(require_websocket_server(), 1);\nvar wrapper_default = import_websocket.default;\n\n// src/browser/simple_client-node.ts\nvar nodeWebSocket = wrapper_default;\nsetDefaultWebSocketConstructor(nodeWebSocket);\nexport {\n  ConvexClient\n};\n//# sourceMappingURL=simple_client-node.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport {\n  getFunctionName\n} from \"../server/api.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport {\n  ConvexError,\n  convexToJson,\n  jsonToConvex\n} from \"../values/index.js\";\nimport {\n  instantiateDefaultLogger,\n  instantiateNoopLogger,\n  logForFunction\n} from \"./logging.js\";\nexport const STATUS_CODE_OK = 200;\nexport const STATUS_CODE_BAD_REQUEST = 400;\nexport const STATUS_CODE_UDF_FAILED = 560;\nlet specifiedFetch = void 0;\nexport function setFetch(f) {\n  specifiedFetch = f;\n}\nexport class ConvexHttpClient {\n  /**\n   * Create a new {@link ConvexHttpClient}.\n   *\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param options - An object of options.\n   * - `skipConvexDeploymentUrlCheck` - Skip validating that the Convex deployment URL looks like\n   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted\n   * Convex backend that uses a different URL.\n   * - `logger` - A logger or a boolean. If not provided, logs to the console.\n   * You can construct your own logger to customize logging to log elsewhere\n   * or not log at all, or use `false` as a shorthand for a no-op logger.\n   * A logger is an object with 4 methods: log(), warn(), error(), and logVerbose().\n   * These methods can receive multiple arguments of any types, like console.log().\n   * - `auth` - A JWT containing identity claims accessible in Convex functions.\n   * This identity may expire so it may be necessary to call `setAuth()` later,\n   * but for short-lived clients it's convenient to specify this value here.\n   * - `fetch` - A custom fetch implementation to use for all HTTP requests made by this client.\n   */\n  constructor(address, options) {\n    __publicField(this, \"address\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"adminAuth\");\n    __publicField(this, \"encodedTsPromise\");\n    __publicField(this, \"debug\");\n    __publicField(this, \"fetchOptions\");\n    __publicField(this, \"fetch\");\n    __publicField(this, \"logger\");\n    __publicField(this, \"mutationQueue\", []);\n    __publicField(this, \"isProcessingQueue\", false);\n    if (typeof options === \"boolean\") {\n      throw new Error(\n        \"skipConvexDeploymentUrlCheck as the second argument is no longer supported. Please pass an options object, `{ skipConvexDeploymentUrlCheck: true }`.\"\n      );\n    }\n    const opts = options ?? {};\n    if (opts.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    this.logger = options?.logger === false ? instantiateNoopLogger({ verbose: false }) : options?.logger !== true && options?.logger ? options.logger : instantiateDefaultLogger({ verbose: false });\n    this.address = address;\n    this.debug = true;\n    this.auth = void 0;\n    this.adminAuth = void 0;\n    this.fetch = options?.fetch;\n    if (options?.auth) {\n      this.setAuth(options.auth);\n    }\n  }\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   * @deprecated Use url, which returns the url without /api at the end.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl() {\n    return `${this.address}/api`;\n  }\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value) {\n    this.clearAuth();\n    this.auth = value;\n  }\n  /**\n   * Set admin auth token to allow calling internal queries, mutations, and actions\n   * and acting as an identity.\n   *\n   * @internal\n   */\n  setAdminAuth(token, actingAsIdentity) {\n    this.clearAuth();\n    if (actingAsIdentity !== void 0) {\n      const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));\n      const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));\n      this.adminAuth = `${token}:${actingAsIdentityEncoded}`;\n    } else {\n      this.adminAuth = token;\n    }\n  }\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = void 0;\n    this.adminAuth = void 0;\n  }\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug) {\n    this.debug = debug;\n  }\n  /**\n   * Used to customize the fetch behavior in some runtimes.\n   *\n   * @internal\n   */\n  setFetchOptions(fetchOptions) {\n    this.fetchOptions = fetchOptions;\n  }\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Execute a Convex query function at the same timestamp as every other\n   * consistent query execution run by this HTTP client.\n   *\n   * This doesn't make sense for long-lived ConvexHttpClients as Convex\n   * backends can read a limited amount into the past: beyond 30 seconds\n   * in the past may not be available.\n   *\n   * Create a new client to use a consistent time.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   *\n   * @deprecated This API is experimental: it may change or disappear.\n   */\n  async consistentQuery(query, ...args) {\n    const queryArgs = parseArgs(args[0]);\n    const timestampPromise = this.getTimestamp();\n    return await this.queryInner(query, queryArgs, { timestampPromise });\n  }\n  async getTimestamp() {\n    if (this.encodedTsPromise) {\n      return this.encodedTsPromise;\n    }\n    return this.encodedTsPromise = this.getTimestampInner();\n  }\n  async getTimestampInner() {\n    const localFetch = this.fetch || specifiedFetch || fetch;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    const response = await localFetch(`${this.address}/api/query_ts`, {\n      ...this.fetchOptions,\n      method: \"POST\",\n      headers\n    });\n    if (!response.ok) {\n      throw new Error(await response.text());\n    }\n    const { ts } = await response.json();\n    return ts;\n  }\n  /**\n   * Execute a Convex query function.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  async query(query, ...args) {\n    const queryArgs = parseArgs(args[0]);\n    return await this.queryInner(query, queryArgs, {});\n  }\n  async queryInner(query, queryArgs, options) {\n    const name = getFunctionName(query);\n    const args = [convexToJson(queryArgs)];\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = this.fetch || specifiedFetch || fetch;\n    const timestamp = options.timestampPromise ? await options.timestampPromise : void 0;\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args,\n      ...timestamp ? { ts: timestamp } : {}\n    });\n    const endpoint = timestamp ? `${this.address}/api/query_at_ts` : `${this.address}/api/query`;\n    const response = await localFetch(endpoint, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logForFunction(this.logger, \"info\", \"query\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage)\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n  async mutationInner(mutation, mutationArgs) {\n    const name = getFunctionName(mutation);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(mutationArgs)]\n    });\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = this.fetch || specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/mutation`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logForFunction(this.logger, \"info\", \"mutation\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage)\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n  async processMutationQueue() {\n    if (this.isProcessingQueue) {\n      return;\n    }\n    this.isProcessingQueue = true;\n    while (this.mutationQueue.length > 0) {\n      const { mutation, args, resolve, reject } = this.mutationQueue.shift();\n      try {\n        const result = await this.mutationInner(mutation, args);\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    }\n    this.isProcessingQueue = false;\n  }\n  enqueueMutation(mutation, args) {\n    return new Promise((resolve, reject) => {\n      this.mutationQueue.push({ mutation, args, resolve, reject });\n      void this.processMutationQueue();\n    });\n  }\n  /**\n   * Execute a Convex mutation function. Mutations are queued by default.\n   *\n   * @param name - The name of the mutation.\n   * @param args - The arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - An optional object containing\n   * @returns A promise of the mutation's result.\n   */\n  async mutation(mutation, ...args) {\n    const [fnArgs, options] = args;\n    const mutationArgs = parseArgs(fnArgs);\n    const queued = !options?.skipQueue;\n    if (queued) {\n      return await this.enqueueMutation(mutation, mutationArgs);\n    } else {\n      return await this.mutationInner(mutation, mutationArgs);\n    }\n  }\n  /**\n   * Execute a Convex action function. Actions are not queued.\n   *\n   * @param name - The name of the action.\n   * @param args - The arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action(action, ...args) {\n    const actionArgs = parseArgs(args[0]);\n    const name = getFunctionName(action);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(actionArgs)]\n    });\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = this.fetch || specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/action`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logForFunction(this.logger, \"info\", \"action\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage)\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n  /**\n   * Execute a Convex function of an unknown type. These function calls are not queued.\n   *\n   * @param name - The name of the function.\n   * @param args - The arguments object for the function. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the function's result.\n   *\n   * @internal\n   */\n  async function(anyFunction, componentPath, ...args) {\n    const functionArgs = parseArgs(args[0]);\n    const name = typeof anyFunction === \"string\" ? anyFunction : getFunctionName(anyFunction);\n    const body = JSON.stringify({\n      componentPath,\n      path: name,\n      format: \"convex_encoded_json\",\n      args: convexToJson(functionArgs)\n    });\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = this.fetch || specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/function`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logForFunction(this.logger, \"info\", \"any\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage)\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n}\nfunction forwardErrorData(errorData, error) {\n  error.data = jsonToConvex(errorData);\n  return error;\n}\n//# sourceMappingURL=http_client.js.map\n","\"use strict\";\nexport { BaseConvexClient } from \"./sync/client.js\";\nexport { ConvexClient } from \"./simple_client.js\";\nexport { ConvexHttpClient } from \"./http_client.js\";\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport {\n  serializePaginatedPathAndArgs,\n  canonicalizeUdfPath\n} from \"./udf_path_utils.js\";\nimport {\n  asPaginationResult\n} from \"./pagination.js\";\nimport { Long } from \"../../vendor/long.js\";\nexport class PaginatedQueryClient {\n  constructor(client, onTransition) {\n    this.client = client;\n    this.onTransition = onTransition;\n    __publicField(this, \"paginatedQuerySet\", /* @__PURE__ */ new Map());\n    // hold onto a real Transition so we can construct synthetic ones with that timestamp\n    __publicField(this, \"lastTransitionTs\");\n    this.lastTransitionTs = Long.fromNumber(0);\n    this.client.addOnTransitionHandler(\n      (transition) => this.onBaseTransition(transition)\n    );\n  }\n  /**\n   * Subscribe to a paginated query.\n   *\n   * @param name - The name of the paginated query function\n   * @param args - Arguments for the query (excluding paginationOpts)\n   * @param options - Pagination options including initialNumItems\n   * @returns Object with paginatedQueryToken and unsubscribe function\n   */\n  subscribe(name, args, options) {\n    const canonicalizedUdfPath = canonicalizeUdfPath(name);\n    const token = serializePaginatedPathAndArgs(\n      canonicalizedUdfPath,\n      args,\n      options\n    );\n    const unsubscribe = () => this.removePaginatedQuerySubscriber(token);\n    const existingEntry = this.paginatedQuerySet.get(token);\n    if (existingEntry) {\n      existingEntry.numSubscribers += 1;\n      return {\n        paginatedQueryToken: token,\n        unsubscribe\n      };\n    }\n    this.paginatedQuerySet.set(token, {\n      token,\n      canonicalizedUdfPath,\n      args,\n      numSubscribers: 1,\n      options: { initialNumItems: options.initialNumItems },\n      nextPageKey: 0,\n      pageKeys: [],\n      pageKeyToQuery: /* @__PURE__ */ new Map(),\n      ongoingSplits: /* @__PURE__ */ new Map(),\n      skip: false,\n      id: options.id\n    });\n    this.addPageToPaginatedQuery(token, null, options.initialNumItems);\n    return {\n      paginatedQueryToken: token,\n      unsubscribe\n    };\n  }\n  /**\n   * Get current results for a paginated query based on local state.\n   *\n   * Throws an error when one of the pages has errored.\n   */\n  localQueryResult(name, args, options) {\n    const canonicalizedUdfPath = canonicalizeUdfPath(name);\n    const token = serializePaginatedPathAndArgs(\n      canonicalizedUdfPath,\n      args,\n      options\n    );\n    return this.localQueryResultByToken(token);\n  }\n  /**\n   * @internal\n   */\n  localQueryResultByToken(token) {\n    const paginatedQuery = this.paginatedQuerySet.get(token);\n    if (!paginatedQuery) {\n      return void 0;\n    }\n    const activePages = this.activePageQueryTokens(paginatedQuery);\n    if (activePages.length === 0) {\n      return {\n        results: [],\n        status: \"LoadingFirstPage\",\n        loadMore: (numItems) => {\n          return this.loadMoreOfPaginatedQuery(token, numItems);\n        }\n      };\n    }\n    let allResults = [];\n    let hasUndefined = false;\n    let isDone = false;\n    for (const pageToken of activePages) {\n      const result = this.client.localQueryResultByToken(pageToken);\n      if (result === void 0) {\n        hasUndefined = true;\n        isDone = false;\n        continue;\n      }\n      const paginationResult = asPaginationResult(result);\n      allResults = allResults.concat(paginationResult.page);\n      isDone = !!paginationResult.isDone;\n    }\n    let status;\n    if (hasUndefined) {\n      status = allResults.length === 0 ? \"LoadingFirstPage\" : \"LoadingMore\";\n    } else if (isDone) {\n      status = \"Exhausted\";\n    } else {\n      status = \"CanLoadMore\";\n    }\n    return {\n      results: allResults,\n      status,\n      loadMore: (numItems) => {\n        return this.loadMoreOfPaginatedQuery(token, numItems);\n      }\n    };\n  }\n  onBaseTransition(transition) {\n    const changedBaseTokens = transition.queries.map((q) => q.token);\n    const changed = this.queriesContainingTokens(changedBaseTokens);\n    let paginatedQueries = [];\n    if (changed.length > 0) {\n      this.processPaginatedQuerySplits(\n        changed,\n        (token) => this.client.localQueryResultByToken(token)\n      );\n      paginatedQueries = changed.map((token) => ({\n        token,\n        modification: {\n          kind: \"Updated\",\n          result: this.localQueryResultByToken(token)\n        }\n      }));\n    }\n    const extendedTransition = {\n      ...transition,\n      paginatedQueries\n    };\n    this.onTransition(extendedTransition);\n  }\n  /**\n   * Load more items for a paginated query.\n   *\n   * This *always* causes a transition, the status of the query\n   * has probably changed from \"CanLoadMore\" to \"LoadingMore\".\n   * Data might have changed too: maybe a subscription to this page\n   * query already exists (unlikely but possible) or this page query\n   * has an optimistic update providing some initial data.\n   *\n   * @internal\n   */\n  loadMoreOfPaginatedQuery(token, numItems) {\n    this.mustGetPaginatedQuery(token);\n    const lastPageToken = this.queryTokenForLastPageOfPaginatedQuery(token);\n    const lastPageResult = this.client.localQueryResultByToken(lastPageToken);\n    if (!lastPageResult) {\n      return false;\n    }\n    const paginationResult = asPaginationResult(lastPageResult);\n    if (paginationResult.isDone) {\n      return false;\n    }\n    this.addPageToPaginatedQuery(\n      token,\n      paginationResult.continueCursor,\n      numItems\n    );\n    const loadMoreTransition = {\n      timestamp: this.lastTransitionTs,\n      reflectedMutations: [],\n      queries: [],\n      paginatedQueries: [\n        {\n          token,\n          modification: {\n            kind: \"Updated\",\n            result: this.localQueryResultByToken(token)\n          }\n        }\n      ]\n    };\n    this.onTransition(loadMoreTransition);\n    return true;\n  }\n  /**\n   * @internal\n   */\n  queriesContainingTokens(queryTokens) {\n    if (queryTokens.length === 0) {\n      return [];\n    }\n    const changed = [];\n    const queryTokenSet = new Set(queryTokens);\n    for (const [paginatedToken, paginatedQuery] of this.paginatedQuerySet) {\n      for (const pageToken of this.allQueryTokens(paginatedQuery)) {\n        if (queryTokenSet.has(pageToken)) {\n          changed.push(paginatedToken);\n          break;\n        }\n      }\n    }\n    return changed;\n  }\n  /**\n   * @internal\n   */\n  processPaginatedQuerySplits(changed, getResult) {\n    for (const paginatedQueryToken of changed) {\n      const paginatedQuery = this.mustGetPaginatedQuery(paginatedQueryToken);\n      const { ongoingSplits, pageKeyToQuery, pageKeys } = paginatedQuery;\n      for (const [pageKey, [splitKey1, splitKey2]] of ongoingSplits) {\n        const bothNewPagesLoaded = getResult(pageKeyToQuery.get(splitKey1).queryToken) !== void 0 && getResult(pageKeyToQuery.get(splitKey2).queryToken) !== void 0;\n        if (bothNewPagesLoaded) {\n          this.completePaginatedQuerySplit(\n            paginatedQuery,\n            pageKey,\n            splitKey1,\n            splitKey2\n          );\n        }\n      }\n      for (const pageKey of pageKeys) {\n        if (ongoingSplits.has(pageKey)) {\n          continue;\n        }\n        const pageToken = pageKeyToQuery.get(pageKey).queryToken;\n        const pageResult = getResult(pageToken);\n        if (!pageResult) {\n          continue;\n        }\n        const result = asPaginationResult(pageResult);\n        const shouldSplit = result.splitCursor && (result.pageStatus === \"SplitRecommended\" || result.pageStatus === \"SplitRequired\" || // This client-driven page splitting condition will change in the future.\n        result.page.length > paginatedQuery.options.initialNumItems * 2);\n        if (shouldSplit) {\n          this.splitPaginatedQueryPage(\n            paginatedQuery,\n            pageKey,\n            result.splitCursor,\n            // we just checked\n            result.continueCursor\n          );\n        }\n      }\n    }\n  }\n  splitPaginatedQueryPage(paginatedQuery, pageKey, splitCursor, continueCursor) {\n    const splitKey1 = paginatedQuery.nextPageKey++;\n    const splitKey2 = paginatedQuery.nextPageKey++;\n    const paginationOpts = {\n      cursor: continueCursor,\n      numItems: paginatedQuery.options.initialNumItems,\n      id: paginatedQuery.id\n    };\n    const firstSubscription = this.client.subscribe(\n      paginatedQuery.canonicalizedUdfPath,\n      {\n        ...paginatedQuery.args,\n        paginationOpts: {\n          ...paginationOpts,\n          cursor: null,\n          // Start from beginning for first split\n          endCursor: splitCursor\n        }\n      }\n    );\n    paginatedQuery.pageKeyToQuery.set(splitKey1, firstSubscription);\n    const secondSubscription = this.client.subscribe(\n      paginatedQuery.canonicalizedUdfPath,\n      {\n        ...paginatedQuery.args,\n        paginationOpts: {\n          ...paginationOpts,\n          cursor: splitCursor,\n          endCursor: continueCursor\n        }\n      }\n    );\n    paginatedQuery.pageKeyToQuery.set(splitKey2, secondSubscription);\n    paginatedQuery.ongoingSplits.set(pageKey, [splitKey1, splitKey2]);\n  }\n  /**\n   * @internal\n   */\n  addPageToPaginatedQuery(token, continueCursor, numItems) {\n    const paginatedQuery = this.mustGetPaginatedQuery(token);\n    const pageKey = paginatedQuery.nextPageKey++;\n    const paginationOpts = {\n      cursor: continueCursor,\n      numItems,\n      id: paginatedQuery.id\n    };\n    const pageArgs = {\n      ...paginatedQuery.args,\n      paginationOpts\n    };\n    const subscription = this.client.subscribe(\n      paginatedQuery.canonicalizedUdfPath,\n      pageArgs\n    );\n    paginatedQuery.pageKeys.push(pageKey);\n    paginatedQuery.pageKeyToQuery.set(pageKey, subscription);\n    return subscription;\n  }\n  removePaginatedQuerySubscriber(token) {\n    const paginatedQuery = this.paginatedQuerySet.get(token);\n    if (!paginatedQuery) {\n      return;\n    }\n    paginatedQuery.numSubscribers -= 1;\n    if (paginatedQuery.numSubscribers > 0) {\n      return;\n    }\n    for (const subscription of paginatedQuery.pageKeyToQuery.values()) {\n      subscription.unsubscribe();\n    }\n    this.paginatedQuerySet.delete(token);\n  }\n  completePaginatedQuerySplit(paginatedQuery, pageKey, splitKey1, splitKey2) {\n    const originalQuery = paginatedQuery.pageKeyToQuery.get(pageKey);\n    paginatedQuery.pageKeyToQuery.delete(pageKey);\n    const pageIndex = paginatedQuery.pageKeys.indexOf(pageKey);\n    paginatedQuery.pageKeys.splice(pageIndex, 1, splitKey1, splitKey2);\n    paginatedQuery.ongoingSplits.delete(pageKey);\n    originalQuery.unsubscribe();\n  }\n  /** The query tokens for all active pages, in result order */\n  activePageQueryTokens(paginatedQuery) {\n    return paginatedQuery.pageKeys.map(\n      (pageKey) => paginatedQuery.pageKeyToQuery.get(pageKey).queryToken\n    );\n  }\n  allQueryTokens(paginatedQuery) {\n    return Array.from(paginatedQuery.pageKeyToQuery.values()).map(\n      (sub) => sub.queryToken\n    );\n  }\n  queryTokenForLastPageOfPaginatedQuery(token) {\n    const paginatedQuery = this.mustGetPaginatedQuery(token);\n    const lastPageKey = paginatedQuery.pageKeys[paginatedQuery.pageKeys.length - 1];\n    if (lastPageKey === void 0) {\n      throw new Error(`No pages for paginated query ${token}`);\n    }\n    return paginatedQuery.pageKeyToQuery.get(lastPageKey).queryToken;\n  }\n  mustGetPaginatedQuery(token) {\n    const paginatedQuery = this.paginatedQuerySet.get(token);\n    if (!paginatedQuery) {\n      throw new Error(\"paginated query no longer exists for token \" + token);\n    }\n    return paginatedQuery;\n  }\n}\n//# sourceMappingURL=paginated_query_client.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { validateDeploymentUrl } from \"../common/index.js\";\nimport {\n  BaseConvexClient\n} from \"./index.js\";\nimport { getFunctionName } from \"../server/api.js\";\nimport {\n  PaginatedQueryClient\n} from \"./sync/paginated_query_client.js\";\nimport { serializedQueryTokenIsPaginated } from \"./sync/udf_path_utils.js\";\nlet defaultWebSocketConstructor;\nexport function setDefaultWebSocketConstructor(ws) {\n  defaultWebSocketConstructor = ws;\n}\nexport class ConvexClient {\n  /**\n   * Construct a client and immediately initiate a WebSocket connection to the passed address.\n   *\n   * @public\n   */\n  constructor(address, options = {}) {\n    __publicField(this, \"listeners\");\n    __publicField(this, \"_client\");\n    __publicField(this, \"_paginatedClient\");\n    // A synthetic server event to run callbacks the first time\n    __publicField(this, \"callNewListenersWithCurrentValuesTimer\");\n    __publicField(this, \"_closed\");\n    __publicField(this, \"_disabled\");\n    if (options.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    const { disabled, ...baseOptions } = options;\n    this._closed = false;\n    this._disabled = !!disabled;\n    if (defaultWebSocketConstructor && !(\"webSocketConstructor\" in baseOptions) && typeof WebSocket === \"undefined\") {\n      baseOptions.webSocketConstructor = defaultWebSocketConstructor;\n    }\n    if (typeof window === \"undefined\" && !(\"unsavedChangesWarning\" in baseOptions)) {\n      baseOptions.unsavedChangesWarning = false;\n    }\n    if (!this.disabled) {\n      this._client = new BaseConvexClient(\n        address,\n        () => {\n        },\n        // NOP, let the paginated query client do it all\n        baseOptions\n      );\n      this._paginatedClient = new PaginatedQueryClient(\n        this._client,\n        (transition) => this._transition(transition)\n      );\n    }\n    this.listeners = /* @__PURE__ */ new Set();\n  }\n  /**\n   * Once closed no registered callbacks will fire again.\n   */\n  get closed() {\n    return this._closed;\n  }\n  get client() {\n    if (this._client) return this._client;\n    throw new Error(\"ConvexClient is disabled\");\n  }\n  /**\n   * @internal\n   */\n  get paginatedClient() {\n    if (this._paginatedClient) return this._paginatedClient;\n    throw new Error(\"ConvexClient is disabled\");\n  }\n  get disabled() {\n    return this._disabled;\n  }\n  /**\n   * Call a callback whenever a new result for a query is received. The callback\n   * will run soon after being registered if a result for the query is already\n   * in memory.\n   *\n   * The return value is an {@link Unsubscribe} object which is both a function\n   * an an object with properties. Both of the patterns below work with this object:\n   *\n   *```ts\n   * // call the return value as a function\n   * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   * unsubscribe();\n   *\n   * // unpack the return value into its properties\n   * const {\n   *   getCurrentValue,\n   *   unsubscribe,\n   * } = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   *```\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - The arguments to run the query with.\n   * @param callback - Function to call when the query result updates.\n   * @param onError - Function to call when the query result updates with an error.\n   * If not provided, errors will be thrown instead of calling the callback.\n   *\n   * @return an {@link Unsubscribe} function to stop calling the onUpdate function.\n   */\n  onUpdate(query, args, callback, onError) {\n    if (this.disabled) {\n      return this.createDisabledUnsubscribe();\n    }\n    const { queryToken, unsubscribe } = this.client.subscribe(\n      getFunctionName(query),\n      args\n    );\n    const queryInfo = {\n      queryToken,\n      callback,\n      onError,\n      unsubscribe,\n      hasEverRun: false,\n      query,\n      args,\n      paginationOptions: void 0\n    };\n    this.listeners.add(queryInfo);\n    if (this.queryResultReady(queryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) {\n      this.callNewListenersWithCurrentValuesTimer = setTimeout(\n        () => this.callNewListenersWithCurrentValues(),\n        0\n      );\n    }\n    const unsubscribeProps = {\n      unsubscribe: () => {\n        if (this.closed) {\n          return;\n        }\n        this.listeners.delete(queryInfo);\n        unsubscribe();\n      },\n      getCurrentValue: () => this.client.localQueryResultByToken(queryToken),\n      getQueryLogs: () => this.client.localQueryLogs(queryToken)\n    };\n    const ret = unsubscribeProps.unsubscribe;\n    Object.assign(ret, unsubscribeProps);\n    return ret;\n  }\n  /**\n   * Call a callback whenever a new result for a paginated query is received.\n   *\n   * This is an experimental preview: the final API may change.\n   * In particular, caching behavior, page splitting, and required paginated query options\n   * may change.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - The arguments to run the query with.\n   * @param options - Options for the paginated query including initialNumItems and id.\n   * @param callback - Function to call when the query result updates.\n   * @param onError - Function to call when the query result updates with an error.\n   *\n   * @return an {@link Unsubscribe} function to stop calling the callback.\n   */\n  onPaginatedUpdate_experimental(query, args, options, callback, onError) {\n    if (this.disabled) {\n      return this.createDisabledUnsubscribe();\n    }\n    const paginationOptions = {\n      initialNumItems: options.initialNumItems,\n      id: -1\n    };\n    const { paginatedQueryToken, unsubscribe } = this.paginatedClient.subscribe(\n      getFunctionName(query),\n      args,\n      // Simple client doesn't use IDs, there's no expectation that these queries remain separate.\n      paginationOptions\n    );\n    const queryInfo = {\n      queryToken: paginatedQueryToken,\n      callback,\n      onError,\n      unsubscribe,\n      hasEverRun: false,\n      query,\n      args,\n      paginationOptions\n    };\n    this.listeners.add(queryInfo);\n    if (!!this.paginatedClient.localQueryResultByToken(paginatedQueryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) {\n      this.callNewListenersWithCurrentValuesTimer = setTimeout(\n        () => this.callNewListenersWithCurrentValues(),\n        0\n      );\n    }\n    const unsubscribeProps = {\n      unsubscribe: () => {\n        if (this.closed) {\n          return;\n        }\n        this.listeners.delete(queryInfo);\n        unsubscribe();\n      },\n      getCurrentValue: () => {\n        const result = this.paginatedClient.localQueryResult(\n          getFunctionName(query),\n          args,\n          paginationOptions\n        );\n        return result;\n      },\n      getQueryLogs: () => []\n      // Paginated queries don't aggregate their logs\n    };\n    const ret = unsubscribeProps.unsubscribe;\n    Object.assign(ret, unsubscribeProps);\n    return ret;\n  }\n  // Run all callbacks that have never been run before if they have a query\n  // result available now.\n  callNewListenersWithCurrentValues() {\n    this.callNewListenersWithCurrentValuesTimer = void 0;\n    this._transition({ queries: [], paginatedQueries: [] }, true);\n  }\n  queryResultReady(queryToken) {\n    return this.client.hasLocalQueryResultByToken(queryToken);\n  }\n  createDisabledUnsubscribe() {\n    const disabledUnsubscribe = () => {\n    };\n    const unsubscribeProps = {\n      unsubscribe: disabledUnsubscribe,\n      getCurrentValue: () => void 0,\n      getQueryLogs: () => void 0\n    };\n    Object.assign(disabledUnsubscribe, unsubscribeProps);\n    return disabledUnsubscribe;\n  }\n  async close() {\n    if (this.disabled) return;\n    this.listeners.clear();\n    this._closed = true;\n    if (this._paginatedClient) {\n      this._paginatedClient = void 0;\n    }\n    return this.client.close();\n  }\n  /**\n   * Get the current JWT auth token and decoded claims.\n   */\n  getAuth() {\n    if (this.disabled) return;\n    return this.client.getCurrentAuthClaims();\n  }\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT (typically an OpenID Connect Identity Token)\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(fetchToken, onChange) {\n    if (this.disabled) return;\n    this.client.setAuth(\n      fetchToken,\n      onChange ?? (() => {\n      })\n    );\n  }\n  /**\n   * @internal\n   */\n  setAdminAuth(token, identity) {\n    if (this.closed) {\n      throw new Error(\"ConvexClient has already been closed.\");\n    }\n    if (this.disabled) return;\n    this.client.setAdminAuth(token, identity);\n  }\n  /**\n   * @internal\n   */\n  _transition({\n    queries,\n    paginatedQueries\n  }, callNewListeners = false) {\n    const updatedQueries = [\n      ...queries.map((q) => q.token),\n      ...paginatedQueries.map((q) => q.token)\n    ];\n    for (const queryInfo of this.listeners) {\n      const { callback, queryToken, onError, hasEverRun } = queryInfo;\n      const isPaginatedQuery = serializedQueryTokenIsPaginated(queryToken);\n      const hasResultReady = isPaginatedQuery ? !!this.paginatedClient.localQueryResultByToken(queryToken) : this.client.hasLocalQueryResultByToken(queryToken);\n      if (updatedQueries.includes(queryToken) || callNewListeners && !hasEverRun && hasResultReady) {\n        queryInfo.hasEverRun = true;\n        let newValue;\n        try {\n          if (isPaginatedQuery) {\n            newValue = this.paginatedClient.localQueryResultByToken(queryToken);\n          } else {\n            newValue = this.client.localQueryResultByToken(queryToken);\n          }\n        } catch (error) {\n          if (!(error instanceof Error)) throw error;\n          if (onError) {\n            onError(\n              error,\n              \"Second argument to onUpdate onError is reserved for later use\"\n            );\n          } else {\n            void Promise.reject(error);\n          }\n          continue;\n        }\n        callback(\n          newValue,\n          \"Second argument to onUpdate callback is reserved for later use\"\n        );\n      }\n    }\n  }\n  /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation(mutation, args, options) {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return await this.client.mutation(getFunctionName(mutation), args, options);\n  }\n  /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action.\n   * @returns A promise of the action's result.\n   */\n  async action(action, args) {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return await this.client.action(getFunctionName(action), args);\n  }\n  /**\n   * Fetch a query result once.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query.\n   * @returns A promise of the query's result.\n   */\n  async query(query, args) {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    const value = this.client.localQueryResult(getFunctionName(query), args);\n    if (value !== void 0) return Promise.resolve(value);\n    return new Promise((resolve, reject) => {\n      const { unsubscribe } = this.onUpdate(\n        query,\n        args,\n        (value2) => {\n          unsubscribe();\n          resolve(value2);\n        },\n        (e) => {\n          unsubscribe();\n          reject(e);\n        }\n      );\n    });\n  }\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState() {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return this.client.connectionState();\n  }\n  /**\n   * Subscribe to the {@link ConnectionState} between the client and the Convex\n   * backend, calling a callback each time it changes.\n   *\n   * Subscribed callbacks will be called when any part of ConnectionState changes.\n   * ConnectionState may grow in future versions (e.g. to provide a array of\n   * inflight requests) in which case callbacks would be called more frequently.\n   *\n   * @returns An unsubscribe function to stop listening.\n   */\n  subscribeToConnectionState(cb) {\n    if (this.disabled) return () => {\n    };\n    return this.client.subscribeToConnectionState(cb);\n  }\n}\n//# sourceMappingURL=simple_client.js.map\n","\"use strict\";\nexport { BaseConvexClient } from \"./sync/client.js\";\nexport { ConvexClient } from \"./simple_client-node.js\";\nexport { ConvexHttpClient } from \"./http_client.js\";\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { convexToJson } from \"./value.js\";\nconst UNDEFINED_VALIDATOR_ERROR_URL = \"https://docs.convex.dev/error#undefined-validator\";\nfunction throwUndefinedValidatorError(context, fieldName) {\n  const fieldInfo = fieldName !== void 0 ? ` for field \"${fieldName}\"` : \"\";\n  throw new Error(\n    `A validator is undefined${fieldInfo} in ${context}. This is often caused by circular imports. See ${UNDEFINED_VALIDATOR_ERROR_URL} for details.`\n  );\n}\nclass BaseValidator {\n  constructor({ isOptional }) {\n    /**\n     * Only for TypeScript, the TS type of the JS values validated\n     * by this validator.\n     */\n    __publicField(this, \"type\");\n    /**\n     * Only for TypeScript, if this an Object validator, then\n     * this is the TS type of its property names.\n     */\n    __publicField(this, \"fieldPaths\");\n    /**\n     * Whether this is an optional Object property value validator.\n     */\n    __publicField(this, \"isOptional\");\n    /**\n     * Always `\"true\"`.\n     */\n    __publicField(this, \"isConvexValidator\");\n    this.isOptional = isOptional;\n    this.isConvexValidator = true;\n  }\n}\nexport class VId extends BaseValidator {\n  /**\n   * Usually you'd use `v.id(tableName)` instead.\n   */\n  constructor({\n    isOptional,\n    tableName\n  }) {\n    super({ isOptional });\n    /**\n     * The name of the table that the validated IDs must belong to.\n     */\n    __publicField(this, \"tableName\");\n    /**\n     * The kind of validator, `\"id\"`.\n     */\n    __publicField(this, \"kind\", \"id\");\n    if (typeof tableName !== \"string\") {\n      throw new Error(\"v.id(tableName) requires a string\");\n    }\n    this.tableName = tableName;\n  }\n  /** @internal */\n  get json() {\n    return { type: \"id\", tableName: this.tableName };\n  }\n  /** @internal */\n  asOptional() {\n    return new VId({\n      isOptional: \"optional\",\n      tableName: this.tableName\n    });\n  }\n}\nexport class VFloat64 extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"float64\"`.\n     */\n    __publicField(this, \"kind\", \"float64\");\n  }\n  /** @internal */\n  get json() {\n    return { type: \"number\" };\n  }\n  /** @internal */\n  asOptional() {\n    return new VFloat64({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VInt64 extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"int64\"`.\n     */\n    __publicField(this, \"kind\", \"int64\");\n  }\n  /** @internal */\n  get json() {\n    return { type: \"bigint\" };\n  }\n  /** @internal */\n  asOptional() {\n    return new VInt64({ isOptional: \"optional\" });\n  }\n}\nexport class VBoolean extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"boolean\"`.\n     */\n    __publicField(this, \"kind\", \"boolean\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VBoolean({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VBytes extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"bytes\"`.\n     */\n    __publicField(this, \"kind\", \"bytes\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VBytes({ isOptional: \"optional\" });\n  }\n}\nexport class VString extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"string\"`.\n     */\n    __publicField(this, \"kind\", \"string\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VString({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VNull extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"null\"`.\n     */\n    __publicField(this, \"kind\", \"null\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VNull({ isOptional: \"optional\" });\n  }\n}\nexport class VAny extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"any\"`.\n     */\n    __publicField(this, \"kind\", \"any\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VAny({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VObject extends BaseValidator {\n  /**\n   * Usually you'd use `v.object({ ... })` instead.\n   */\n  constructor({\n    isOptional,\n    fields\n  }) {\n    super({ isOptional });\n    /**\n     * An object with the validator for each property.\n     */\n    __publicField(this, \"fields\");\n    /**\n     * The kind of validator, `\"object\"`.\n     */\n    __publicField(this, \"kind\", \"object\");\n    globalThis.Object.entries(fields).forEach(([fieldName, validator]) => {\n      if (validator === void 0) {\n        throwUndefinedValidatorError(\"v.object()\", fieldName);\n      }\n      if (!validator.isConvexValidator) {\n        throw new Error(\"v.object() entries must be validators\");\n      }\n    });\n    this.fields = fields;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: globalThis.Object.fromEntries(\n        globalThis.Object.entries(this.fields).map(([k, v]) => [\n          k,\n          {\n            fieldType: v.json,\n            optional: v.isOptional === \"optional\" ? true : false\n          }\n        ])\n      )\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VObject({\n      isOptional: \"optional\",\n      fields: this.fields\n    });\n  }\n  /**\n   * Create a new VObject with the specified fields omitted.\n   * @param fields The field names to omit from this VObject.\n   */\n  omit(...fields) {\n    const newFields = { ...this.fields };\n    for (const field of fields) {\n      delete newFields[field];\n    }\n    return new VObject({\n      isOptional: this.isOptional,\n      fields: newFields\n    });\n  }\n  /**\n   * Create a new VObject with only the specified fields.\n   * @param fields The field names to pick from this VObject.\n   */\n  pick(...fields) {\n    const newFields = {};\n    for (const field of fields) {\n      newFields[field] = this.fields[field];\n    }\n    return new VObject({\n      isOptional: this.isOptional,\n      fields: newFields\n    });\n  }\n  /**\n   * Create a new VObject with all fields marked as optional.\n   */\n  partial() {\n    const newFields = {};\n    for (const [key, validator] of globalThis.Object.entries(this.fields)) {\n      newFields[key] = validator.asOptional();\n    }\n    return new VObject({\n      isOptional: this.isOptional,\n      fields: newFields\n    });\n  }\n  /**\n   * Create a new VObject with additional fields merged in.\n   * @param fields An object with additional validators to merge into this VObject.\n   */\n  extend(fields) {\n    return new VObject({\n      isOptional: this.isOptional,\n      fields: { ...this.fields, ...fields }\n    });\n  }\n}\nexport class VLiteral extends BaseValidator {\n  /**\n   * Usually you'd use `v.literal(value)` instead.\n   */\n  constructor({ isOptional, value }) {\n    super({ isOptional });\n    /**\n     * The value that the validated values must be equal to.\n     */\n    __publicField(this, \"value\");\n    /**\n     * The kind of validator, `\"literal\"`.\n     */\n    __publicField(this, \"kind\", \"literal\");\n    if (typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\" && typeof value !== \"bigint\") {\n      throw new Error(\"v.literal(value) must be a string, number, or boolean\");\n    }\n    this.value = value;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: convexToJson(this.value)\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VLiteral({\n      isOptional: \"optional\",\n      value: this.value\n    });\n  }\n}\nexport class VArray extends BaseValidator {\n  /**\n   * Usually you'd use `v.array(element)` instead.\n   */\n  constructor({\n    isOptional,\n    element\n  }) {\n    super({ isOptional });\n    /**\n     * The validator for the elements of the array.\n     */\n    __publicField(this, \"element\");\n    /**\n     * The kind of validator, `\"array\"`.\n     */\n    __publicField(this, \"kind\", \"array\");\n    if (element === void 0) {\n      throwUndefinedValidatorError(\"v.array()\");\n    }\n    this.element = element;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: this.element.json\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VArray({\n      isOptional: \"optional\",\n      element: this.element\n    });\n  }\n}\nexport class VRecord extends BaseValidator {\n  /**\n   * Usually you'd use `v.record(key, value)` instead.\n   */\n  constructor({\n    isOptional,\n    key,\n    value\n  }) {\n    super({ isOptional });\n    /**\n     * The validator for the keys of the record.\n     */\n    __publicField(this, \"key\");\n    /**\n     * The validator for the values of the record.\n     */\n    __publicField(this, \"value\");\n    /**\n     * The kind of validator, `\"record\"`.\n     */\n    __publicField(this, \"kind\", \"record\");\n    if (key === void 0) {\n      throwUndefinedValidatorError(\"v.record()\", \"key\");\n    }\n    if (value === void 0) {\n      throwUndefinedValidatorError(\"v.record()\", \"value\");\n    }\n    if (key.isOptional === \"optional\") {\n      throw new Error(\"Record validator cannot have optional keys\");\n    }\n    if (value.isOptional === \"optional\") {\n      throw new Error(\"Record validator cannot have optional values\");\n    }\n    if (!key.isConvexValidator || !value.isConvexValidator) {\n      throw new Error(\"Key and value of v.record() but be validators\");\n    }\n    this.key = key;\n    this.value = value;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      // This cast is needed because TypeScript thinks the key type is too wide\n      keys: this.key.json,\n      values: {\n        fieldType: this.value.json,\n        optional: false\n      }\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VRecord({\n      isOptional: \"optional\",\n      key: this.key,\n      value: this.value\n    });\n  }\n}\nexport class VUnion extends BaseValidator {\n  /**\n   * Usually you'd use `v.union(...members)` instead.\n   */\n  constructor({ isOptional, members }) {\n    super({ isOptional });\n    /**\n     * The array of validators, one of which must match the value.\n     */\n    __publicField(this, \"members\");\n    /**\n     * The kind of validator, `\"union\"`.\n     */\n    __publicField(this, \"kind\", \"union\");\n    members.forEach((member, index) => {\n      if (member === void 0) {\n        throwUndefinedValidatorError(\"v.union()\", `member at index ${index}`);\n      }\n      if (!member.isConvexValidator) {\n        throw new Error(\"All members of v.union() must be validators\");\n      }\n    });\n    this.members = members;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: this.members.map((v) => v.json)\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VUnion({\n      isOptional: \"optional\",\n      members: this.members\n    });\n  }\n}\n//# sourceMappingURL=validators.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class SearchFilter {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isSearchFilter\");\n  }\n}\n//# sourceMappingURL=search_filter_builder.js.map\n","\"use strict\";\nconst markNames = [\n  \"convexClientConstructed\",\n  \"convexWebSocketOpen\",\n  \"convexFirstMessageReceived\"\n];\nexport function mark(name, sessionId) {\n  const detail = { sessionId };\n  if (typeof performance === \"undefined\" || !performance.mark) return;\n  performance.mark(name, { detail });\n}\nfunction performanceMarkToJson(mark2) {\n  let name = mark2.name.slice(\"convex\".length);\n  name = name.charAt(0).toLowerCase() + name.slice(1);\n  return {\n    name,\n    startTime: mark2.startTime\n  };\n}\nexport function getMarksReport(sessionId) {\n  if (typeof performance === \"undefined\" || !performance.getEntriesByName) {\n    return [];\n  }\n  const allMarks = [];\n  for (const name of markNames) {\n    const marks = performance.getEntriesByName(name).filter((entry) => entry.entryType === \"mark\").filter((mark2) => mark2.detail.sessionId === sessionId);\n    allMarks.push(...marks);\n  }\n  return allMarks.map(performanceMarkToJson);\n}\n//# sourceMappingURL=metrics.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class IndexRange {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isIndexRange\");\n  }\n}\n//# sourceMappingURL=index_range_builder.js.map\n","\"use strict\";\nvar lookup = [];\nvar revLookup = [];\nvar Arr = Uint8Array;\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n}\nexport function byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(_b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nexport function toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0;\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 255;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  return arr;\n}\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n}\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\nexport function fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3;\n  var parts = [];\n  var maxChunkLength = 16383;\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(\n      encodeChunk(\n        uint8,\n        i,\n        i + maxChunkLength > len2 ? len2 : i + maxChunkLength\n      )\n    );\n  }\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n    );\n  }\n  return parts.join(\"\");\n}\nexport function fromByteArrayUrlSafeNoPadding(uint8) {\n  return fromByteArray(uint8).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n//# sourceMappingURL=base64.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst INFO_COLOR = \"color:rgb(0, 145, 255)\";\nfunction prefix_for_source(source) {\n  switch (source) {\n    case \"query\":\n      return \"Q\";\n    case \"mutation\":\n      return \"M\";\n    case \"action\":\n      return \"A\";\n    case \"any\":\n      return \"?\";\n  }\n}\nexport class DefaultLogger {\n  constructor(options) {\n    __publicField(this, \"_onLogLineFuncs\");\n    __publicField(this, \"_verbose\");\n    this._onLogLineFuncs = {};\n    this._verbose = options.verbose;\n  }\n  addLogLineListener(func) {\n    let id = Math.random().toString(36).substring(2, 15);\n    for (let i = 0; i < 10; i++) {\n      if (this._onLogLineFuncs[id] === void 0) {\n        break;\n      }\n      id = Math.random().toString(36).substring(2, 15);\n    }\n    this._onLogLineFuncs[id] = func;\n    return () => {\n      delete this._onLogLineFuncs[id];\n    };\n  }\n  logVerbose(...args) {\n    if (this._verbose) {\n      for (const func of Object.values(this._onLogLineFuncs)) {\n        func(\"debug\", `${(/* @__PURE__ */ new Date()).toISOString()}`, ...args);\n      }\n    }\n  }\n  log(...args) {\n    for (const func of Object.values(this._onLogLineFuncs)) {\n      func(\"info\", ...args);\n    }\n  }\n  warn(...args) {\n    for (const func of Object.values(this._onLogLineFuncs)) {\n      func(\"warn\", ...args);\n    }\n  }\n  error(...args) {\n    for (const func of Object.values(this._onLogLineFuncs)) {\n      func(\"error\", ...args);\n    }\n  }\n}\nexport function instantiateDefaultLogger(options) {\n  const logger = new DefaultLogger(options);\n  logger.addLogLineListener((level, ...args) => {\n    switch (level) {\n      case \"debug\":\n        console.debug(...args);\n        break;\n      case \"info\":\n        console.log(...args);\n        break;\n      case \"warn\":\n        console.warn(...args);\n        break;\n      case \"error\":\n        console.error(...args);\n        break;\n      default: {\n        level;\n        console.log(...args);\n      }\n    }\n  });\n  return logger;\n}\nexport function instantiateNoopLogger(options) {\n  return new DefaultLogger(options);\n}\nexport function logForFunction(logger, type, source, udfPath, message) {\n  const prefix = prefix_for_source(source);\n  if (typeof message === \"object\") {\n    message = `ConvexError ${JSON.stringify(message.errorData, null, 2)}`;\n  }\n  if (type === \"info\") {\n    const match = message.match(/^\\[.*?\\] /);\n    if (match === null) {\n      logger.error(\n        `[CONVEX ${prefix}(${udfPath})] Could not parse console.log`\n      );\n      return;\n    }\n    const level = message.slice(1, match[0].length - 2);\n    const args = message.slice(match[0].length);\n    logger.log(`%c[CONVEX ${prefix}(${udfPath})] [${level}]`, INFO_COLOR, args);\n  } else {\n    logger.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);\n  }\n}\nexport function logFatalError(logger, message) {\n  const errorMessage = `[CONVEX FATAL ERROR] ${message}`;\n  logger.error(errorMessage);\n  return new Error(errorMessage);\n}\nexport function createHybridErrorStacktrace(source, udfPath, result) {\n  const prefix = prefix_for_source(source);\n  return `[CONVEX ${prefix}(${udfPath})] ${result.errorMessage}\n  Called by client`;\n}\nexport function forwardData(result, error) {\n  error.data = result.errorData;\n  return error;\n}\n//# sourceMappingURL=logging.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class Expression {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isExpression\");\n    // Property to distinguish expressions by the type they resolve to.\n    __publicField(this, \"_value\");\n  }\n}\n//# sourceMappingURL=filter_builder.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class FilterExpression {\n  /**\n   * @internal\n   */\n  constructor() {\n    // Property for nominal type support.\n    __publicField(this, \"_isExpression\");\n    // Property to distinguish expressions by the type they resolve to.\n    __publicField(this, \"_value\");\n  }\n}\n//# sourceMappingURL=vector_search.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nexport class Long {\n  constructor(low, high) {\n    __publicField(this, \"low\");\n    __publicField(this, \"high\");\n    __publicField(this, \"__isUnsignedLong__\");\n    this.low = low | 0;\n    this.high = high | 0;\n    this.__isUnsignedLong__ = true;\n  }\n  static isLong(obj) {\n    return (obj && obj.__isUnsignedLong__) === true;\n  }\n  // prettier-ignore\n  static fromBytesLE(bytes) {\n    return new Long(\n      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,\n      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24\n    );\n  }\n  // prettier-ignore\n  toBytesLE() {\n    const hi = this.high;\n    const lo = this.low;\n    return [\n      lo & 255,\n      lo >>> 8 & 255,\n      lo >>> 16 & 255,\n      lo >>> 24,\n      hi & 255,\n      hi >>> 8 & 255,\n      hi >>> 16 & 255,\n      hi >>> 24\n    ];\n  }\n  static fromNumber(value) {\n    if (isNaN(value)) return UZERO;\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);\n  }\n  toString() {\n    return (BigInt(this.high) * BigInt(TWO_PWR_32_DBL) + BigInt(this.low)).toString();\n  }\n  equals(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  }\n  notEquals(other) {\n    return !this.equals(other);\n  }\n  comp(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.equals(other)) return 0;\n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n  }\n  lessThanOrEqual(other) {\n    return this.comp(\n      /* validates */\n      other\n    ) <= 0;\n  }\n  static fromValue(val) {\n    if (typeof val === \"number\") return Long.fromNumber(val);\n    return new Long(val.low, val.high);\n  }\n}\nconst UZERO = new Long(0, 0);\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst MAX_UNSIGNED_VALUE = new Long(4294967295 | 0, 4294967295 | 0);\n//# sourceMappingURL=long.js.map\n","\"use strict\";\nexport function asPaginationArgs(value) {\n  if (typeof value.paginationOpts.numItems !== \"number\") {\n    throw new Error(`Not valid paginated query args: ${JSON.stringify(value)}`);\n  }\n  return value;\n}\nexport function asPaginationResult(value) {\n  if (typeof value !== \"object\" || value === null || !Array.isArray(value.page) || typeof value.isDone !== \"boolean\" || typeof value.continueCursor !== \"string\") {\n    throw new Error(`Not a valid paginated query result: ${value?.toString()}`);\n  }\n  return value;\n}\n//# sourceMappingURL=pagination.js.map\n","\"use strict\";\nexport function compareUTF8(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const length = Math.min(aLength, bLength);\n  for (let i = 0; i < length; ) {\n    const aCodePoint = a.codePointAt(i);\n    const bCodePoint = b.codePointAt(i);\n    if (aCodePoint !== bCodePoint) {\n      if (aCodePoint < 128 && bCodePoint < 128) {\n        return aCodePoint - bCodePoint;\n      }\n      const aLength2 = utf8Bytes(aCodePoint, aBytes);\n      const bLength2 = utf8Bytes(bCodePoint, bBytes);\n      return compareArrays(aBytes, aLength2, bBytes, bLength2);\n    }\n    i += utf16LengthForCodePoint(aCodePoint);\n  }\n  return aLength - bLength;\n}\nfunction compareArrays(a, aLength, b, bLength) {\n  const length = Math.min(aLength, bLength);\n  for (let i = 0; i < length; i++) {\n    const aValue = a[i];\n    const bValue = b[i];\n    if (aValue !== bValue) {\n      return aValue - bValue;\n    }\n  }\n  return aLength - bLength;\n}\nexport function utf16LengthForCodePoint(aCodePoint) {\n  return aCodePoint > 65535 ? 2 : 1;\n}\nconst arr = () => Array.from({ length: 4 }, () => 0);\nconst aBytes = arr();\nconst bBytes = arr();\nfunction utf8Bytes(codePoint, bytes) {\n  if (codePoint < 128) {\n    bytes[0] = codePoint;\n    return 1;\n  }\n  let count;\n  let offset;\n  if (codePoint <= 2047) {\n    count = 1;\n    offset = 192;\n  } else if (codePoint <= 65535) {\n    count = 2;\n    offset = 224;\n  } else if (codePoint <= 1114111) {\n    count = 3;\n    offset = 240;\n  } else {\n    throw new Error(\"Invalid code point\");\n  }\n  bytes[0] = (codePoint >> 6 * count) + offset;\n  let i = 1;\n  for (; count > 0; count--) {\n    const temp = codePoint >> 6 * (count - 1);\n    bytes[i++] = 128 | temp & 63;\n  }\n  return i;\n}\nexport function greaterThan(a, b) {\n  return compareUTF8(a, b) > 0;\n}\nexport function greaterThanEq(a, b) {\n  return compareUTF8(a, b) >= 0;\n}\nexport function lessThan(a, b) {\n  return compareUTF8(a, b) < 0;\n}\nexport function lessThanEq(a, b) {\n  return compareUTF8(a, b) <= 0;\n}\n//# sourceMappingURL=compare_utf8.js.map\n","\"use strict\";\nexport const version = \"1.31.2\";\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nexport const functionName = Symbol.for(\"functionName\");\n//# sourceMappingURL=functionName.js.map\n","\"use strict\";\nexport function newSessionId() {\n  return uuidv4();\n}\nfunction uuidv4() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 3 | 8;\n    return v.toString(16);\n  });\n}\n//# sourceMappingURL=session.js.map\n","\"use strict\";\nexport class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(\n    atob(str).replace(/(.)/g, (_m, p) => {\n      let code = p.charCodeAt(0).toString(16).toUpperCase();\n      if (code.length < 2) {\n        code = \"0\" + code;\n      }\n      return \"%\" + code;\n    })\n  );\n}\nfunction base64UrlDecode(str) {\n  let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += \"==\";\n      break;\n    case 3:\n      output += \"=\";\n      break;\n    default:\n      throw new Error(\"base64 string is not of the correct length\");\n  }\n  try {\n    return b64DecodeUnicode(output);\n  } catch {\n    return atob(output);\n  }\n}\nexport function jwtDecode(token, options) {\n  if (typeof token !== \"string\") {\n    throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n  }\n  options || (options = {});\n  const pos = options.header === true ? 0 : 1;\n  const part = token.split(\".\")[pos];\n  if (typeof part !== \"string\") {\n    throw new InvalidTokenError(\n      `Invalid token specified: missing part #${pos + 1}`\n    );\n  }\n  let decoded;\n  try {\n    decoded = base64UrlDecode(part);\n  } catch (e) {\n    throw new InvalidTokenError(\n      `Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`\n    );\n  }\n  try {\n    return JSON.parse(decoded);\n  } catch (e) {\n    throw new InvalidTokenError(\n      `Invalid token specified: invalid json for part #${pos + 1} (${e.message})`\n    );\n  }\n}\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nexport function parseArgs(args) {\n  if (args === void 0) {\n    return {};\n  }\n  if (!isSimpleObject(args)) {\n    throw new Error(\n      `The arguments to a Convex function must be an object. Received: ${args}`\n    );\n  }\n  return args;\n}\nexport function validateDeploymentUrl(deploymentUrl) {\n  if (typeof deploymentUrl === \"undefined\") {\n    throw new Error(\n      `Client created with undefined deployment address. If you used an environment variable, check that it's set.`\n    );\n  }\n  if (typeof deploymentUrl !== \"string\") {\n    throw new Error(\n      `Invalid deployment address: found ${deploymentUrl}\".`\n    );\n  }\n  if (!(deploymentUrl.startsWith(\"http:\") || deploymentUrl.startsWith(\"https:\"))) {\n    throw new Error(\n      `Invalid deployment address: Must start with \"https://\" or \"http://\". Found \"${deploymentUrl}\".`\n    );\n  }\n  try {\n    new URL(deploymentUrl);\n  } catch {\n    throw new Error(\n      `Invalid deployment address: \"${deploymentUrl}\" is not a valid URL. If you believe this URL is correct, use the \\`skipConvexDeploymentUrlCheck\\` option to bypass this.`\n    );\n  }\n  if (deploymentUrl.endsWith(\".convex.site\")) {\n    throw new Error(\n      `Invalid deployment address: \"${deploymentUrl}\" ends with .convex.site, which is used for HTTP Actions. Convex deployment URLs typically end with .convex.cloud? If you believe this URL is correct, use the \\`skipConvexDeploymentUrlCheck\\` option to bypass this.`\n    );\n  }\n}\nexport function isSimpleObject(value) {\n  const isObject = typeof value === \"object\";\n  const prototype = Object.getPrototypeOf(value);\n  const isSimple = prototype === null || prototype === Object.prototype || // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous\n  // conditions but are still simple objects.\n  prototype?.constructor?.name === \"Object\";\n  return isObject && isSimple;\n}\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nexport function validateArg(arg, idx, method, argName) {\n  if (arg === void 0) {\n    throw new TypeError(\n      `Must provide arg ${idx} \\`${argName}\\` to \\`${method}\\``\n    );\n  }\n}\nexport function validateArgIsInteger(arg, idx, method, argName) {\n  if (!Number.isInteger(arg)) {\n    throw new TypeError(\n      `Arg ${idx} \\`${argName}\\` to \\`${method}\\` must be an integer`\n    );\n  }\n}\nexport function validateArgIsNonNegativeInteger(arg, idx, method, argName) {\n  if (!Number.isInteger(arg) || arg < 0) {\n    throw new TypeError(\n      `Arg ${idx} \\`${argName}\\` to \\`${method}\\` must be a non-negative integer`\n    );\n  }\n}\n//# sourceMappingURL=validate.js.map\n","import { ConvexHttpClient } from \"convex/browser\";\n\n/**\n * Lightweight Convex HTTP client for server-side routes.\n * Throws with a clear message if the deployment URL is not configured.\n */\nexport function getConvexClient() {\n\tconst url = process.env.NEXT_PUBLIC_CONVEX_URL;\n\tif (!url) {\n\t\tthrow new Error(\n\t\t\t\"NEXT_PUBLIC_CONVEX_URL is missing. Add it to your environment to use public pay links.\"\n\t\t);\n\t}\n\treturn new ConvexHttpClient(url);\n}\n","/* eslint-disable */\n/**\n * Generated `api` utility.\n *\n * THIS CODE IS AUTOMATICALLY GENERATED.\n *\n * To regenerate, run `npx convex dev`.\n * @module\n */\n\nimport { anyApi, componentsGeneric } from \"convex/server\";\n\n/**\n * A utility for referencing Convex functions in your app's API.\n *\n * Usage:\n * ```js\n * const myFunctionReference = api.myModule.myFunction;\n * ```\n */\nexport const api = anyApi;\nexport const internal = anyApi;\nexport const components = componentsGeneric();\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]}