{"version":3,"sources":["../../../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../../../node_modules/next/src/server/lib/trace/constants.ts","../../../../../../node_modules/next/src/shared/lib/is-thenable.ts","../../../../../../node_modules/next/src/server/lib/trace/tracer.ts","../../../../../../node_modules/next/src/lib/detached-promise.ts","../../../../../../node_modules/next/src/server/stream-utils/encoded-tags.ts","../../../../../../node_modules/next/src/server/stream-utils/uint8array-helpers.ts","../../../../../../node_modules/next/src/shared/lib/errors/constants.ts","../../../../../../node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","../../../../../../node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","../../../../../../node_modules/next/src/server/stream-utils/node-web-streams-helper.ts","../../../../../../node_modules/next/src/server/app-render/encryption-utils.ts","../../../../../../node_modules/next/src/server/app-render/encryption.ts","../../../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../../../node_modules/%40clerk/nextjs/src/server/keyless-custom-headers.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/\n\n// eslint typescript has a bug with TS enums\n\nenum BaseServerSpan {\n  handleRequest = 'BaseServer.handleRequest',\n  run = 'BaseServer.run',\n  pipe = 'BaseServer.pipe',\n  getStaticHTML = 'BaseServer.getStaticHTML',\n  render = 'BaseServer.render',\n  renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',\n  renderToResponse = 'BaseServer.renderToResponse',\n  renderToHTML = 'BaseServer.renderToHTML',\n  renderError = 'BaseServer.renderError',\n  renderErrorToResponse = 'BaseServer.renderErrorToResponse',\n  renderErrorToHTML = 'BaseServer.renderErrorToHTML',\n  render404 = 'BaseServer.render404',\n}\n\nenum LoadComponentsSpan {\n  loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',\n  loadComponents = 'LoadComponents.loadComponents',\n}\n\nenum NextServerSpan {\n  getRequestHandler = 'NextServer.getRequestHandler',\n  getRequestHandlerWithMetadata = 'NextServer.getRequestHandlerWithMetadata',\n  getServer = 'NextServer.getServer',\n  getServerRequestHandler = 'NextServer.getServerRequestHandler',\n  createServer = 'createServer.createServer',\n}\n\nenum NextNodeServerSpan {\n  compression = 'NextNodeServer.compression',\n  getBuildId = 'NextNodeServer.getBuildId',\n  createComponentTree = 'NextNodeServer.createComponentTree',\n  clientComponentLoading = 'NextNodeServer.clientComponentLoading',\n  getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',\n  generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',\n  generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',\n  generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',\n  generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',\n  sendRenderResult = 'NextNodeServer.sendRenderResult',\n  proxyRequest = 'NextNodeServer.proxyRequest',\n  runApi = 'NextNodeServer.runApi',\n  render = 'NextNodeServer.render',\n  renderHTML = 'NextNodeServer.renderHTML',\n  imageOptimizer = 'NextNodeServer.imageOptimizer',\n  getPagePath = 'NextNodeServer.getPagePath',\n  getRoutesManifest = 'NextNodeServer.getRoutesManifest',\n  findPageComponents = 'NextNodeServer.findPageComponents',\n  getFontManifest = 'NextNodeServer.getFontManifest',\n  getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',\n  getRequestHandler = 'NextNodeServer.getRequestHandler',\n  renderToHTML = 'NextNodeServer.renderToHTML',\n  renderError = 'NextNodeServer.renderError',\n  renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',\n  render404 = 'NextNodeServer.render404',\n  startResponse = 'NextNodeServer.startResponse',\n\n  // nested inner span, does not require parent scope name\n  route = 'route',\n  onProxyReq = 'onProxyReq',\n  apiResolver = 'apiResolver',\n  internalFetch = 'internalFetch',\n}\n\nenum StartServerSpan {\n  startServer = 'startServer.startServer',\n}\n\nenum RenderSpan {\n  getServerSideProps = 'Render.getServerSideProps',\n  getStaticProps = 'Render.getStaticProps',\n  renderToString = 'Render.renderToString',\n  renderDocument = 'Render.renderDocument',\n  createBodyResult = 'Render.createBodyResult',\n}\n\nenum AppRenderSpan {\n  renderToString = 'AppRender.renderToString',\n  renderToReadableStream = 'AppRender.renderToReadableStream',\n  getBodyResult = 'AppRender.getBodyResult',\n  fetch = 'AppRender.fetch',\n}\n\nenum RouterSpan {\n  executeRoute = 'Router.executeRoute',\n}\n\nenum NodeSpan {\n  runHandler = 'Node.runHandler',\n}\n\nenum AppRouteRouteHandlersSpan {\n  runHandler = 'AppRouteRouteHandlers.runHandler',\n}\n\nenum ResolveMetadataSpan {\n  generateMetadata = 'ResolveMetadata.generateMetadata',\n  generateViewport = 'ResolveMetadata.generateViewport',\n}\n\nenum MiddlewareSpan {\n  execute = 'Middleware.execute',\n}\n\ntype SpanTypes =\n  | `${BaseServerSpan}`\n  | `${LoadComponentsSpan}`\n  | `${NextServerSpan}`\n  | `${StartServerSpan}`\n  | `${NextNodeServerSpan}`\n  | `${RenderSpan}`\n  | `${RouterSpan}`\n  | `${AppRenderSpan}`\n  | `${NodeSpan}`\n  | `${AppRouteRouteHandlersSpan}`\n  | `${ResolveMetadataSpan}`\n  | `${MiddlewareSpan}`\n\n// This list is used to filter out spans that are not relevant to the user\nexport const NextVanillaSpanAllowlist = new Set([\n  MiddlewareSpan.execute,\n  BaseServerSpan.handleRequest,\n  RenderSpan.getServerSideProps,\n  RenderSpan.getStaticProps,\n  AppRenderSpan.fetch,\n  AppRenderSpan.getBodyResult,\n  RenderSpan.renderDocument,\n  NodeSpan.runHandler,\n  AppRouteRouteHandlersSpan.runHandler,\n  ResolveMetadataSpan.generateMetadata,\n  ResolveMetadataSpan.generateViewport,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.getLayoutOrPageModule,\n  NextNodeServerSpan.startResponse,\n  NextNodeServerSpan.clientComponentLoading,\n])\n\n// These Spans are allowed to be always logged\n// when the otel log prefix env is set\nexport const LogSpanAllowList = new Set([\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.clientComponentLoading,\n])\n\nexport {\n  BaseServerSpan,\n  LoadComponentsSpan,\n  NextServerSpan,\n  NextNodeServerSpan,\n  StartServerSpan,\n  RenderSpan,\n  RouterSpan,\n  AppRenderSpan,\n  NodeSpan,\n  AppRouteRouteHandlersSpan,\n  ResolveMetadataSpan,\n  MiddlewareSpan,\n}\n\nexport type { SpanTypes }\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { FetchEventResult } from '../../web/types'\nimport type { TextMapSetter } from '@opentelemetry/api'\nimport type { SpanTypes } from './constants'\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from 'next/dist/compiled/@opentelemetry/api'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\nconst NEXT_OTEL_PERFORMANCE_PREFIX = process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n\nlet api: typeof import('next/dist/compiled/@opentelemetry/api')\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n} else {\n  try {\n    api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n  } catch (err) {\n    api =\n      require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super()\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== 'object' || error === null) return false\n  return error instanceof BubbledError\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {\n      span.recordException(error)\n      span.setAttribute('error.type', error.name)\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })\n  }\n  span.end()\n}\n\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n  parentSpan?: Span\n  spanName?: string\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>\n  hideSpan?: boolean\n}\n\ninterface NextTracer {\n  getContext(): ContextAPI\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[]\n}\n\ntype NextAttributeNames =\n  | 'next.route'\n  | 'next.page'\n  | 'next.rsc'\n  | 'next.segment'\n  | 'next.span_name'\n  | 'next.span_type'\n  | 'next.clientComponentLoadCount'\ntype OTELAttributeNames = `http.${string}` | `net.${string}`\ntype AttributeNames = NextAttributeNames | OTELAttributeNames\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>()\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId')\nlet lastSpanId = 0\nconst getSpanId = () => lastSpanId++\n\nexport interface ClientTraceDataEntry {\n  key: string\n  value: string\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    })\n  },\n}\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer('next.js', '0.0.1')\n  }\n\n  public getContext(): ContextAPI {\n    return context\n  }\n\n  public getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeContext, entries, clientTraceDataSetter)\n    return entries\n  }\n\n  public getActiveScopeSpan(): Span | undefined {\n    return trace.getSpan(context?.active())\n  }\n\n  public withPropagatedContext<T, C>(\n    carrier: C,\n    fn: () => T,\n    getter?: TextMapGetter<C>\n  ): T {\n    const activeContext = context.active()\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn()\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter)\n    return context.with(remoteContext, fn)\n  }\n\n  // Trace, wrap implementation is inspired by datadog trace implementation\n  // (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(...args: Array<any>) {\n    const [type, fnOrOptions, fnOrEmpty] = args\n\n    // coerce options form overload\n    const {\n      fn,\n      options,\n    }: {\n      fn: (span?: Span, done?: (error?: Error) => any) => T | Promise<T>\n      options: TracerSpanOptions\n    } =\n      typeof fnOrOptions === 'function'\n        ? {\n            fn: fnOrOptions,\n            options: {},\n          }\n        : {\n            fn: fnOrEmpty,\n            options: { ...fnOrOptions },\n          }\n\n    const spanName = options.spanName ?? type\n\n    if (\n      (!NextVanillaSpanAllowlist.has(type) &&\n        process.env.NEXT_OTEL_VERBOSE !== '1') ||\n      options.hideSpan\n    ) {\n      return fn()\n    }\n\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n\n    if (!spanContext) {\n      spanContext = context?.active() ?? ROOT_CONTEXT\n    }\n    // Check if there's already a root span in the store for this trace\n    // We are intentionally not checking whether there is an active context\n    // from outside of nextjs to ensure that we can provide the same level\n    // of telemetry when using a custom server\n    const existingRootSpanId = spanContext.getValue(rootSpanIdKey)\n    const isRootSpan =\n      typeof existingRootSpanId !== 'number' ||\n      !rootSpanAttributesStore.has(existingRootSpanId)\n\n    const spanId = getSpanId()\n\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes,\n    }\n\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>\n      this.getTracerInstance().startActiveSpan(\n        spanName,\n        options,\n        (span: Span) => {\n          let startTime: number | undefined\n          if (\n            NEXT_OTEL_PERFORMANCE_PREFIX &&\n            type &&\n            LogSpanAllowList.has(type)\n          ) {\n            startTime =\n              'performance' in globalThis && 'measure' in performance\n                ? globalThis.performance.now()\n                : undefined\n          }\n\n          let cleanedUp = false\n          const onCleanup = () => {\n            if (cleanedUp) return\n            cleanedUp = true\n            rootSpanAttributesStore.delete(spanId)\n            if (startTime) {\n              performance.measure(\n                `${NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(\n                  type.split('.').pop() || ''\n                ).replace(\n                  /[A-Z]/g,\n                  (match: string) => '-' + match.toLowerCase()\n                )}`,\n                {\n                  start: startTime,\n                  end: performance.now(),\n                }\n              )\n            }\n          }\n\n          if (isRootSpan) {\n            rootSpanAttributesStore.set(\n              spanId,\n              new Map(\n                Object.entries(options.attributes ?? {}) as [\n                  AttributeNames,\n                  AttributeValue | undefined,\n                ][]\n              )\n            )\n          }\n          if (fn.length > 1) {\n            try {\n              return fn(span, (err) => closeSpanWithError(span, err))\n            } catch (err: any) {\n              closeSpanWithError(span, err)\n              throw err\n            } finally {\n              onCleanup()\n            }\n          }\n\n          try {\n            const result = fn(span)\n            if (isThenable(result)) {\n              // If there's error make sure it throws\n              return result\n                .then((res) => {\n                  span.end()\n                  // Need to pass down the promise result,\n                  // it could be react stream response with error { error, stream }\n                  return res\n                })\n                .catch((err) => {\n                  closeSpanWithError(span, err)\n                  throw err\n                })\n                .finally(onCleanup)\n            } else {\n              span.end()\n              onCleanup()\n            }\n\n            return result\n          } catch (err: any) {\n            closeSpanWithError(span, err)\n            onCleanup()\n            throw err\n          }\n        }\n      )\n    )\n  }\n\n  public wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap(...args: Array<any>) {\n    const tracer = this\n    const [name, options, fn] =\n      args.length === 3 ? args : [args[0], {}, args[1]]\n\n    if (\n      !NextVanillaSpanAllowlist.has(name) &&\n      process.env.NEXT_OTEL_VERBOSE !== '1'\n    ) {\n      return fn\n    }\n\n    return function (this: any) {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb)\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err: any) {\n            done?.(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  public startSpan(type: SpanTypes): Span\n  public startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n  public startSpan(...args: Array<any>): Span {\n    const [type, options]: [string, TracerSpanOptions | undefined] = args as any\n\n    const spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    return this.getTracerInstance().startSpan(type, options, spanContext)\n  }\n\n  private getSpanContext(parentSpan?: Span) {\n    const spanContext = parentSpan\n      ? trace.setSpan(context.active(), parentSpan)\n      : undefined\n\n    return spanContext\n  }\n\n  public getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    return rootSpanAttributesStore.get(spanId)\n  }\n\n  public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    const attributes = rootSpanAttributesStore.get(spanId)\n    if (attributes && !attributes.has(key)) {\n      attributes.set(key, value)\n    }\n  }\n}\n\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl()\n\n  return () => tracer\n})()\n\nexport { getTracer, SpanStatusCode, SpanKind }\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }\n","/**\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\n * `reject` functions on a `Promise`.\n *\n * @see https://tc39.es/proposal-promise-with-resolvers/\n */\nexport class DetachedPromise<T = any> {\n  public readonly resolve: (value: T | PromiseLike<T>) => void\n  public readonly reject: (reason: any) => void\n  public readonly promise: Promise<T>\n\n  constructor() {\n    let resolve: (value: T | PromiseLike<T>) => void\n    let reject: (reason: any) => void\n\n    // Create the promise and assign the resolvers to the object.\n    this.promise = new Promise<T>((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    // We know that resolvers is defined because the Promise constructor runs\n    // synchronously.\n    this.resolve = resolve!\n    this.reject = reject!\n  }\n}\n","export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n  META: {\n    // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n    // <meta name=\"«nxt-icon»\"\n    // This is a special mark that will be replaced by the icon insertion script tag.\n    ICON_MARK: new Uint8Array([\n      60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,\n      116, 45, 105, 99, 111, 110, 194, 187, 34,\n    ]),\n  },\n} as const\n","/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n","export const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS'\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","import type { ReactDOMServerReadableStream } from 'react-dom/server'\nimport { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encoded-tags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from '../../client/components/app-router-headers'\nimport { computeCacheBustingSearchParam } from '../../shared/lib/router/utils/cache-busting-search-param'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // If we have no streams, return an empty stream. This behavior is\n  // intentional as we're now providing the `RenderResult.EMPTY` value.\n  if (streams.length === 0) {\n    return new ReadableStream<T>({\n      start(controller) {\n        controller.close()\n      },\n    })\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport type BufferedTransformOptions = {\n  /**\n   * Flush synchronously once the buffer reaches this many bytes.\n   */\n  readonly maxBufferByteLength?: number\n}\n\nexport function createBufferedTransformStream(\n  options: BufferedTransformOptions = {}\n): TransformStream<Uint8Array, Uint8Array> {\n  const { maxBufferByteLength = Infinity } = options\n\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    try {\n      if (bufferedChunks.length === 0) {\n        return\n      }\n\n      const chunk = new Uint8Array(bufferByteLength)\n      let copiedBytes = 0\n\n      for (let i = 0; i < bufferedChunks.length; i++) {\n        const bufferedChunk = bufferedChunks[i]\n        chunk.set(bufferedChunk, copiedBytes)\n        copiedBytes += bufferedChunk.byteLength\n      }\n      // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n      // and our bufferByteLength to prepare for the next round of buffered chunks\n      bufferedChunks.length = 0\n      bufferByteLength = 0\n      controller.enqueue(chunk)\n    } catch {\n      // If an error occurs while enqueuing, it can't be due to this\n      // transformer. It's most likely caused by the controller having been\n      // errored (for example, if the stream was cancelled).\n    }\n  }\n\n  const scheduleFlush = (controller: TransformStreamDefaultController) => {\n    if (pending) {\n      return\n    }\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        flush(controller)\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      if (bufferByteLength >= maxBufferByteLength) {\n        flush(controller)\n      } else {\n        scheduleFlush(controller)\n      }\n    },\n    flush() {\n      return pending?.promise\n    },\n  })\n}\n\nfunction createPrefetchCommentStream(\n  isBuildTimePrerendering: boolean,\n  buildId: string\n): TransformStream<Uint8Array, Uint8Array> {\n  // Insert an extra comment at the beginning of the HTML document. This must\n  // come after the DOCTYPE, which is inserted by React.\n  //\n  // The first chunk sent by React will contain the doctype. After that, we can\n  // pass through the rest of the chunks as-is.\n  let didTransformFirstChunk = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n        didTransformFirstChunk = true\n        const decoder = new TextDecoder('utf-8', { fatal: true })\n        const chunkStr = decoder.decode(chunk, {\n          stream: true,\n        })\n        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n        controller.enqueue(encoder.encode(updatedChunkStr))\n        return\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: {\n    renderToReadableStream: typeof import('react-dom/server').renderToReadableStream\n  }\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactDOMServerReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createMetadataTransformStream(\n  insert: () => Promise<string> | string\n): TransformStream<Uint8Array, Uint8Array> {\n  let chunkIndex = -1\n  let isMarkRemoved = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      let iconMarkIndex = -1\n      let closedHeadIndex = -1\n      chunkIndex++\n\n      if (isMarkRemoved) {\n        controller.enqueue(chunk)\n        return\n      }\n      let iconMarkLength = 0\n      // Only search for the closed head tag once\n      if (iconMarkIndex === -1) {\n        iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)\n        if (iconMarkIndex === -1) {\n          controller.enqueue(chunk)\n          return\n        } else {\n          // When we found the `<meta name=\"«nxt-icon»\"` tag prefix, we will remove it from the chunk.\n          // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n          iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length\n          // Check if next char is /, this is for xml mode.\n          if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n            iconMarkLength += 2\n          } else {\n            // The last char is `>`\n            iconMarkLength++\n          }\n        }\n      }\n\n      // Check if icon mark is inside <head> tag in the first chunk.\n      if (chunkIndex === 0) {\n        closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (iconMarkIndex !== -1) {\n          // The mark icon is located in the 1st chunk before the head tag.\n          // We do not need to insert the script tag in this case because it's in the head.\n          // Just remove the icon mark from the chunk.\n          if (iconMarkIndex < closedHeadIndex) {\n            const replaced = new Uint8Array(chunk.length - iconMarkLength)\n\n            // Remove the icon mark from the chunk.\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex\n            )\n            chunk = replaced\n          } else {\n            // The icon mark is after the head tag, replace and insert the script tag at that position.\n            const insertion = await insert()\n            const encodedInsertion = encoder.encode(insertion)\n            const insertionLength = encodedInsertion.length\n            const replaced = new Uint8Array(\n              chunk.length - iconMarkLength + insertionLength\n            )\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(encodedInsertion, iconMarkIndex)\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex + insertionLength\n            )\n            chunk = replaced\n          }\n          isMarkRemoved = true\n        }\n        // If there's no icon mark located, it will be handled later when if present in the following chunks.\n      } else {\n        // When it's appeared in the following chunks, we'll need to\n        // remove the mark and then insert the script tag at that position.\n        const insertion = await insert()\n        const encodedInsertion = encoder.encode(insertion)\n        const insertionLength = encodedInsertion.length\n        // Replace the icon mark with the hoist script or empty string.\n        const replaced = new Uint8Array(\n          chunk.length - iconMarkLength + insertionLength\n        )\n        // Set the first part of the chunk, before the icon mark.\n        replaced.set(chunk.subarray(0, iconMarkIndex))\n        // Set the insertion after the icon mark.\n        replaced.set(encodedInsertion, iconMarkIndex)\n\n        // Set the rest of the chunk after the icon mark.\n        replaced.set(\n          chunk.subarray(iconMarkIndex + iconMarkLength),\n          iconMarkIndex + insertionLength\n        )\n        chunk = replaced\n        isMarkRemoved = true\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\nfunction createClientResumeScriptInsertionTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  const segmentPath = '/_full'\n  const cacheBustingHeader = computeCacheBustingSearchParam(\n    '1', //            headers[NEXT_ROUTER_PREFETCH_HEADER]\n    '/_full', //       headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]\n    undefined, //      headers[NEXT_ROUTER_STATE_TREE_HEADER]\n    undefined //       headers[NEXT_URL]\n  )\n  const searchStr = `${NEXT_RSC_UNION_QUERY}=${cacheBustingHeader}`\n  const NEXT_CLIENT_RESUME_SCRIPT = `<script>__NEXT_CLIENT_RESUME=fetch(location.pathname+'?${searchStr}',{credentials:'same-origin',headers:{'${RSC_HEADER}': '1','${NEXT_ROUTER_PREFETCH_HEADER}': '1','${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}': '${segmentPath}'}})</script>`\n\n  let didAlreadyInsert = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (didAlreadyInsert) {\n        // Already inserted the script into the head. Pass through.\n        controller.enqueue(chunk)\n        return\n      }\n      // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n      const headClosingTagIndex = indexOfUint8Array(\n        chunk,\n        ENCODED_TAGS.CLOSED.HEAD\n      )\n\n      if (headClosingTagIndex === -1) {\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        controller.enqueue(chunk)\n        return\n      }\n\n      const encodedInsertion = encoder.encode(NEXT_CLIENT_RESUME_SCRIPT)\n      // Get the total count of the bytes in the chunk and the insertion\n      // e.g.\n      // chunk = <head><meta charset=\"utf-8\"></head>\n      // insertion = <script>...</script>\n      // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n      const insertedHeadContent = new Uint8Array(\n        chunk.length + encodedInsertion.length\n      )\n      // Append the first part of the chunk, before the head tag\n      insertedHeadContent.set(chunk.slice(0, headClosingTagIndex))\n      // Append the server inserted content\n      insertedHeadContent.set(encodedInsertion, headClosingTagIndex)\n      // Append the rest of the chunk\n      insertedHeadContent.set(\n        chunk.slice(headClosingTagIndex),\n        headClosingTagIndex + encodedInsertion.length\n      )\n\n      controller.enqueue(insertedHeadContent)\n      didAlreadyInsert = true\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\nfunction createFlightDataInjectionTransformStream(\n  stream: ReadableStream<Uint8Array>,\n  delayDataUntilFirstHtmlChunk: boolean\n): TransformStream<Uint8Array, Uint8Array> {\n  let htmlStreamFinished = false\n\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  function startOrContinuePulling(\n    controller: TransformStreamDefaultController\n  ) {\n    if (!pull) {\n      pull = startPulling(controller)\n    }\n    return pull\n  }\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    const reader = stream.getReader()\n\n    if (delayDataUntilFirstHtmlChunk) {\n      // NOTE: streaming flush\n      // We are buffering here for the inlined data stream because the\n      // \"shell\" stream might be chunkenized again by the underlying stream\n      // implementation, e.g. with a specific high-water mark. To ensure it's\n      // the safe timing to pipe the data stream, this extra tick is\n      // necessary.\n\n      // We don't start reading until we've left the current Task to ensure\n      // that it's inserted after flushing the shell. Note that this implementation\n      // might get stale if impl details of Fizz change in the future.\n      await atLeastOneTask()\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        // We want to prioritize HTML over RSC data.\n        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n          await atLeastOneTask()\n        }\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    start(controller) {\n      if (!delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    flush(controller) {\n      htmlStreamFinished = true\n      if (donePulling) {\n        return\n      }\n      return startOrContinuePulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: ('html' | 'body')[] = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags\n                .map((c) => `<${c}>`)\n                .join(\n                  missingTags.length > 1 ? ' and ' : ''\n                )} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  isBuildTimePrerendering: boolean\n  buildId: string\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactDOMServerReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    isBuildTimePrerendering,\n    buildId,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML we need to wait for it to resolve before continuing.\n  if (isStaticGeneration) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Add build id comment to start of the HTML document (in export mode)\n    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n\n    // Transform metadata\n    createMetadataTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream\n      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  isBuildTimePrerendering: boolean\n  buildId: string\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport async function continueStaticFallbackPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  // Same as `continueStaticPrerender`, but also inserts an additional script\n  // to instruct the client to start fetching the hydration data as early\n  // as possible.\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the client resume script into the head\n      .pipeThrough(createClientResumeScriptInsertionTransformStream())\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  delayDataUntilFirstHtmlChunk: boolean\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    delayDataUntilFirstHtmlChunk,\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(\n          inlinedDataStream,\n          delayDataUntilFirstHtmlChunk\n        )\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n","import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifestForRsc()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifestForRsc()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","'use server';\n\nimport { headers } from 'next/headers';\n\ninterface MetadataHeaders {\n  nodeVersion?: string;\n  nextVersion?: string;\n  npmConfigUserAgent?: string;\n  userAgent: string;\n  port?: string;\n  host: string;\n  xHost: string;\n  xPort: string;\n  xProtocol: string;\n  xClerkAuthStatus: string;\n  isCI: boolean;\n}\n\n/**\n * Collects metadata from the environment and request headers\n */\nexport async function collectKeylessMetadata(): Promise<MetadataHeaders> {\n  const headerStore = await headers();\n\n  return {\n    nodeVersion: process.version,\n    nextVersion: getNextVersion(),\n    npmConfigUserAgent: process.env.npm_config_user_agent, // eslint-disable-line\n    userAgent: headerStore.get('User-Agent') ?? 'unknown user-agent',\n    port: process.env.PORT, // eslint-disable-line\n    host: headerStore.get('host') ?? 'unknown host',\n    xPort: headerStore.get('x-forwarded-port') ?? 'unknown x-forwarded-port',\n    xHost: headerStore.get('x-forwarded-host') ?? 'unknown x-forwarded-host',\n    xProtocol: headerStore.get('x-forwarded-proto') ?? 'unknown x-forwarded-proto',\n    xClerkAuthStatus: headerStore.get('x-clerk-auth-status') ?? 'unknown x-clerk-auth-status',\n    isCI: detectCIEnvironment(),\n  };\n}\n\n// Common CI environment variables\nconst CI_ENV_VARS = [\n  'CI',\n  'CONTINUOUS_INTEGRATION',\n  'BUILD_NUMBER',\n  'BUILD_ID',\n  'BUILDKITE',\n  'CIRCLECI',\n  'GITHUB_ACTIONS',\n  'GITLAB_CI',\n  'JENKINS_URL',\n  'TRAVIS',\n  'APPVEYOR',\n  'WERCKER',\n  'DRONE',\n  'CODESHIP',\n  'SEMAPHORE',\n  'SHIPPABLE',\n  'TEAMCITY_VERSION',\n  'BAMBOO_BUILDKEY',\n  'GO_PIPELINE_NAME',\n  'TF_BUILD',\n  'SYSTEM_TEAMFOUNDATIONCOLLECTIONURI',\n  'BITBUCKET_BUILD_NUMBER',\n  'HEROKU_TEST_RUN_ID',\n  'VERCEL',\n  'NETLIFY',\n];\n\n/**\n * Detects if the application is running in a CI environment\n */\nfunction detectCIEnvironment(): boolean {\n  const ciIndicators = CI_ENV_VARS;\n\n  const falsyValues = new Set<string>(['', 'false', '0', 'no']);\n\n  return ciIndicators.some(indicator => {\n    const value = process.env[indicator];\n    if (value === undefined) {\n      return false;\n    }\n\n    const normalizedValue = value.trim().toLowerCase();\n    return !falsyValues.has(normalizedValue);\n  });\n}\n\n/**\n * Extracts Next.js version from process title\n */\nfunction getNextVersion(): string | undefined {\n  try {\n    return process.title ?? 'unknown-process-title'; // 'next-server (v15.4.5)'\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Converts metadata to HTTP headers\n */\nexport async function formatMetadataHeaders(metadata: MetadataHeaders): Promise<Headers> {\n  const headers = new Headers();\n\n  if (metadata.nodeVersion) {\n    headers.set('Clerk-Node-Version', metadata.nodeVersion);\n  }\n\n  if (metadata.nextVersion) {\n    headers.set('Clerk-Next-Version', metadata.nextVersion);\n  }\n\n  if (metadata.npmConfigUserAgent) {\n    headers.set('Clerk-NPM-Config-User-Agent', metadata.npmConfigUserAgent);\n  }\n\n  if (metadata.userAgent) {\n    headers.set('Clerk-Client-User-Agent', metadata.userAgent);\n  }\n\n  if (metadata.port) {\n    headers.set('Clerk-Node-Port', metadata.port);\n  }\n\n  if (metadata.host) {\n    headers.set('Clerk-Client-Host', metadata.host);\n  }\n\n  if (metadata.xPort) {\n    headers.set('Clerk-X-Port', metadata.xPort);\n  }\n\n  if (metadata.xHost) {\n    headers.set('Clerk-X-Host', metadata.xHost);\n  }\n\n  if (metadata.xProtocol) {\n    headers.set('Clerk-X-Protocol', metadata.xProtocol);\n  }\n\n  if (metadata.xClerkAuthStatus) {\n    headers.set('Clerk-Auth-Status', metadata.xClerkAuthStatus);\n  }\n\n  if (metadata.isCI) {\n    headers.set('Clerk-Is-CI', 'true');\n  }\n\n  return headers;\n}\n"],"names":["registerServerReference","AppRenderSpan","AppRouteRouteHandlersSpan","BaseServerSpan","LoadComponentsSpan","LogSpanAllowList","MiddlewareSpan","NextNodeServerSpan","NextServerSpan","NextVanillaSpanAllowlist","NodeSpan","RenderSpan","ResolveMetadataSpan","RouterSpan","StartServerSpan","Set","isThenable","promise","then","BubbledError","SpanKind","SpanStatusCode","getTracer","isBubbledError","NEXT_OTEL_PERFORMANCE_PREFIX","process","env","api","NEXT_RUNTIME","require","err","context","propagation","trace","ROOT_CONTEXT","Error","constructor","bubble","result","error","closeSpanWithError","span","setAttribute","recordException","name","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","clientTraceDataSetter","set","carrier","key","value","push","NextTracerImpl","getTracerInstance","getContext","getTracePropagationData","activeContext","active","entries","inject","getActiveScopeSpan","getSpan","withPropagatedContext","fn","getter","getSpanContext","remoteContext","extract","with","args","type","fnOrOptions","fnOrEmpty","options","spanName","has","NEXT_OTEL_VERBOSE","hideSpan","spanContext","parentSpan","existingRootSpanId","getValue","isRootSpan","spanId","attributes","setValue","startActiveSpan","startTime","globalThis","performance","now","undefined","cleanedUp","onCleanup","delete","measure","split","pop","replace","match","toLowerCase","start","Object","length","res","catch","finally","wrap","tracer","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","getRootSpanAttributes","get","setRootSpanAttribute","DetachedPromise","resolve","reject","Promise","rej","ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML","META","ICON_MARK","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","a","b","i","completeMatch","j","tagIndex","subarray","removed","slice","MISSING_ROOT_TAGS_ERROR","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","buildId","truncated","originalHtml","includes","startsWith","partialHtmlDocument","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","hexHash","join","chainStreams","continueDynamicHTMLResume","continueDynamicPrerender","continueFizzStream","continueStaticFallbackPrerender","continueStaticPrerender","createBufferedTransformStream","createDocumentClosingStream","createRootLayoutValidatorStream","renderToInitialFizzStream","streamFromBuffer","streamFromString","streamToBuffer","streamToString","voidCatch","encoder","TextEncoder","streams","ReadableStream","controller","close","readable","writable","TransformStream","pipeTo","preventClose","nextStream","lastStream","str","enqueue","encode","chunk","stream","reader","getReader","chunks","read","Buffer","concat","signal","decoder","TextDecoder","fatal","string","aborted","decode","maxBufferByteLength","Infinity","bufferedChunks","bufferByteLength","pending","flush","copiedBytes","bufferedChunk","byteLength","scheduleFlush","detached","scheduleImmediate","transform","createPrefetchCommentStream","isBuildTimePrerendering","didTransformFirstChunk","chunkStr","updatedChunkStr","ReactDOMServer","element","streamOptions","renderToReadableStream","createMetadataTransformStream","insert","chunkIndex","isMarkRemoved","iconMarkIndex","closedHeadIndex","iconMarkLength","replaced","insertion","encodedInsertion","insertionLength","createHeadInsertionTransformStream","inserted","hasBytes","index","insertedHeadContent","createClientResumeScriptInsertionTransformStream","segmentPath","cacheBustingHeader","searchStr","NEXT_RSC_UNION_QUERY","NEXT_CLIENT_RESUME_SCRIPT","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","didAlreadyInsert","headClosingTagIndex","createDeferredSuffixStream","suffix","flushed","createFlightDataInjectionTransformStream","delayDataUntilFirstHtmlChunk","htmlStreamFinished","pull","donePulling","startOrContinuePulling","startPulling","atLeastOneTask","CLOSE_TAG","createMoveSuffixStream","foundSuffix","before","after","createStripDocumentClosingTagsTransform","foundHtml","foundBody","missingTags","map","c","chainTransformers","transformers","transformer","pipeThrough","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","allReady","prerenderStream","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","setReferenceManifestsSingleton","stringToUint8Array","__next_loaded_action_key","buffer","bytes","len","String","fromCharCode","binary","arr","charCodeAt","iv","data","crypto","subtle","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","clientReferenceManifestsPerPage","normalizeAppPath","serverActionsManifestSingleton","InvariantError","workStore","workAsyncStorage","getStore","mergeClientReferenceManifests","route","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","importKey","atob","clientReferenceManifests","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","textEncoder","textDecoder","filterStackFrame","NODE_ENV","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","actionId","arg","originalPayload","ivValue","payload","decrypted","encodeActionBoundArg","randomBytes","workUnitAsyncStorage","exit","getRandomValues","encrypted","btoa","ReadStatus","React","cache","workUnitStore","cacheSignal","getCacheSignal","captureStackTrace","didCatchError","hangingInputAbortSignal","createHangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","addEventListener","once","serialized","onError","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","encryptedPromise","decryptedBoundArgs","deserialized","createFromReadableStream","renderSignal","serverConsumerManifest","moduleLoading","moduleMap","ensureServerEntryExports","actions","action","headers"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}