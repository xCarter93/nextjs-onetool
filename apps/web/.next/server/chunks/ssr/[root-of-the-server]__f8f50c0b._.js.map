{"version":3,"sources":["../../../../../../node_modules/%40clerk/nextjs/dist/esm/chunk-BUSYA2B4.js","../../../../../../node_modules/%40clerk/nextjs/dist/esm/server/fs/utils.js","../../../../../../node_modules/%40clerk/nextjs/dist/esm/runtime/node/safe-node-apis.js","../../../../../../node_modules/%40clerk/nextjs/src/server/keyless-node.ts"],"sourcesContent":["var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\nexport {\n  __commonJS\n};\n//# sourceMappingURL=chunk-BUSYA2B4.js.map","import \"../../chunk-BUSYA2B4.js\";\nimport nodeRuntime from \"#safe-node-apis\";\nfunction assertNotNullable(value, moduleName) {\n  if (!value) {\n    throw new Error(`Clerk: ${moduleName} is missing. This is an internal error. Please contact Clerk's support.`);\n  }\n}\nconst nodeFsOrThrow = () => {\n  assertNotNullable(nodeRuntime.fs, \"fs\");\n  return nodeRuntime.fs;\n};\nconst nodePathOrThrow = () => {\n  assertNotNullable(nodeRuntime.path, \"path\");\n  return nodeRuntime.path;\n};\nconst nodeCwdOrThrow = () => {\n  assertNotNullable(nodeRuntime.cwd, \"cwd\");\n  return nodeRuntime.cwd;\n};\nexport {\n  nodeCwdOrThrow,\n  nodeFsOrThrow,\n  nodePathOrThrow\n};\n//# sourceMappingURL=utils.js.map","import {\n  __commonJS\n} from \"../../chunk-BUSYA2B4.js\";\nvar require_safe_node_apis = __commonJS({\n  \"src/runtime/node/safe-node-apis.js\"(exports, module) {\n    const { existsSync, writeFileSync, readFileSync, appendFileSync, mkdirSync, rmSync } = require(\"node:fs\");\n    const path = require(\"node:path\");\n    const fs = {\n      existsSync,\n      writeFileSync,\n      readFileSync,\n      appendFileSync,\n      mkdirSync,\n      rmSync\n    };\n    const cwd = () => process.cwd();\n    module.exports = { fs, path, cwd };\n  }\n});\nexport default require_safe_node_apis();\n//# sourceMappingURL=safe-node-apis.js.map","import type { AccountlessApplication } from '@clerk/backend';\n\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { nodeCwdOrThrow, nodeFsOrThrow, nodePathOrThrow } from './fs/utils';\nimport { collectKeylessMetadata, formatMetadataHeaders } from './keyless-custom-headers';\n\n/**\n * The Clerk-specific directory name.\n */\nconst CLERK_HIDDEN = '.clerk';\n\n/**\n * The Clerk-specific lock file that is used to mitigate multiple key creation.\n * This is automatically cleaned up.\n */\nconst CLERK_LOCK = 'clerk.lock';\n\n/**\n * The `.clerk/` directory is NOT safe to be committed as it may include sensitive information about a Clerk instance.\n * It may include an instance's secret key and the secret token for claiming that instance.\n */\nfunction updateGitignore() {\n  const { existsSync, writeFileSync, readFileSync, appendFileSync } = nodeFsOrThrow();\n\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n  const gitignorePath = path.join(cwd(), '.gitignore');\n  if (!existsSync(gitignorePath)) {\n    writeFileSync(gitignorePath, '');\n  }\n\n  // Check if `.clerk/` entry exists in .gitignore\n  const gitignoreContent = readFileSync(gitignorePath, 'utf-8');\n  const COMMENT = `# clerk configuration (can include secrets)`;\n  if (!gitignoreContent.includes(CLERK_HIDDEN + '/')) {\n    appendFileSync(gitignorePath, `\\n${COMMENT}\\n/${CLERK_HIDDEN}/\\n`);\n  }\n}\n\nconst generatePath = (...slugs: string[]) => {\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n  return path.join(cwd(), CLERK_HIDDEN, ...slugs);\n};\n\nconst _TEMP_DIR_NAME = '.tmp';\nconst getKeylessConfigurationPath = () => generatePath(_TEMP_DIR_NAME, 'keyless.json');\nconst getKeylessReadMePath = () => generatePath(_TEMP_DIR_NAME, 'README.md');\n\nlet isCreatingFile = false;\n\nexport function safeParseClerkFile(): AccountlessApplication | undefined {\n  const { readFileSync } = nodeFsOrThrow();\n  try {\n    const CONFIG_PATH = getKeylessConfigurationPath();\n    let fileAsString;\n    try {\n      fileAsString = readFileSync(CONFIG_PATH, { encoding: 'utf-8' }) || '{}';\n    } catch {\n      fileAsString = '{}';\n    }\n    return JSON.parse(fileAsString) as AccountlessApplication;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Using both an in-memory and file system lock seems to be the most effective solution.\n */\nconst lockFileWriting = () => {\n  const { writeFileSync } = nodeFsOrThrow();\n\n  isCreatingFile = true;\n\n  writeFileSync(\n    CLERK_LOCK,\n    // In the rare case, the file persists give the developer enough context.\n    'This file can be deleted. Please delete this file and refresh your application',\n    {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    },\n  );\n};\n\nconst unlockFileWriting = () => {\n  const { rmSync } = nodeFsOrThrow();\n\n  try {\n    rmSync(CLERK_LOCK, { force: true, recursive: true });\n  } catch {\n    // Simply ignore if the removal of the directory/file fails\n  }\n\n  isCreatingFile = false;\n};\n\nconst isFileWritingLocked = () => {\n  const { existsSync } = nodeFsOrThrow();\n  return isCreatingFile || existsSync(CLERK_LOCK);\n};\n\nasync function createOrReadKeyless(): Promise<AccountlessApplication | null> {\n  const { writeFileSync, mkdirSync } = nodeFsOrThrow();\n\n  /**\n   * If another request is already in the process of acquiring keys return early.\n   * Using both an in-memory and file system lock seems to be the most effective solution.\n   */\n  if (isFileWritingLocked()) {\n    return null;\n  }\n\n  lockFileWriting();\n\n  const CONFIG_PATH = getKeylessConfigurationPath();\n  const README_PATH = getKeylessReadMePath();\n\n  mkdirSync(generatePath(_TEMP_DIR_NAME), { recursive: true });\n  updateGitignore();\n\n  /**\n   * When the configuration file exists, always read the keys from the file\n   */\n  const envVarsMap = safeParseClerkFile();\n  if (envVarsMap?.publishableKey && envVarsMap?.secretKey) {\n    unlockFileWriting();\n\n    return envVarsMap;\n  }\n\n  /**\n   * At this step, it is safe to create new keys and store them.\n   */\n  const client = createClerkClientWithOptions({});\n\n  // Collect metadata\n  const keylessHeaders = await collectKeylessMetadata()\n    .then(formatMetadataHeaders)\n    .catch(() => new Headers());\n\n  const accountlessApplication = await client.__experimental_accountlessApplications\n    .createAccountlessApplication({ requestHeaders: keylessHeaders })\n    .catch(() => null);\n\n  if (accountlessApplication) {\n    writeFileSync(CONFIG_PATH, JSON.stringify(accountlessApplication), {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    });\n\n    // TODO-KEYLESS: Add link to official documentation.\n    const README_NOTIFICATION = `\n## DO NOT COMMIT\nThis directory is auto-generated from \\`@clerk/nextjs\\` because you are running in Keyless mode. Avoid committing the \\`.clerk/\\` directory as it includes the secret key of the unclaimed instance.\n  `;\n\n    writeFileSync(README_PATH, README_NOTIFICATION, {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    });\n  }\n  /**\n   * Clean up locks.\n   */\n  unlockFileWriting();\n\n  return accountlessApplication;\n}\n\nfunction removeKeyless() {\n  const { rmSync } = nodeFsOrThrow();\n\n  /**\n   * If another request is already in the process of acquiring keys return early.\n   * Using both an in-memory and file system lock seems to be the most effective solution.\n   */\n  if (isFileWritingLocked()) {\n    return undefined;\n  }\n\n  lockFileWriting();\n\n  try {\n    rmSync(generatePath(), { force: true, recursive: true });\n  } catch {\n    // Simply ignore if the removal of the directory/file fails\n  }\n\n  /**\n   * Clean up locks.\n   */\n  unlockFileWriting();\n}\n\nexport { createOrReadKeyless, removeKeyless };\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}