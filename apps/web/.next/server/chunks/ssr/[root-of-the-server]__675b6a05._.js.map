{"version":3,"sources":["../../../../../../node_modules/%40clerk/nextjs/dist/esm/chunk-BUSYA2B4.js","../../../../../../node_modules/%40clerk/nextjs/dist/esm/server/fs/utils.js","../../../../../../node_modules/%40clerk/nextjs/dist/esm/runtime/node/safe-node-apis.js","../../../../../../node_modules/%40clerk/nextjs/src/server/keyless-telemetry.ts"],"sourcesContent":["var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\nexport {\n  __commonJS\n};\n//# sourceMappingURL=chunk-BUSYA2B4.js.map","import \"../../chunk-BUSYA2B4.js\";\nimport nodeRuntime from \"#safe-node-apis\";\nfunction assertNotNullable(value, moduleName) {\n  if (!value) {\n    throw new Error(`Clerk: ${moduleName} is missing. This is an internal error. Please contact Clerk's support.`);\n  }\n}\nconst nodeFsOrThrow = () => {\n  assertNotNullable(nodeRuntime.fs, \"fs\");\n  return nodeRuntime.fs;\n};\nconst nodePathOrThrow = () => {\n  assertNotNullable(nodeRuntime.path, \"path\");\n  return nodeRuntime.path;\n};\nconst nodeCwdOrThrow = () => {\n  assertNotNullable(nodeRuntime.cwd, \"cwd\");\n  return nodeRuntime.cwd;\n};\nexport {\n  nodeCwdOrThrow,\n  nodeFsOrThrow,\n  nodePathOrThrow\n};\n//# sourceMappingURL=utils.js.map","import {\n  __commonJS\n} from \"../../chunk-BUSYA2B4.js\";\nvar require_safe_node_apis = __commonJS({\n  \"src/runtime/node/safe-node-apis.js\"(exports, module) {\n    const { existsSync, writeFileSync, readFileSync, appendFileSync, mkdirSync, rmSync } = require(\"node:fs\");\n    const path = require(\"node:path\");\n    const fs = {\n      existsSync,\n      writeFileSync,\n      readFileSync,\n      appendFileSync,\n      mkdirSync,\n      rmSync\n    };\n    const cwd = () => process.cwd();\n    module.exports = { fs, path, cwd };\n  }\n});\nexport default require_safe_node_apis();\n//# sourceMappingURL=safe-node-apis.js.map","import type { TelemetryEventRaw } from '@clerk/types';\n\nimport { canUseKeyless } from '../utils/feature-flags';\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { nodeFsOrThrow, nodePathOrThrow } from './fs/utils';\n\nconst EVENT_KEYLESS_ENV_DRIFT_DETECTED = 'KEYLESS_ENV_DRIFT_DETECTED';\nconst EVENT_SAMPLING_RATE = 1; // 100% sampling rate\nconst TELEMETRY_FLAG_FILE = '.clerk/.tmp/telemetry.json';\n\ntype EventKeylessEnvDriftPayload = {\n  publicKeyMatch: boolean;\n  secretKeyMatch: boolean;\n  envVarsMissing: boolean;\n  keylessFileHasKeys: boolean;\n  keylessPublishableKey: string;\n  envPublishableKey: string;\n};\n\n/**\n * Gets the absolute path to the telemetry flag file.\n *\n * This file is used to track whether telemetry events have already been fired\n * to prevent duplicate event reporting during the application lifecycle.\n *\n * @returns The absolute path to the telemetry flag file in the project's .clerk/.tmp directory\n */\nfunction getTelemetryFlagFilePath(): string {\n  const path = nodePathOrThrow();\n  return path.join(process.cwd(), TELEMETRY_FLAG_FILE);\n}\n\n/**\n * Attempts to create a telemetry flag file to mark that a telemetry event has been fired.\n *\n * This function uses the 'wx' flag to create the file atomically - it will only succeed\n * if the file doesn't already exist. This ensures that telemetry events are only fired\n * once per application lifecycle, preventing duplicate event reporting.\n *\n * @returns Promise<boolean> - Returns true if the flag file was successfully created (meaning\n *   the event should be fired), false if the file already exists (meaning the event was\n *   already fired) or if there was an error creating the file\n */\nfunction tryMarkTelemetryEventAsFired(): boolean {\n  try {\n    if (canUseKeyless) {\n      const { mkdirSync, writeFileSync } = nodeFsOrThrow();\n      const path = nodePathOrThrow();\n      const flagFilePath = getTelemetryFlagFilePath();\n      const flagDirectory = path.dirname(flagFilePath);\n\n      // Ensure the directory exists before attempting to write the file\n      mkdirSync(flagDirectory, { recursive: true });\n\n      const flagData = {\n        firedAt: new Date().toISOString(),\n        event: EVENT_KEYLESS_ENV_DRIFT_DETECTED,\n      };\n      writeFileSync(flagFilePath, JSON.stringify(flagData, null, 2), { flag: 'wx' });\n      return true;\n    } else {\n      return false;\n    }\n  } catch (error: unknown) {\n    if ((error as { code?: string })?.code === 'EEXIST') {\n      return false;\n    }\n    console.warn('Failed to create telemetry flag file:', error);\n    return false;\n  }\n}\n\n/**\n * Detects and reports environment drift between keyless configuration and environment variables.\n *\n * This function compares the Clerk keys stored in the keyless configuration file (.clerk/clerk.json)\n * with the keys set in environment variables (NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY and CLERK_SECRET_KEY).\n * It only reports drift when there's an actual mismatch between existing keys, not when keys are simply missing.\n *\n * The function handles several scenarios and only reports drift in specific cases:\n * - **Normal keyless mode**: env vars missing but keyless file has keys → no drift (expected)\n * - **No configuration**: neither env vars nor keyless file have keys → no drift (nothing to compare)\n * - **Actual drift**: env vars exist and don't match keyless file keys → drift detected\n * - **Empty keyless file**: keyless file exists but has no keys → no drift (nothing to compare)\n *\n * Drift is only detected when:\n * 1. Both environment variables and keyless file contain keys\n * 2. The keys in environment variables don't match the keys in the keyless file\n *\n * Telemetry events are only fired once per application lifecycle using a flag file mechanism\n * to prevent duplicate reporting.\n *\n * @returns Promise<void> - Function completes silently, errors are logged but don't throw\n */\nexport async function detectKeylessEnvDrift(): Promise<void> {\n  if (!canUseKeyless) {\n    return;\n  }\n  // Only run on server side\n  if (typeof window !== 'undefined') {\n    return;\n  }\n\n  try {\n    // Dynamically import server-side dependencies to avoid client-side issues\n    const { safeParseClerkFile } = await import('./keyless-node.js');\n\n    // Read the keyless configuration file\n    const keylessFile = safeParseClerkFile();\n\n    if (!keylessFile) {\n      return;\n    }\n\n    // Get environment variables\n    const envPublishableKey = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;\n    const envSecretKey = process.env.CLERK_SECRET_KEY;\n\n    // Check the state of environment variables and keyless file\n    const hasEnvVars = Boolean(envPublishableKey || envSecretKey);\n    const keylessFileHasKeys = Boolean(keylessFile?.publishableKey && keylessFile?.secretKey);\n    const envVarsMissing = !envPublishableKey && !envSecretKey;\n\n    // Early return conditions - no drift to detect in these scenarios:\n    if (!hasEnvVars && !keylessFileHasKeys) {\n      // Neither env vars nor keyless file have keys - nothing to compare\n      return;\n    }\n\n    if (envVarsMissing && keylessFileHasKeys) {\n      // Environment variables are missing but keyless file has keys - this is normal for keyless mode\n      return;\n    }\n\n    if (!keylessFileHasKeys) {\n      // Keyless file doesn't have keys, so no drift can be detected\n      return;\n    }\n\n    // Only proceed with drift detection if we have something meaningful to compare\n    if (!hasEnvVars) {\n      return;\n    }\n\n    // Compare keys only when both sides have values to compare\n    const publicKeyMatch = Boolean(\n      envPublishableKey && keylessFile.publishableKey && envPublishableKey === keylessFile.publishableKey,\n    );\n\n    const secretKeyMatch = Boolean(envSecretKey && keylessFile.secretKey && envSecretKey === keylessFile.secretKey);\n\n    // Determine if there's an actual drift:\n    // Drift occurs when we have env vars that don't match the keyless file keys\n    const hasActualDrift =\n      (envPublishableKey && keylessFile.publishableKey && !publicKeyMatch) ||\n      (envSecretKey && keylessFile.secretKey && !secretKeyMatch);\n\n    // Only fire telemetry if there's an actual drift (not just missing keys)\n    if (!hasActualDrift) {\n      return;\n    }\n\n    const payload: EventKeylessEnvDriftPayload = {\n      publicKeyMatch,\n      secretKeyMatch,\n      envVarsMissing,\n      keylessFileHasKeys,\n      keylessPublishableKey: keylessFile.publishableKey ?? '',\n      envPublishableKey: envPublishableKey ?? '',\n    };\n\n    // Create a clerk client to access telemetry\n    const clerkClient = createClerkClientWithOptions({\n      publishableKey: keylessFile.publishableKey,\n      secretKey: keylessFile.secretKey,\n      telemetry: {\n        samplingRate: 1,\n      },\n    });\n\n    const shouldFireEvent = tryMarkTelemetryEventAsFired();\n\n    if (shouldFireEvent) {\n      // Fire drift detected event only if we successfully created the flag\n      const driftDetectedEvent: TelemetryEventRaw<EventKeylessEnvDriftPayload> = {\n        event: EVENT_KEYLESS_ENV_DRIFT_DETECTED,\n        eventSamplingRate: EVENT_SAMPLING_RATE,\n        payload,\n      };\n\n      clerkClient.telemetry?.record(driftDetectedEvent);\n    }\n  } catch (error) {\n    // Silently handle errors to avoid breaking the application\n    console.warn('Failed to detect keyless environment drift:', error);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}