{"version":3,"sources":["../../../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../../../apps/web/src/env.ts","../../../../../apps/web/src/app/api/unsplash/route.ts","../../../../../node_modules/%40t3-oss/env-core/src/standard.ts","../../../../../node_modules/next/src/build/templates/app-route.ts","../../../../../node_modules/%40t3-oss/env-nextjs/src/index.ts","../../../../../node_modules/%40t3-oss/env-core/src/index.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/unsplash/route\",\n        pathname: \"/api/unsplash\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/apps/web/src/app/api/unsplash/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/unsplash/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n\tserver: {\n\t\tCLERK_SECRET_KEY: z.string().min(1),\n\t\tCLERK_USER_WEBHOOK_SECRET: z.string().min(1),\n\t\tCLERK_BILLING_WEBHOOK_SECRET: z.string().min(1),\n\t\tBOLDSIGN_API_KEY: z.string().min(1),\n\t\tBOLDSIGN_WEBHOOK_SECRET: z.string().optional(),\n\t\tOPENAI_API_KEY: z.string().min(1),\n\t\tUNSPLASH_ACCESS_KEY: z.string().min(1),\n\t\tUNSPLASH_SECRET_KEY: z.string().min(1),\n\t\tUNSPLASH_APP_ID: z.string().min(1),\n\t\tCLERK_ISSUER_DOMAIN: z.string().min(1),\n\t\tRESEND_API_KEY: z.string().min(1),\n\t\tRESEND_WEBHOOK_SECRET: z.string().min(1),\n\t\tSTRIPE_APPLICATION_FEE_CENTS: z.string().optional().default(\"100\"),\n\t},\n\tclient: {\n\t\tNEXT_PUBLIC_CONVEX_URL: z.string().min(1),\n\t\tNEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),\n\t\tNEXT_PUBLIC_CLERK_FRONTEND_API_URL: z.string().min(1),\n\t\tNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().min(1),\n\t},\n\texperimental__runtimeEnv: {\n\t\tNEXT_PUBLIC_CLERK_PUBLISHABLE_KEY:\n\t\t\tprocess.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,\n\t\tNEXT_PUBLIC_CONVEX_URL: process.env.NEXT_PUBLIC_CONVEX_URL,\n\t\tNEXT_PUBLIC_CLERK_FRONTEND_API_URL:\n\t\t\tprocess.env.NEXT_PUBLIC_CLERK_FRONTEND_API_URL,\n\t\tNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:\n\t\t\tprocess.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,\n\t},\n});\n","import { env } from \"@/env\";\nimport { NextResponse } from \"next/server\";\nimport type { UnsplashSearchResponse } from \"@/types/unsplash\";\n\nexport const revalidate = 3600; // Cache for 1 hour\n\nexport async function GET(request: Request) {\n\tconst { searchParams } = new URL(request.url);\n\tconst downloadUrl = searchParams.get(\"download\");\n\n\t// Handle download tracking\n\tif (downloadUrl) {\n\t\ttry {\n\t\t\tif (!env.UNSPLASH_ACCESS_KEY) {\n\t\t\t\tconsole.error(\"UNSPLASH_ACCESS_KEY is not defined\");\n\t\t\t\treturn NextResponse.json(\n\t\t\t\t\t{ error: \"Missing Unsplash API key\" },\n\t\t\t\t\t{ status: 500 }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate download URL to prevent SSRF\n\t\t\tlet url: URL;\n\t\t\ttry {\n\t\t\t\turl = new URL(downloadUrl);\n\t\t\t} catch {\n\t\t\t\treturn NextResponse.json(\n\t\t\t\t\t{ error: \"Invalid download URL\" },\n\t\t\t\t\t{ status: 400 }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Only allow HTTPS requests to Unsplash domains\n\t\t\tif (url.protocol !== \"https:\") {\n\t\t\t\treturn NextResponse.json(\n\t\t\t\t\t{ error: \"Only HTTPS URLs are allowed\" },\n\t\t\t\t\t{ status: 400 }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate hostname is an Unsplash domain\n\t\t\tconst hostname = url.hostname.toLowerCase();\n\t\t\tconst isUnsplashDomain =\n\t\t\t\thostname === \"api.unsplash.com\" || hostname.endsWith(\".unsplash.com\");\n\n\t\t\tif (!isUnsplashDomain) {\n\t\t\t\treturn NextResponse.json(\n\t\t\t\t\t{ error: \"Only Unsplash URLs are allowed\" },\n\t\t\t\t\t{ status: 400 }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Track download with authentication\n\t\t\tconst response = await fetch(url.toString(), {\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Client-ID ${env.UNSPLASH_ACCESS_KEY}`,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.error(`Unsplash download tracking error: ${response.status}`);\n\t\t\t}\n\n\t\t\treturn NextResponse.json({ success: true });\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error tracking download:\", error);\n\t\t\treturn NextResponse.json({ success: false });\n\t\t}\n\t}\n\n\t// Handle image search\n\ttry {\n\t\tconsole.log(\"Fetching from Unsplash API...\");\n\n\t\t// Verify API key exists\n\t\tif (!env.UNSPLASH_ACCESS_KEY) {\n\t\t\tconsole.error(\"UNSPLASH_ACCESS_KEY is not defined\");\n\t\t\tthrow new Error(\"Missing Unsplash API key\");\n\t\t}\n\n\t\t// Fetch 20 images with 'Small Business' query for cycling through\n\t\tconst response = await fetch(\n\t\t\t`https://api.unsplash.com/search/photos?query=small+business&per_page=30&orientation=portrait&order_by=relevant`,\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Client-ID ${env.UNSPLASH_ACCESS_KEY}`,\n\t\t\t\t},\n\t\t\t\tnext: {\n\t\t\t\t\trevalidate: 3600, // Cache for 1 hour\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error(`Unsplash API error: ${response.status} - ${errorText}`);\n\t\t\tthrow new Error(`Unsplash API error: ${response.statusText}`);\n\t\t}\n\n\t\tconst data: UnsplashSearchResponse = await response.json();\n\n\t\t// Transform the response to only include what we need\n\t\tconst photos = data.results.map((photo) => ({\n\t\t\tid: photo.id,\n\t\t\talt: photo.alt_description || \"Small business professional\",\n\t\t\turl: `${photo.urls.raw}&w=396&h=528&fit=crop&q=80`,\n\t\t\tdownloadLocation: photo.links.download_location,\n\t\t\tphotographer: {\n\t\t\t\tname: photo.user.name,\n\t\t\t\tusername: photo.user.username,\n\t\t\t\tprofileUrl: photo.user.links.html,\n\t\t\t},\n\t\t\tphotoUrl: photo.links.html,\n\t\t}));\n\n\t\treturn NextResponse.json(\n\t\t\t{\n\t\t\t\tphotos,\n\t\t\t\tfetchedAt: new Date().toISOString(),\n\t\t\t},\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Cache-Control\": \"public, s-maxage=3600, stale-while-revalidate=7200\",\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching Unsplash images:\", error);\n\n\t\t// Return fallback images (the original hardcoded ones)\n\t\treturn NextResponse.json(\n\t\t\t{\n\t\t\t\tphotos: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: \"fallback-1\",\n\t\t\t\t\t\talt: \"Field service team collaboration\",\n\t\t\t\t\t\turl: \"https://images.unsplash.com/photo-1557804506-669a67965ba0?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&h=528&q=80\",\n\t\t\t\t\t\tphotographer: { name: \"Unsplash\", username: \"unsplash\" },\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tid: \"fallback-2\",\n\t\t\t\t\t\talt: \"Professional working on tablet\",\n\t\t\t\t\t\turl: \"https://images.unsplash.com/photo-1485217988980-11786ced9454?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&h=528&q=80\",\n\t\t\t\t\t\tphotographer: { name: \"Unsplash\", username: \"unsplash\" },\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tid: \"fallback-3\",\n\t\t\t\t\t\talt: \"Team meeting and planning\",\n\t\t\t\t\t\turl: \"https://images.unsplash.com/photo-1559136555-9303baea8ebd?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&crop=focalpoint&fp-x=.4&w=396&h=528&q=80\",\n\t\t\t\t\t\tphotographer: { name: \"Unsplash\", username: \"unsplash\" },\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tid: \"fallback-4\",\n\t\t\t\t\t\talt: \"Modern office workspace\",\n\t\t\t\t\t\turl: \"https://images.unsplash.com/photo-1670272504528-790c24957dda?ixlib=rb-4.0.3&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&crop=left&w=400&h=528&q=80\",\n\t\t\t\t\t\tphotographer: { name: \"Unsplash\", username: \"unsplash\" },\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tid: \"fallback-5\",\n\t\t\t\t\t\talt: \"Technology and innovation\",\n\t\t\t\t\t\turl: \"https://images.unsplash.com/photo-1670272505284-8faba1c31f7d?ixlib=rb-4.0.3&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&h=528&q=80\",\n\t\t\t\t\t\tphotographer: { name: \"Unsplash\", username: \"unsplash\" },\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tfetchedAt: new Date().toISOString(),\n\t\t\t\tisFallback: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tstatus: 200,\n\t\t\t}\n\t\t);\n\t}\n}\n","/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n  /** The Standard Schema properties. */\n  readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\n\nexport declare namespace StandardSchemaV1 {\n  /** The Standard Schema properties interface. */\n  export interface Props<Input = unknown, Output = Input> {\n    /** The version number of the standard. */\n    readonly version: 1;\n    /** The vendor name of the schema library. */\n    readonly vendor: string;\n    /** Validates unknown input values. */\n    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n    /** Inferred types associated with the schema. */\n    readonly types?: Types<Input, Output> | undefined;\n  }\n\n  /** The result interface of the validate function. */\n  export type Result<Output> = SuccessResult<Output> | FailureResult;\n\n  /** The result interface if validation succeeds. */\n  export interface SuccessResult<Output> {\n    /** The typed output value. */\n    readonly value: Output;\n    /** The non-existent issues. */\n    readonly issues?: undefined;\n  }\n\n  /** The result interface if validation fails. */\n  export interface FailureResult {\n    /** The issues of failed validation. */\n    readonly issues: ReadonlyArray<Issue>;\n  }\n\n  /** The issue interface of the failure output. */\n  export interface Issue {\n    /** The error message of the issue. */\n    readonly message: string;\n    /** The path of the issue, if any. */\n    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n  }\n\n  /** The path segment interface of the issue. */\n  export interface PathSegment {\n    /** The key representing a path segment. */\n    readonly key: PropertyKey;\n  }\n\n  /** The Standard Schema types interface. */\n  export interface Types<Input = unknown, Output = Input> {\n    /** The input type of the schema. */\n    readonly input: Input;\n    /** The output type of the schema. */\n    readonly output: Output;\n  }\n\n  /** Infers the input type of a Standard Schema. */\n  export type InferInput<Schema extends StandardSchemaV1> = NonNullable<\n    Schema[\"~standard\"][\"types\"]\n  >[\"input\"];\n\n  /** Infers the output type of a Standard Schema. */\n  export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<\n    Schema[\"~standard\"][\"types\"]\n  >[\"output\"];\n}\n\nexport type StandardSchemaDictionary<\n  Input = Record<string, unknown>,\n  Output extends Record<keyof Input, unknown> = Input,\n> = {\n  [K in keyof Input]-?: StandardSchemaV1<Input[K], Output[K]>;\n};\n\nexport namespace StandardSchemaDictionary {\n  export type InferInput<T extends StandardSchemaDictionary> = {\n    [K in keyof T]: StandardSchemaV1.InferInput<T[K]>;\n  };\n  export type InferOutput<T extends StandardSchemaDictionary> = {\n    [K in keyof T]: StandardSchemaV1.InferOutput<T[K]>;\n  };\n}\n\nexport function ensureSynchronous<T>(value: T | Promise<T>, message: string): asserts value is T {\n  if (value instanceof Promise) {\n    throw new Error(message);\n  }\n}\n\nexport function parseWithDictionary<TDict extends StandardSchemaDictionary>(\n  dictionary: TDict,\n  value: Record<string, unknown>,\n): StandardSchemaV1.Result<StandardSchemaDictionary.InferOutput<TDict>> {\n  const result: Record<string, unknown> = {};\n  const issues: StandardSchemaV1.Issue[] = [];\n  for (const key in dictionary) {\n    const propResult = dictionary[key][\"~standard\"].validate(value[key]);\n\n    ensureSynchronous(propResult, `Validation must be synchronous, but ${key} returned a Promise.`);\n\n    if (propResult.issues) {\n      issues.push(\n        ...propResult.issues.map((issue) => ({\n          ...issue,\n          message: issue.message, // https://github.com/t3-oss/t3-env/pull/346\n          path: [key, ...(issue.path ?? [])],\n        })),\n      );\n      continue;\n    }\n    result[key] = propResult.value;\n  }\n  if (issues.length) {\n    return { issues };\n  }\n  return { value: result as never };\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","/**\n * This is the nextjs package of t3-env.\n * It contains the `createEnv` function that you can use to create your schema.\n * @module\n */\nimport type {\n  CreateEnv,\n  CreateSchemaOptions,\n  DefaultCombinedSchema,\n  ServerClientOptions,\n  StandardSchemaDictionary,\n  StandardSchemaV1,\n  StrictOptions,\n} from \"@t3-oss/env-core\";\nimport { createEnv as createEnvCore } from \"@t3-oss/env-core\";\n\nconst CLIENT_PREFIX = \"NEXT_PUBLIC_\";\ntype ClientPrefix = typeof CLIENT_PREFIX;\n\ntype Options<\n  TServer extends StandardSchemaDictionary,\n  TClient extends Record<`${ClientPrefix}${string}`, StandardSchemaV1>,\n  TShared extends StandardSchemaDictionary,\n  TExtends extends Array<Record<string, unknown>>,\n  TFinalSchema extends StandardSchemaV1<{}, {}>,\n> = Omit<\n  StrictOptions<ClientPrefix, TServer, TClient, TShared, TExtends> &\n    ServerClientOptions<ClientPrefix, TServer, TClient> &\n    CreateSchemaOptions<TServer, TClient, TShared, TFinalSchema>,\n  \"runtimeEnvStrict\" | \"runtimeEnv\" | \"clientPrefix\"\n> &\n  (\n    | {\n        /**\n         * Manual destruction of `process.env`. Required for Next.js < 13.4.4.\n         */\n        runtimeEnv: StrictOptions<\n          ClientPrefix,\n          TServer,\n          TClient,\n          TShared,\n          TExtends\n        >[\"runtimeEnvStrict\"];\n        experimental__runtimeEnv?: never;\n      }\n    | {\n        runtimeEnv?: never;\n        /**\n         * Can be used for Next.js ^13.4.4 since they stopped static analysis of server side `process.env`.\n         * Only client side `process.env` is statically analyzed and needs to be manually destructured.\n         */\n        experimental__runtimeEnv: Record<\n          | {\n              [TKey in keyof TClient]: TKey extends `${ClientPrefix}${string}` ? TKey : never;\n            }[keyof TClient]\n          | {\n              [TKey in keyof TShared]: TKey extends string ? TKey : never;\n            }[keyof TShared],\n          string | boolean | number | undefined\n        >;\n      }\n  );\n\n/**\n * Create a new environment variable schema.\n */\nexport function createEnv<\n  TServer extends StandardSchemaDictionary = NonNullable<unknown>,\n  TClient extends Record<`${ClientPrefix}${string}`, StandardSchemaV1> = NonNullable<unknown>,\n  TShared extends StandardSchemaDictionary = NonNullable<unknown>,\n  const TExtends extends Array<Record<string, unknown>> = [],\n  TFinalSchema extends StandardSchemaV1<{}, {}> = DefaultCombinedSchema<TServer, TClient, TShared>,\n>(\n  opts: Options<TServer, TClient, TShared, TExtends, TFinalSchema>,\n): CreateEnv<TFinalSchema, TExtends> {\n  const client = typeof opts.client === \"object\" ? opts.client : {};\n  const server = typeof opts.server === \"object\" ? opts.server : {};\n  const shared = opts.shared;\n\n  const runtimeEnv = opts.runtimeEnv\n    ? opts.runtimeEnv\n    : {\n        ...process.env,\n        ...opts.experimental__runtimeEnv,\n      };\n\n  return createEnvCore<ClientPrefix, TServer, TClient, TShared, TExtends, TFinalSchema>({\n    ...opts,\n    shared,\n    client,\n    server,\n    clientPrefix: CLIENT_PREFIX,\n    runtimeEnv,\n  });\n}\n","/**\n * This is the core package of t3-env.\n * It contains the `createEnv` function that you can use to create your schema.\n * @module\n */\nimport type { StandardSchemaDictionary, StandardSchemaV1 } from \"./standard.ts\";\nimport { ensureSynchronous, parseWithDictionary } from \"./standard.ts\";\n\nexport type {\n  /**\n   * The Standard Schema Interface\n   * @see https://github.com/standard-schema/standard-schema\n   * @internal\n   */\n  StandardSchemaV1,\n  /**\n   * A record with values being Standard Schema validators\n   * @see https://github.com/standard-schema/standard-schema\n   * @internal\n   */\n  StandardSchemaDictionary,\n};\n\n/**\n * Symbol for indicating type errors\n * @internal\n */\ntype ErrorMessage<T extends string> = T;\n\n/**\n * Simplify a type\n * @internal\n */\ntype Simplify<T> = {\n  [P in keyof T]: T[P];\n} & {};\n\n/**\n * Get the keys of the possibly undefined values\n * @internal\n */\ntype PossiblyUndefinedKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\n/**\n * Make the keys of the type possibly undefined\n * @internal\n */\ntype UndefinedOptional<T> = Partial<Pick<T, PossiblyUndefinedKeys<T>>> &\n  Omit<T, PossiblyUndefinedKeys<T>>;\n\n/**\n * Make the keys of the type impossible\n * @internal\n */\ntype Impossible<T extends Record<string, any>> = Partial<Record<keyof T, never>>;\n\n/**\n * Reverse a Readonly object to be mutable\n * @internal\n */\ntype Mutable<T> = T extends Readonly<infer U> ? U : T;\n\n/**\n * Reduce an array of records to a single object where later keys override earlier ones\n * @internal\n */\ntype Reduce<TArr extends Record<string, unknown>[], TAcc = object> = TArr extends []\n  ? TAcc\n  : TArr extends [infer Head, ...infer Tail]\n    ? Tail extends Record<string, unknown>[]\n      ? Mutable<Head> & Omit<Reduce<Tail, TAcc>, keyof Head>\n      : never\n    : never;\n\n/**\n * The options that can be passed to the `createEnv` function.\n */\nexport interface BaseOptions<\n  TShared extends StandardSchemaDictionary,\n  TExtends extends Array<Record<string, unknown>>,\n> {\n  /**\n   * How to determine whether the app is running on the server or the client.\n   * @default typeof window === \"undefined\"\n   */\n  isServer?: boolean;\n\n  /**\n   * Shared variables, often those that are provided by build tools and is available to both client and server,\n   * but isn't prefixed and doesn't require to be manually supplied. For example `NODE_ENV`, `VERCEL_URL` etc.\n   */\n  shared?: TShared;\n\n  /**\n   * Extend presets\n   */\n  extends?: TExtends;\n\n  /**\n   * Called when validation fails. By default the error is logged,\n   * and an error is thrown telling what environment variables are invalid.\n   */\n  onValidationError?: (issues: readonly StandardSchemaV1.Issue[]) => never;\n\n  /**\n   * Called when a server-side environment variable is accessed on the client.\n   * By default an error is thrown.\n   */\n  onInvalidAccess?: (variable: string) => never;\n\n  /**\n   * Whether to skip validation of environment variables.\n   * @default false\n   */\n  skipValidation?: boolean;\n\n  /**\n   * By default, this library will feed the environment variables directly to\n   * the Zod validator.\n   *\n   * This means that if you have an empty string for a value that is supposed\n   * to be a number (e.g. `PORT=` in a \".env\" file), Zod will incorrectly flag\n   * it as a type mismatch violation. Additionally, if you have an empty string\n   * for a value that is supposed to be a string with a default value (e.g.\n   * `DOMAIN=` in an \".env\" file), the default value will never be applied.\n   *\n   * In order to solve these issues, we recommend that all new projects\n   * explicitly specify this option as true.\n   */\n  emptyStringAsUndefined?: boolean;\n}\n\n/**\n * Using this interface doesn't validate all environment variables are specified\n * in the `runtimeEnv` object. You may want to use `StrictOptions` instead if\n * your framework performs static analysis and tree-shakes unused variables.\n */\nexport interface LooseOptions<\n  TShared extends StandardSchemaDictionary,\n  TExtends extends Array<Record<string, unknown>>,\n> extends BaseOptions<TShared, TExtends> {\n  runtimeEnvStrict?: never;\n\n  /**\n   * What object holds the environment variables at runtime. This is usually\n   * `process.env` or `import.meta.env`.\n   */\n  // Unlike `runtimeEnvStrict`, this doesn't enforce that all environment variables are set.\n  runtimeEnv: Record<string, string | boolean | number | undefined>;\n}\n\n/**\n * Using this interface validates all environment variables are specified\n * in the `runtimeEnv` object. If you miss one, you'll get a type error. Useful\n * if you want to make sure all environment variables are set for frameworks that\n * perform static analysis and tree-shakes unused variables.\n */\nexport interface StrictOptions<\n  TPrefix extends string | undefined,\n  TServer extends StandardSchemaDictionary,\n  TClient extends StandardSchemaDictionary,\n  TShared extends StandardSchemaDictionary,\n  TExtends extends Array<Record<string, unknown>>,\n> extends BaseOptions<TShared, TExtends> {\n  /**\n   * Runtime Environment variables to use for validation - `process.env`, `import.meta.env` or similar.\n   * Enforces all environment variables to be set. Required in for example Next.js Edge and Client runtimes.\n   */\n  runtimeEnvStrict: Record<\n    | {\n        [TKey in keyof TClient]: TPrefix extends undefined\n          ? never\n          : TKey extends `${TPrefix}${string}`\n            ? TKey\n            : never;\n      }[keyof TClient]\n    | {\n        [TKey in keyof TServer]: TPrefix extends undefined\n          ? TKey\n          : TKey extends `${TPrefix}${string}`\n            ? never\n            : TKey;\n      }[keyof TServer]\n    | {\n        [TKey in keyof TShared]: TKey extends string ? TKey : never;\n      }[keyof TShared],\n    string | boolean | number | undefined\n  >;\n  runtimeEnv?: never;\n}\n\n/**\n * This interface is used to define the client-side environment variables.\n * It's used in conjunction with the `clientPrefix` option to ensure\n * that all client-side variables are prefixed with the same string.\n * Common examples of prefixes are `NEXT_PUBLIC_`, `NUXT_PUBLIC` or `PUBLIC_`.\n */\nexport interface ClientOptions<\n  TPrefix extends string | undefined,\n  TClient extends StandardSchemaDictionary,\n> {\n  /**\n   * The prefix that client-side variables must have. This is enforced both at\n   * a type-level and at runtime.\n   */\n  clientPrefix: TPrefix;\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app isn't\n   * built with invalid env vars.\n   */\n  client: Partial<{\n    [TKey in keyof TClient]: TKey extends `${TPrefix}${string}`\n      ? TClient[TKey]\n      : ErrorMessage<`${TKey extends string ? TKey : never} is not prefixed with ${TPrefix}.`>;\n  }>;\n}\n\n/**\n * This interface is used to define the schema for your\n * server-side environment variables.\n */\nexport interface ServerOptions<\n  TPrefix extends string | undefined,\n  TServer extends StandardSchemaDictionary,\n> {\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app isn't\n   * built with invalid env vars.\n   */\n  server: Partial<{\n    [TKey in keyof TServer]: TPrefix extends undefined\n      ? TServer[TKey]\n      : TPrefix extends \"\"\n        ? TServer[TKey]\n        : TKey extends `${TPrefix}${string}`\n          ? ErrorMessage<`${TKey extends `${TPrefix}${string}`\n              ? TKey\n              : never} should not prefixed with ${TPrefix}.`>\n          : TServer[TKey];\n  }>;\n}\n\nexport interface CreateSchemaOptions<\n  TServer extends StandardSchemaDictionary,\n  TClient extends StandardSchemaDictionary,\n  TShared extends StandardSchemaDictionary,\n  TFinalSchema extends StandardSchemaV1<{}, {}>,\n> {\n  /**\n   * A custom function to combine the schemas.\n   * Can be used to add further refinement or transformation.\n   */\n  createFinalSchema?: (shape: TServer & TClient & TShared, isServer: boolean) => TFinalSchema;\n}\n\nexport type ServerClientOptions<\n  TPrefix extends string | undefined,\n  TServer extends StandardSchemaDictionary,\n  TClient extends StandardSchemaDictionary,\n> =\n  | (ClientOptions<TPrefix, TClient> & ServerOptions<TPrefix, TServer>)\n  | (ServerOptions<TPrefix, TServer> & Impossible<ClientOptions<never, never>>)\n  | (ClientOptions<TPrefix, TClient> & Impossible<ServerOptions<never, never>>);\n\nexport type EnvOptions<\n  TPrefix extends string | undefined,\n  TServer extends StandardSchemaDictionary,\n  TClient extends StandardSchemaDictionary,\n  TShared extends StandardSchemaDictionary,\n  TExtends extends Array<Record<string, unknown>>,\n  TFinalSchema extends StandardSchemaV1<{}, {}>,\n> = (\n  | (LooseOptions<TShared, TExtends> & ServerClientOptions<TPrefix, TServer, TClient>)\n  | (StrictOptions<TPrefix, TServer, TClient, TShared, TExtends> &\n      ServerClientOptions<TPrefix, TServer, TClient>)\n) &\n  CreateSchemaOptions<TServer, TClient, TShared, TFinalSchema>;\n\ntype TPrefixFormat = string | undefined;\ntype TServerFormat = StandardSchemaDictionary;\ntype TClientFormat = StandardSchemaDictionary;\ntype TSharedFormat = StandardSchemaDictionary;\ntype TExtendsFormat = Array<Record<string, unknown>>;\n\nexport type DefaultCombinedSchema<\n  TServer extends TServerFormat,\n  TClient extends TClientFormat,\n  TShared extends TSharedFormat,\n> = StandardSchemaV1<\n  {},\n  UndefinedOptional<StandardSchemaDictionary.InferOutput<TServer & TClient & TShared>>\n>;\n\nexport type CreateEnv<\n  TFinalSchema extends StandardSchemaV1<{}, {}>,\n  TExtends extends TExtendsFormat,\n> = Readonly<Simplify<Reduce<[StandardSchemaV1.InferOutput<TFinalSchema>, ...TExtends]>>>;\n\n/**\n * Create a new environment variable schema.\n */\nexport function createEnv<\n  TPrefix extends TPrefixFormat,\n  TServer extends TServerFormat = NonNullable<unknown>,\n  TClient extends TClientFormat = NonNullable<unknown>,\n  TShared extends TSharedFormat = NonNullable<unknown>,\n  const TExtends extends TExtendsFormat = [],\n  TFinalSchema extends StandardSchemaV1<{}, {}> = DefaultCombinedSchema<TServer, TClient, TShared>,\n>(\n  opts: EnvOptions<TPrefix, TServer, TClient, TShared, TExtends, TFinalSchema>,\n): CreateEnv<TFinalSchema, TExtends> {\n  const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? process.env;\n\n  const emptyStringAsUndefined = opts.emptyStringAsUndefined ?? false;\n  if (emptyStringAsUndefined) {\n    for (const [key, value] of Object.entries(runtimeEnv)) {\n      if (value === \"\") {\n        delete runtimeEnv[key];\n      }\n    }\n  }\n\n  const skip = !!opts.skipValidation;\n  if (skip) {\n    if (opts.extends) {\n      for (const preset of opts.extends) {\n        preset.skipValidation = true;\n      }\n    }\n\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    return runtimeEnv as any;\n  }\n\n  const _client = typeof opts.client === \"object\" ? opts.client : {};\n  const _server = typeof opts.server === \"object\" ? opts.server : {};\n  const _shared = typeof opts.shared === \"object\" ? opts.shared : {};\n  const isServer = opts.isServer ?? (typeof window === \"undefined\" || \"Deno\" in window);\n\n  const finalSchemaShape = isServer\n    ? {\n        ..._server,\n        ..._shared,\n        ..._client,\n      }\n    : {\n        ..._client,\n        ..._shared,\n      };\n\n  const finalSchema = opts.createFinalSchema?.(finalSchemaShape as never, isServer);\n  const parsed =\n    finalSchema?.[\"~standard\"].validate(runtimeEnv) ??\n    parseWithDictionary(finalSchemaShape, runtimeEnv);\n\n  ensureSynchronous(parsed, \"Validation must be synchronous\");\n\n  const onValidationError =\n    opts.onValidationError ??\n    ((issues) => {\n      console.error(\" Invalid environment variables:\", issues);\n      throw new Error(\"Invalid environment variables\");\n    });\n\n  const onInvalidAccess =\n    opts.onInvalidAccess ??\n    (() => {\n      throw new Error(\" Attempted to access a server-side environment variable on the client\");\n    });\n\n  if (parsed.issues) {\n    return onValidationError(parsed.issues);\n  }\n\n  const isServerAccess = (prop: string) => {\n    if (!opts.clientPrefix) return true;\n    return !prop.startsWith(opts.clientPrefix) && !(prop in _shared);\n  };\n  const isValidServerAccess = (prop: string) => {\n    return isServer || !isServerAccess(prop);\n  };\n  const ignoreProp = (prop: string) => {\n    return prop === \"__esModule\" || prop === \"$$typeof\";\n  };\n\n  const extendedObj = (opts.extends ?? []).reduce((acc, curr) => {\n    return Object.assign(acc, curr);\n  }, {});\n  const fullObj = Object.assign(extendedObj, parsed.value);\n\n  const env = new Proxy(fullObj, {\n    get(target, prop) {\n      if (typeof prop !== \"string\") return undefined;\n      if (ignoreProp(prop)) return undefined;\n      if (!isValidServerAccess(prop)) return onInvalidAccess(prop);\n      return Reflect.get(target, prop);\n    },\n    // Maybe reconsider this in the future:\n    // https://github.com/t3-oss/t3-env/pull/111#issuecomment-1682931526\n    // set(_target, prop) {\n    //   // Readonly - this is the error message you get from assigning to a frozen object\n    //   throw new Error(\n    //     typeof prop === \"string\"\n    //       ? `Cannot assign to read only property ${prop} of object #<Object>`\n    //       : `Cannot assign to read only property of object #<Object>`\n    //   );\n    // },\n  });\n\n  return env as any;\n}\n"],"names":["patchFetch","getRequestMeta","result: Record<string, unknown>","setReferenceManifestsSingleton","NodeNextRequest","NodeNextResponse","NextRequestAdapter","BaseServerSpan","getRevalidateReason","sendResponse","createEnvCore","INFINITE_CACHE","userland","env","__NEXT_RELATIVE_DIST_DIR"],"mappings":"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","ignoreList":[0,3,4,5,6]}